{"meta":{"title":"Derek Zhu's Blog","subtitle":"Derek Blog","description":"Derek Blog, originated from my notes","author":"Derek Zhu","url":"https://RedRe4per.github.io","root":"/"},"pages":[],"posts":[{"title":"Traverse objects and arrays","slug":"JavaScript/ES6/6 Traverse objects and arrays","date":"2023-04-18T22:49:04.000Z","updated":"2023-09-11T02:58:01.588Z","comments":true,"path":"2023/04/19/JavaScript/ES6/6 Traverse objects and arrays/","link":"","permalink":"https://redre4per.github.io/2023/04/19/JavaScript/ES6/6%20Traverse%20objects%20and%20arrays/","excerpt":"","text":"Traverse the object: for…in loops through the object’s own and inherited enumerable properties Loops through the object’s own and inherited enumerable properties (excluding Symbol properties). 1234var obj = &#123;&#x27;0&#x27;:&#x27;a&#x27;, &#x27;1&#x27;:&#x27;b&#x27;, &#x27;2&#x27;:&#x27;c&#x27;&#125;;for(var i in obj)&#123;console.log(i, &quot;:&quot;, obj[i]);&#125; result: 1230:a1:b2:c Traverse objects: Object.keys() Returns an array, including all enumerable properties (excluding Symbol properties) of the object itself (excluding inherited ones). 1234var obj = &#123;&#x27;0&#x27;:&#x27;a&#x27;, &#x27;1&#x27;:&#x27;b&#x27;, &#x27;2&#x27;:&#x27;c&#x27;&#125;;Object.keys(obj).forEach(function(key)&#123; console.log(key, obj[key]);&#125;); result: 1230a1b2c Traverse objects: Object.keys(obj), Object.values(obj) 123const obj = &#123;id:1, name:&quot;Derek&quot;, age:18&#125;;console.log(Object.keys(obj));console.log(Object.values(obj)); result: 12[&#x27;id&#x27;, &#x27;name&#x27;, &#x27;age&#x27;][&#x27;1&#x27;, &#x27;Derek&#x27;, &#x27;18&#x27;] Traverse objects: Object.getOwnPropertyNames(obj) Returns an array containing all properties of the object itself (excluding Symbol properties, but including non-enumerable properties). 12345var obj = &#123;&#x27;0&#x27;:&#x27;a&#x27;,&#x27;1&#x27;:&#x27;b&#x27;,&#x27;2&#x27;:&#x27;c&#x27;&#125;; Object.getOwnPropertyNames(obj).forEach(function(key)&#123; console.log(key,obj[key]);&#125;); Traverse objects: Reflect.ownKeys(obj) 12345var obj = &#123;&#x27;0&#x27;:&#x27;a&#x27;,&#x27;1&#x27;:&#x27;b&#x27;,&#x27;2&#x27;:&#x27;c&#x27;&#125;; Reflect.ownKeys(obj).forEach(function(key)&#123;console.log(key,obj[key]);&#125;); result: 1230a1b2c Traverse objects: Object.entries() Object.entries() is a method in JavaScript that returns an array of key-value pairs for a given object’s own enumerable properties, the order of the key-value pairs in the array and the order of using for...in loops Same (the main difference between the two is that the for-in loop also enumerates the properties in the prototype chain). Let’s say you have the following objects: 12345const obj = &#123; a: &quot;hello&quot;, b: &quot;world&quot;, c: &quot;!&quot;&#125;; If you call Object.entries(obj) you will get: 12345[ [&#x27;a&#x27;, &#x27;hello&#x27;], [&#x27;b&#x27;, &#x27;world&#x27;], [&#x27;c&#x27;, &#x27;!&#x27;]] In the code you gave, Object.entries(fontSize) converts each property of the fontSize object into an array of the form [key, value], and then uses the map method to map each key value Perform some operations on. In this operation, it creates a new HeadingBasestyle component and uses headingName (key) as the key property of the component and headingSize (value) as the headingsize property. headingName is also used Used as a child element of a component. Overall, Object.entries() is a way to get a list of key-value pairs from an object, which is useful when you need to perform operations on each property of the object. Traverse the array: forEach() 1234var arr=[1, 2, 3, 4];arr.forEach(function(val, index)&#123;console.log(val, index)&#125;); result: 12341 0twenty one3 24 3 Traverse the array: for..in.. 1234var arr=[&#x27;Derek&#x27;, &#x27;Tom&#x27;, &#x27;Jason&#x27;, &#x27;Tim&#x27;];for(var i in arr)&#123; console.log(i, &quot;:&quot;, arr[i]);&#125; result: 12340:Derek1:Tom2: Jason3: Tim Traverse array: for-of Not only arrays are supported, but also most array-like objects, such as DOM NodeList objects. String traversal is also supported, which traverses strings as a series of Unicode characters. 1234var arr=[&#x27;Derek&#x27;, &#x27;Tom&#x27;, &#x27;Jason&#x27;, &#x27;Tim&#x27;];for(var value of arr)&#123; console.log(value);&#125; result: 1234DerekTomJasonTim","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"ES6","slug":"JS-TS/ES6","permalink":"https://redre4per.github.io/categories/JS-TS/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://redre4per.github.io/tags/ES6/"}]},{"title":"Promise Advanced","slug":"JavaScript/ES6/5 Promise advanced","date":"2023-04-12T10:36:12.000Z","updated":"2023-09-11T02:58:59.748Z","comments":true,"path":"2023/04/12/JavaScript/ES6/5 Promise advanced/","link":"","permalink":"https://redre4per.github.io/2023/04/12/JavaScript/ES6/5%20Promise%20advanced/","excerpt":"","text":"Promise.all() and Promise.allSettled() Promise.all and Promise.allSettled are both methods for handling multiple concurrent Promises, but they differ in how they handle successful and failed Promises. Promise.all Promise.all accepts an array of Promise as parameters. When all Promises are resolved, Promise.all is also resolved, and the return value is an array containing the results of all successful Promises. If any Promise fails (rejected), Promise.all will also immediately fail (rejected), and the return value is the reason for the first failed Promise. This means that if you use Promise.all, if one Promise fails, the entire Promise.all will fail immediately before all Promises have completed. Therefore, Promise.all is more suitable for scenarios where all Promises need to succeed. 1234567javascriptCopy codePromise.all([promise1, promise2, promise3]) .then((results) =&gt; &#123; // All promises fulfilled successfully &#125;) .catch((error) =&gt; &#123; // At least one promise was rejected &#125;); Promise.allSettled Promise.allSettled also accepts an array of Promise as parameters. Promise.allSettled will wait for all Promises to complete, regardless of whether each Promise succeeds or fails. Promise.allSettled succeeds (resolved) when all Promises are completed (regardless of success or failure), and the return value is an array containing the status of all Promise (success or failure). Each element in the array is an object that contains a status property (with a value of &quot;fulfilled&quot; or &quot;rejected&quot;) and a value (the result on success) or reason (on failure time reason) attribute. This means that if you use Promise.allSettled, even if one or more Promises fail, the entire Promise.allSettled will still succeed and return the final status of all Promises. Therefore, Promise.allSettled is more suitable for scenarios where you need to know the final status of all Promises, not just the success status. 123456789101112131415const promise1 = Promise.resolve(3);const promise2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 100, &#x27;Error&#x27;));const promise3 = Promise.resolve(5); Promise.all([promise1, promise2, promise3]) .then(console.log) .catch(console.error); // Output: Error (because promise2 was rejected) Promise.allSettled([promise1, promise2, promise3]) .then(console.log) .catch(console.error); // Output: [ // &#123; status: &quot;fulfilled&quot;, value: 3 &#125;, // &#123; status: &quot;rejected&quot;, reason: &quot;Error&quot; Example: Music Player 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121interface ArtistResults &#123;status: &quot;fulfilled&quot; | &quot;rejected&quot;;value: IBanner;&#125;interface AlbumListResults &#123;status: &quot;fulfilled&quot; | &quot;rejected&quot;;value: IAlbumList;&#125;function getRandomInt() &#123;return Math.floor(Math.random() * 10);&#125;async function getArtist(areaCode: AreaCode) &#123;const randomInteger = Math.floor(Math.random() * 100000) + 1;const artistRes = await fetch( `$&#123; process.env.NEXT_PUBLIC_SERVER_ADDRESS &#125;/artist/list?area=$&#123;areaCode&#125;&amp;limit=1&amp;offset=$&#123;getRandomInt()&#125;&amp;timestamp=$&#123; Date.now() - randomInteger &#125;`);const artistArray = await artistRes.json();const artist = artistArray.artists[0];const artistSongRes = await fetch( `$&#123;process.env.NEXT_PUBLIC_SERVER_ADDRESS&#125;/artists?id=$&#123; artist.id &#125;&amp;limit=6&amp;order=time&amp;timestamp=$&#123;Date.now() - randomInteger&#125;`);const artistDetails = await artistSongRes.json();const artistSongsDetails = artistDetails.hotSongs.slice(0, 6) as IAlbumSong[];const artistSongs = artistSongsDetails.map((song) =&gt; &#123; return &#123; name: song.name, id: song.id, image: song.al.picUrl, &#125;;&#125;);const colorRes = await fetch( `$&#123; process.env.NEXT_PUBLIC_CLIENT_ADDRESS &#125;/api/colorExtract?imageUrl=$&#123;convertToHttps(artist.picUrl)&#125;`);const color = await colorRes.json();const banner: IBanner = &#123; artistId: artist.id, artistName: artist.name, artistCover: convertToHttps(artist.picUrl) as string, artistAreaCode: areaCode, artistAlias: artist.alias, bgColor: color.dominantColor, artistSongs: artistSongs,&#125;;return banner;&#125;export async function fetchArtistsInfo(areas: AreaCode[]) &#123;try &#123; const promises = areas.map((area: AreaCode) =&gt; getArtist(area)); const results = await Promise.allSettled(promises); const filteredResults = results.filter( (result) =&gt; result.status === &quot;fulfilled&quot; ) as ArtistResults[]; const resultAlbums = filteredResults.map((results: ArtistResults) =&gt; &#123; return results.value; &#125;); return resultAlbums;&#125; catch (error) &#123; console.error(&quot;Error fetching data:&quot;, error); throw error;&#125;&#125;async function getAlbumLists(area: AlbumArea) &#123;const albumRes = await fetch( `$&#123;process.env.NEXT_PUBLIC_SERVER_ADDRESS&#125;/album/list/style?area=$&#123;area&#125;&amp;limit=13`);const rawAlbumLists = await albumRes.json();const albumLists = &#123; ...rawAlbumLists, title: albumAreaMapper(area), path: `album/list/style?area=$&#123;area&#125;&amp;`,&#125;;return albumLists;&#125;export async function fetchAlbumListInfo(albumAreas: AlbumArea[]) &#123;try &#123; const promises = albumAreas.map((albumArea: AlbumArea) =&gt; getAlbumLists(albumArea) ); const results = await Promise.allSettled(promises); const filteredResults = results.filter( (result) =&gt; result.status === &quot;fulfilled&quot; ) as AlbumListResults[]; const resultAlbumLists = filteredResults.map( (results: AlbumListResults) =&gt; &#123; return results.value; &#125; ); return resultAlbumLists;&#125; catch (error) &#123; console.error(&quot;Error in fetching area album lists data:&quot;, error); throw error;&#125;&#125;export async function getPlaylistList(playListType: &quot;/highquality&quot; | &quot;&quot;) &#123;const topPlaylistListResponse = await fetch( `$&#123;process.env.NEXT_PUBLIC_SERVER_ADDRESS&#125;/top/playlist$&#123;playListType&#125;?limit=13`);const rawTopLists = await topPlaylistListResponse.json();const topPlaylistList = await playlistsGroupTranslator(rawTopLists);return &#123; ...topPlaylistList, path: `top/playlist$&#123;playListType&#125;?` &#125;;&#125;","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"ES6","slug":"JS-TS/ES6","permalink":"https://redre4per.github.io/categories/JS-TS/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://redre4per.github.io/tags/ES6/"},{"name":"Promise","slug":"Promise","permalink":"https://redre4per.github.io/tags/Promise/"}]},{"title":"Promise basic","slug":"JavaScript/ES6/4 Promise basic","date":"2022-11-06T07:07:12.000Z","updated":"2023-09-11T01:16:03.606Z","comments":true,"path":"2022/11/06/JavaScript/ES6/4 Promise basic/","link":"","permalink":"https://redre4per.github.io/2022/11/06/JavaScript/ES6/4%20Promise%20basic/","excerpt":"","text":"Promise: A new solution for asynchronous programming introduced in ES6. Promises are mainly to solve the previous problem of callback hell. Promise is a constructor that encapsulates an asynchronous operation and can get its success or failure result. Promise accepts a function parameter, this function parameter has two formal parameters, the first is success (resolved by default), and the second is failure (reject by default). When calling resolve() Promise takes the success path, calling reject() takes the failure path. 1234567891011//Instantiate a Promise objectconst p = new Promise(function(resolve, reject)&#123; //resolve &amp; reject. It&#x27;s just an unspoken rule, you can name it yourself setTimeout(function()&#123; let data = &#x27;obj in database&#x27;; if(Math.random()&gt;0.5)&#123; resolve(data); //custom &#x27;success&#x27; &#125;else&#123; reject(data); //custom &#x27;failure&#x27; &#125; &#125;, 1000);&#125;); After success or failure, the then() method of the Promise object can be called. The then() method accepts two function-type parameters. Both function parameters have formal parameters. The successful formal parameter is generally called value, and the failed formal parameter is generally called reason. 1p.then(function(value)&#123;&#125;, function(reason)&#123;&#125;) The first function argument in then() is called when the Promise status is fulfilled. where value is the parameter of the previous resolve(). 123p.then(function(value)&#123; console.log(value) //The value value is the parameter passed in by resolve() in the previous Promise&#125;, function(reason)&#123;&#125;) When the Promise status is rejected, the second function argument in then() is called. where the reason value is the parameter of the previous reject(). 1234p.then(function(value)&#123; &#125;,function(reason)&#123; console.log(reason) //The reason value is the parameter passed in by reject() in the previous Promise.&#125;) Promise encapsulates an example of an Ajax request. Ajax request for JS in ES5 123456789101112const xhr = new XMLHttpRequest(); //The first step: create an objectxhr.open(&quot;GET&quot;,&quot;http://api.apiopen.top/getJoke&quot;); //Part 2: Initializationxhr.send(); //The third step: sendxhr.onreadystatechange = function()&#123; //Step 4: Bind events and process response results if(xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123; console.log(xhr.response); //Processing successful results &#125;else&#123; console.error(xhr.status); //Process the result of failure &#125; &#125;&#125; Encapsulating Ajax with Promises 123456789101112131415161718192021const p = new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;,&quot;http://api.apiopen.top/getJoke&quot;); xhr.send(); xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123; resolve(xhr.response); //Declare success first, and pass parameters to then() before processing &#125;else&#123; reject(xhr.status); //Declare failure first, and pass parameters to then() before processing &#125; &#125; &#125;&#125;)// Specify success/failure callbackp.then(function(value)&#123; console.log(value) //Success, pass in the parameter xhr.response of resolve() as the actual parameter of the formal parameter value.&#125;,function(reason)&#123; console.err(reason) //If it fails, pass in the parameter xhr.status of reject() as the actual parameter of the formal parameter reason.&#125;) This example shows that Promises handle asynchronous success&#x2F;failure results differently than in ES5. It turns out that ES5 operates in the callback function, and now the callback is specified by the then() method after the asynchronous task. This is clearly structured and doesn’t create callback hell problems. then() function Promise instances have a then() method, that is, the then() method is defined on the prototype object Promise.prototype. Parameter 2 is optional. The return result of then() is also a Promise object. 12345678910111213const p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;ERROR!&#x27;) &#125;, 1000)&#125;)const result = p.then(value =&gt; &#123; console.log(value)&#125;, reason =&gt; &#123; console.warn(reason)&#125;)console.log(result); //The result is a Promise object, and the result is resolved/fulfilled (new version) The return result of the then() method The state of the Promise object is determined by the execution result of the callback function. If the result returned in the callback function is non promise type data, status is success, and the return value is the success value of the object. 12345678const result = p.then(value =&gt; &#123; console.log(value) return &#x27;success!&#x27;;&#125;, reason =&gt; &#123; console.warn(reason)&#125;)console.log(result); //The status of the result is &#x27;resolved&#x27; and the value is &#x27;success!&#x27;. When no return is written, the default return result inside the function is undefined. undefined is not a Promise type object, so the return status result is also success. 12345678const result = p.then(value =&gt; &#123; console.log(value) //return &#x27;success!&#x27;; no return&#125;, reason =&gt; &#123; console.warn(reason)&#125;)console.log(result); //The status of the result is &#x27;resolved&#x27; and the value is undefined. If the result returned in the callback function is a promise object, the state returned by the internal promise object determines the return of the then() method The state of the promise, and the value of the internal promise is the value of the promise returned by the then() method. 12345678910const result = p.then(value =&gt; &#123; console.log(value) return new Promise((resolve, reject) =&gt; &#123; //The return status of this promise determines the status of the promise returned by the then() method. resolve(&#x27;ok&#x27;); &#125;)&#125;, reason =&gt; &#123; console.warn(reason)&#125;)console.log(result); //The status of the result is &#x27;resolved&#x27; and the value is &#x27;ok&#x27;. 123456789const result = p.then(value =&gt; &#123; console.log(value) return new Promise((resolve, reject) =&gt; &#123; //reject, similarly reject(&#x27;error&#x27;); &#125;, reason =&gt; &#123; console.warn(reason)&#125;)console.log(result); //The status of the result is &#x27;rejected&#x27; and the value is error. If an error is thrown, then() returns a promise with a status of rejected and value as the value of the thrown error. Note that throw new Error(&#39;test&#39;); and reject(new Error(&#39;test&#39;)); are equivalent. 123456789const result = p.then(value =&gt; &#123; console.log(value) throw new Error(&#x27;Error diagnosis&#x27;) //Throwing an error, there is a throw, such as throw &#x27;ERROR&#x27;; also acceptable. &#125;)&#125;, reason =&gt; &#123; console.warn(reason)&#125;)console.log(result); //The status of the result is &#x27;rejected&#x27; and the value is &#x27;Error diagnosis&#x27;. The chained invocation of the then() method, and the reason parameter can be omitted 1234p.then(value =&gt; &#123;&#125;).then(value =&gt; &#123;&#125;).then(value =&gt; &#123;&#125;) Callback hell can be avoided by chaining calls. Chain call example: Each call passes in new data and saves all data on the chain. 12345678910111213141516171819202122const p = new Promise((resolve, reject) =&gt; &#123; //The first promise on the chain fs.readFile(&quot;./resources/file1.md&quot;, (err, data) =&gt; &#123; //node.js syntax resolve(data); &#125;);&#125;);p.then(value =&gt; &#123; //The 2nd promise on the chain return new Promise((resolve, reject) =&gt; &#123; fs.readFile(&quot;./resources/file2.md&quot;, (err, data) =&gt; &#123; resolve([value, data]); //The value is the data of file1, and the data is the data of file2. &#125;); &#125;);&#125;).then(value =&gt; &#123; //The 3rd promise on the chain。Note that value here is the resolve value of the second promise on the chain:[value, data], which is the data of file1 and file2. return new Promise((resolve, reject) =&gt; &#123; fs.readFile(&quot;./resources/file3.md&quot;, (err, data) =&gt; &#123; value.push(data); resolve(value); &#125;); &#125;);&#125;).then(value =&gt; &#123; //The value value is the content (array of) of the first three files console.log(value.join(&#x27;\\r\\n&#x27;)); //combine&#125;) Break the Promise chain In promise chains without catch(), each then() on the chain has two function arguments, success and failure. But note that whether it succeeds or fails (return non-Promise, return a successful Promise, throw an error), it will trigger then() on the next chain. If you want to end the chain call directly after a then() in the chain fails to trigger, you need to call a Promise instance with a initialized state in the then() failure function. 1return new Promise(() =&gt; &#123;&#125;); catch() Promise.prototype.catch() is syntactic sugar for .then(null, rejection), catch() method is used to specify the callback of Promise failure, which can uniformly handle errors on the Promise chain. Even if catch() is used, all then()s in the chain do not need to write failure callbacks. 12345const p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&quot;Error!&quot;); &#125;, 1000)&#125;); 123p.then(function(value)&#123;&#125;, function(reason)&#123; //Method 1: Specify the failed callback through then() console.error(reason)&#125;) 123p.catch(function(reason)&#123; //Method 2: Specify the failure callback through catch(). Use the first value argument to write then(). console.error(reason)&#125;) Micro task, Macro task The code in new Promise(), except asynchronous code and resolve, will be executed directly in synchronous order. And resolve will be put into the micro task queue, so it will be executed after the synchronous code is executed. The code in promise.then() is asynchronous and placed in the micro task queue. So the execution order is after the synchronous code. And promise only has three states: pending, fulfilled, rejected. Therefore, as long as resolve or reject is encountered, the state will be condensed, and the following fulfilled, rejected, if any, will not be executed. But if there is other code behind the resolve or reject code, such as console.log(), then this part of the code will continue to be executed synchronously. If the promise is pending, neither .then() nor .catch() will execute. If there are two asynchronous tasks, one is a micro task such as promise, and the other is a macro task such as setTimeout, then the micro will be executed first, and then the macro will be executed. Therefore, the code execution order is, synchronization &gt; micro task &gt; macro task. At the same time, after each macro task or micro task is executed, the system will recheck the macro task queue and macro task queue. Therefore, newly generated tasks with high priority will be executed first.","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"ES6","slug":"JS-TS/ES6","permalink":"https://redre4per.github.io/categories/JS-TS/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://redre4per.github.io/tags/ES6/"},{"name":"Promise","slug":"Promise","permalink":"https://redre4per.github.io/tags/Promise/"}]},{"title":"Rerender jest-axe","slug":"Test/React-testing-library/07 Rerender jest-axe","date":"2022-10-18T06:16:12.000Z","updated":"2022-11-10T15:26:02.774Z","comments":true,"path":"2022/10/18/Test/React-testing-library/07 Rerender jest-axe/","link":"","permalink":"https://redre4per.github.io/2022/10/18/Test/React-testing-library/07%20Rerender%20jest-axe/","excerpt":"","text":"render() rerender is used to simulate props changing. How to get rerender(): 1const &#123;rerender&#125; = render(&lt;FavoriteNumber /&gt;); rerender() uses and passes parameters rerender() is used to test the new props of the component, so its argument is the component with props. 12...rerender(&lt;FavoriteNumber max=&#123;10&#125; /&gt;) axe() axe() is a helper for jest. Can be used to help us check various properties of the container. Note that axe is asynchronous. 1234567import &#123;axe&#125; from &#x27;jest-axe&#x27;test(&#x27;the form is accessible&#x27;, async() =&gt; &#123; const &#123;container&#125; = render(&lt;Form /&gt;) const results = await axe(container) expect(results.violations).toHaveLength(0)&#125;) The above method uses axe(), but does not get a useful error message. So you can use the special methods that come with axe() . 12345678import &#123;axe, toHaveNoViolations&#125; from &#x27;jest-axe&#x27;import &#x27;jest-axe/extend-expect&#x27; //Replace expect.extend(toHaveNoViolations), simplify the codetest(&#x27;the form is accessible&#x27;, () =&gt; &#123; const &#123;container&#125; = render(&lt;Form /&gt;) const results = await axe(container) expect(results).toHaveNoViolations()&#125;)","categories":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/categories/Test/"},{"name":"React-testing-library","slug":"Test/React-testing-library","permalink":"https://redre4per.github.io/categories/Test/React-testing-library/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/tags/Test/"},{"name":"React-testing-library","slug":"React-testing-library","permalink":"https://redre4per.github.io/tags/React-testing-library/"}]},{"title":"Jest test methods","slug":"Test/React-testing-library/06 Jest test methods","date":"2022-10-18T01:26:45.000Z","updated":"2022-11-10T15:23:03.513Z","comments":true,"path":"2022/10/18/Test/React-testing-library/06 Jest test methods/","link":"","permalink":"https://redre4per.github.io/2022/10/18/Test/React-testing-library/06%20Jest%20test%20methods/","excerpt":"","text":"Format expect(A).ValidateItem() is used in React testing library and Jest to verify functionality. Expect() Assertion Summary 1 [Expect() Assertion Summary 2](https://www.w3cschool.cn/jest_cn/ jest_expect.html) ​ Usage Test call&#x2F;disable expect() parameters Validation item method meaning events such as onClick toBeCalled() expect to be called events such as onClick toBeCalledTimes(x) expect to be called x times button toBeCalledWith(x) Expected to be called by the x event button toBeDisabled() expect button to be disabled Value comparison expect() parameters Validation item method meaning input toHaveValue(x) expect input value x DOM toHaveClass(x) expects DOM to have className x DOM toHaveTextContent(x) expects DOM to have literal x DOM toHaveTextContent(x) expects DOM to have literal x Hook, value, other toBe() expect equal variable name toBeWithinRange(a, b) Expected value is in range properties&#x2F;properties of the axe result toHaveLength(x) expect arr length equal to x Component testing expect() parameters Validation item method meaning asFragment() toMatchSnapshot() Expect no changes to components queryByX(‘x’) toBeNull() expect component x not to be rendered queryByX(‘x’) (.not).toBeInTheDocument() expect component x (not) in file jest-axe method expect() parameters Validation item method meaning axe result toHaveNoViolations(0) axe’s violations array has length 0 Other usage Test whether a child element contains a class name 12345678910test(&quot;Test whether the child element contains a class name&quot;, () =&gt; &#123; const Demo = (&#123; loading &#125;) =&gt; ( &lt;button aria-label=&quot;Button&quot;&gt; &lt;span className=&#123;loading ? &quot;loading&quot; : &quot;button&quot;&#125;&gt;button&lt;/span&gt; &lt;/button&gt; ); const &#123; baseElement &#125; = render(&lt;Demo loading /&gt;); const ele = baseElement.getElementsByClassName(&quot;loading&quot;); expect(ele.length).toBe(1);&#125;); Test the asynchronous call event 1await waitFor(() =&gt; expect(fn).toBeCalledWith(&quot;click&quot;)); 1234test(&#x27;is divisible by external value&#x27;, async () =&gt; &#123; await expect(100).toBeDivisibleByExternalValue(); await expect(101).not.toBeDivisibleByExternalValue();&#125;); await waitForNextUpdate(); Wait for the next update, default will wait 1000 milliseconds. Timer e&#x3D;method meaning jest.useFakeTimers() use fakeTimer jest.runAllTimers() execute all timers jest.useRealTimers() use realTimer ​ Custom matcher function Similar to expect.toXXXX() , we can customize the matcher function. 1234567891011121314151617181920212223242526272829303132333435363738import &#123;expect&#125; from &#x27;@jest/globals&#x27;;function toBeWithinRange(actual, floor, ceiling) &#123; if ( typeof actual !== &#x27;number&#x27; || typeof floor !== &#x27;number&#x27; || typeof ceiling !== &#x27;number&#x27; ) &#123; throw new Error(&#x27;These must be of type number!&#x27;); &#125; const pass = actual &gt;= floor &amp;&amp; actual &lt;= ceiling; if (pass) &#123; return &#123; message: () =&gt; `expected $&#123;this.utils.printReceived( actual, )&#125; not to be within range $&#123;this.utils.printExpected( `$&#123;floor&#125; - $&#123;ceiling&#125;`, )&#125;`, pass: true, &#125;; &#125; else &#123; return &#123; message: () =&gt; `expected $&#123;this.utils.printReceived( actual, )&#125; to be within range $&#123;this.utils.printExpected( `$&#123;floor&#125; - $&#123;ceiling&#125;`, )&#125;`, pass: false, &#125;; &#125;&#125;expect.extend(&#123; toBeWithinRange,&#125;);","categories":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/categories/Test/"},{"name":"React-testing-library","slug":"Test/React-testing-library","permalink":"https://redre4per.github.io/categories/Test/React-testing-library/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/tags/Test/"},{"name":"React-testing-library","slug":"React-testing-library","permalink":"https://redre4per.github.io/tags/React-testing-library/"}]},{"title":"FireEvent to simulate user operation","slug":"Test/React-testing-library/05 FireEvent to simulate user operation","date":"2022-10-17T12:36:19.000Z","updated":"2022-11-17T03:32:41.405Z","comments":true,"path":"2022/10/17/Test/React-testing-library/05 FireEvent to simulate user operation/","link":"","permalink":"https://redre4per.github.io/2022/10/17/Test/React-testing-library/05%20FireEvent%20to%20simulate%20user%20operation/","excerpt":"","text":"fireEvent fireEvent was originally in the @testing-library&#x2F;dom package, but @testing-library&#x2F;react rewrote it and gave it additional React-specific functionality. It can simulate user actions to trigger events. usage instruction event fireEvent.click(DOM) mouse click on the DOM fireEvent.change(input, { target: { value: “x” } }); User enters x fireEvent.mouseOver(DOM); Move the mouse into the DOM fireEvent.keyPress(inputEl, { key: “Enter”, code: “Enter”, charCode: 13 }); keyboard press event Note that in fireEvent.change(input, &#123; target: &#123; value: &quot;x&quot; &#125; &#125;);, &#39;&#39; should be used here even if the input format is a number.","categories":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/categories/Test/"},{"name":"React-testing-library","slug":"Test/React-testing-library","permalink":"https://redre4per.github.io/categories/Test/React-testing-library/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/tags/Test/"},{"name":"React-testing-library","slug":"React-testing-library","permalink":"https://redre4per.github.io/tags/React-testing-library/"}]},{"title":"Methods to get DOM","slug":"Test/React-testing-library/04 Methods to get DOM","date":"2022-10-17T05:12:27.000Z","updated":"2022-11-10T14:57:42.584Z","comments":true,"path":"2022/10/17/Test/React-testing-library/04 Methods to get DOM/","link":"","permalink":"https://redre4per.github.io/2022/10/17/Test/React-testing-library/04%20Methods%20to%20get%20DOM/","excerpt":"","text":"Aria-label try not to use role and aria-label in css. It’s all about accessibility. aria-label=&quot;cancelbtn&quot;, will read cancelbtn directly. So aria-label is for reading. If there is no aria-label, the value of role will be pronounced. If there is no role, read the default role, the button tag in html. When both aria-label and role exist, role will be read after aria-label is read. If you write this, use the reader to test. Therefore, do not use role indiscriminately, the consequences are very serious. Many websites now have cookies, which are mandated by the GDPR. Europe and the United States will be fined. Get the source of the DOM method These method sources are all destructuring of render(&lt;component&gt;), such as: 123const &#123;getByLableText, getByRole, rerender, debug&#125; = render( &lt;FavoriteNumber /&gt;,) ​ Websites and plugins to help get the DOM Website for testing elements: https://testing-playground.com/. Chrome plugin for testing elements: Testing Playground. ​ getByRole(). For testing, getByRole() is preferred. Its parameter is the text in html. ​ getByTestId() The test can get the element with screen.getByTestId(“id”) . The id needs to be annotated with data-testid &#x3D; {} in the body element. Everything that starts with data is useless to html, only for test. ​ getByLabelText() Get the element using the id in the Label. queryByRole() This method is similar to getByRole(). The difference between them is that when the test component is not rendered, if the component is not found, the error message of getByRole() will be bad. And queryByRole() is designed for this situation.","categories":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/categories/Test/"},{"name":"React-testing-library","slug":"Test/React-testing-library","permalink":"https://redre4per.github.io/categories/Test/React-testing-library/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/tags/Test/"},{"name":"React-testing-library","slug":"React-testing-library","permalink":"https://redre4per.github.io/tags/React-testing-library/"}]},{"title":"Render, debug","slug":"Test/React-testing-library/03 Render, debug","date":"2022-10-17T01:38:05.000Z","updated":"2022-11-10T14:51:27.497Z","comments":true,"path":"2022/10/17/Test/React-testing-library/03 Render, debug/","link":"","permalink":"https://redre4per.github.io/2022/10/17/Test/React-testing-library/03%20Render,%20debug/","excerpt":"","text":"Simple reusable rendering method In this method, we pass in the component as a parameter: 12345function render(ui) &#123; const div = document.createElement(&#x27;div&#x27;) ReactDOM.render(&lt;FavoriteNumber /&gt;, div) getQueriesForElement(div)&#125; But there is no return here. We need to return an object with all queries. At the same time, we’re going to rename the div to container and add it to return . 123456789101112function render(ui) &#123; const container = document.createElement(&#x27;div&#x27;) ReactDOM.render(ui, container) const queries = getQueriesForElement(container) return &#123;container, ...queries&#125;&#125;test(&#x27;renders a number input with a label &quot;Favorite Number&quot;&#x27;, () =&gt; &#123; const &#123;getByLabelText&#125; = render(&lt;FavoriteNumber /&gt;) const input = getByLabelText(/favorite number/i) expect(input).toHaveAttribute(&#x27;type&#x27;, &#x27;number&#x27;)&#125;) In this code, we replace the previous three lines of code with render to make it generic. 1const &#123;getByLabelText&#125; = render(&lt;FavoriteNumber /&gt;) //new 123const div = document.createElement(&#x27;div&#x27;) // old is replaced.ReactDOM.render(&lt;FavoriteNumber /&gt;, div)const &#123;getByLabelText&#125; = getQueriesForElement(div) ​ Using the built-in render method Actually, the render method already exists in the react testing library. 1import &#123;render&#125; from &#x27;@testing-library/react&#x27; ​ Use debug to find errors debug and debug() can be used anywhere, with or without arguments. debug() can see what the DOM looks like at this node. E.g: 1234567test(&#x27;renders a number input with a label &quot;Favorite Number&quot;&#x27;, () =&gt; &#123; const &#123;getByLabelText, debug&#125; = render(&lt;FavoriteNumber /&gt;) debug() const input = getByLabelText(/favorite number/i) expect(input).toHaveAttribute(&#x27;type&#x27;, &#x27;number&#x27;) debug(input)&#125;) ​","categories":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/categories/Test/"},{"name":"React-testing-library","slug":"Test/React-testing-library","permalink":"https://redre4per.github.io/categories/Test/React-testing-library/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/tags/Test/"},{"name":"React-testing-library","slug":"React-testing-library","permalink":"https://redre4per.github.io/tags/React-testing-library/"}]},{"title":"Jest DOM, DOM testing","slug":"Test/React-testing-library/02 Jest DOM, DOM testing","date":"2022-10-16T08:56:27.000Z","updated":"2022-11-10T14:45:02.811Z","comments":true,"path":"2022/10/16/Test/React-testing-library/02 Jest DOM, DOM testing/","link":"","permalink":"https://redre4per.github.io/2022/10/16/Test/React-testing-library/02%20Jest%20DOM,%20DOM%20testing/","excerpt":"","text":"A simple test example 1234567891011import React from &#x27;react&#x27;import &#123;FavoriteNumber&#125; from &#x27;../favorite-number&#x27;import ReactDOM from &#x27;react-dom&#x27;test(&#x27;renders a number input with a label &quot;Favorite Number&quot;&#x27;, () =&gt; &#123; const div = document.createElement(&#x27;div&#x27;) ReactDOM.render(&lt;FavoriteNumber /&gt;, div) console.log(div.innerHTML) //You can use console.log to see the results in the terminal. expect(div.querySelector(&#x27;input&#x27;).type).toBe(&#x27;number&#x27;) expect(div.querySelector(&#x27;label&#x27;).textContent).toBe(&#x27;Favorite Number&#x27;))&#125;) The result can be seen in the terminal. expect(div.querySelector(&#39;label&#39;).textContent).toBe(&#39;Favorite Number&#39;)) can be reversed to verify that the false output passes the test. If the result is fail, assertions run normally. ​ Using Jest DOM to boost assertions In the previous method, the error message is not helpful. For example, if the input is wrong in div.querySelector(&#39;input&#39;), an error TypeError: Cannot read property &#39;type&#39; of null will be reported, and it will be marked in div on. We use testing-library&#x2F;jest-dom to solve this problem. It has many methods, such as &#123;toHaveAttribute, toHaveTextContent&#125; . To simplify this code, such as expect.extend(jestDom), use import &#39;@testing-library/jest-dom/extend-expect&#39; to import the package. Or you can automatically import this package in jest.setup.js for all files. The modified assertion is: 12345678import &#x27;@testing-library/jest-dom/extend-expect&#x27;test(&#x27;renders a number input with a label &quot;Favorite Number&quot;&#x27;, () =&gt; &#123; const div = document.createElement(&#x27;div&#x27;) ReactDOM.render(&lt;FavoriteNumber /&gt;, div) expect(div.querySelector(&#x27;input&#x27;)).toHaveAttribute(&#x27;type&#x27;,&#x27;number&#x27;) expect(div.querySelector(&#x27;label&#x27;)).toHaveTextContent(&#x27;Favorite Number&#x27;)&#125;) At this time, if the input is written incorrectly, the error will become: 12expect(received).toHaveAttribute()received value must be an HTMLElement or an SVGElement. Received has value: null At this point it is easier to understand and fix. Use assertions to ensure label and element match exactly If there is no match, if the value of htmlFor in label is modified, the test can still pass. But there will be an error when the screen reader reads it. We can use an assertion to get the element corresponding to the label. 123456789import &#123;queries&#125; from &#x27;@testing-library/dom&#x27; // can be done in the configuration filetest(&#x27;renders a number input with a label &quot;Favorite Number&quot;&#x27;, () =&gt; &#123; const div = document.createElement(&#x27;div&#x27;) ReactDOM.render(&lt;FavoriteNumber /&gt;, div) const input = queries.getByLabelText(div, &#x27;Favorite Number&#x27;) expect(input).toHaveAttribute(&#x27;type&#x27;,&#x27;number&#x27;) //Simplified because of the previous line //The next line is deleted because of duplication&#125;) queries.getByLabelText(div, &#39;Favorite Number&#39;) will cause the DOM testing library to search all children of this div for a label containing this text. At the same time, the previous div.querySelector(&#39;label&#39;) can also be deleted, because its content is already contained in queries.getByLabelText(div, &#39;Favorite Number&#39;). This method is case sensitive. But users of screen reader don’t care about case, so it should be written as: 123456test(&#x27;renders a number input with a label &quot;Favorite Number&quot;&#x27;, () =&gt; &#123; const div = document.createElement(&#x27;div&#x27;) ReactDOM.render(&lt;FavoriteNumber /&gt;, div) const input = queries.getByLabelText(div, /Favorite Number/i) expect(input).toHaveAttribute(&#x27;type&#x27;,&#x27;number&#x27;)&#125;) This regex ignores case. Use getQueriesForElement to simplify div fetching From getQueriesForElement , we can access many other queries from the DOM testing library to find elements in the render DOM. 123456789import &#123;queries, getQueriesForElement&#125; from &#x27;@testing-library/dom&#x27;test(&#x27;renders a number input with a label &quot;Favorite Number&quot;&#x27;, () =&gt; &#123; const div = document.createElement(&#x27;div&#x27;) ReactDOM.render(&lt;FavoriteNumber /&gt;, div) const &#123;getByLabelText&#125; = getQueriesForElement(div) const input = getByLabelText(/Favorite Number/i) expect(input).toHaveAttribute(&#x27;type&#x27;,&#x27;number&#x27;)&#125;) What’s done here is that the testing library&#x2F;DOM module is added, and we pull in getQueriesForElement. We get queries for div. Now, getByLabelText is pre-bound to that div, so we can take the text matching regex as a parameter and get the input. Then we can assert on that input that it has a numeric type.","categories":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/categories/Test/"},{"name":"React-testing-library","slug":"Test/React-testing-library","permalink":"https://redre4per.github.io/categories/Test/React-testing-library/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/tags/Test/"},{"name":"React-testing-library","slug":"React-testing-library","permalink":"https://redre4per.github.io/tags/React-testing-library/"}]},{"title":"Installation, config","slug":"Test/React-testing-library/01 Installation & config","date":"2022-10-15T14:47:09.000Z","updated":"2022-11-10T14:27:06.214Z","comments":true,"path":"2022/10/16/Test/React-testing-library/01 Installation & config/","link":"","permalink":"https://redre4per.github.io/2022/10/16/Test/React-testing-library/01%20Installation%20&%20config/","excerpt":"","text":"Install 1npm install --save-dev @testing-library/dom After installation, the setupTests.js file will be generated under src. ​ unit test file location The unit test file can be placed in the same folder as the text file, named text.test.js. In fact, as long as it is consistent with the text. In CourtCanva, the project is to keep all the test files together. This way is to create a __tests__ folder under src. Sometimes test files are written directly under src, but in most cases they are written in the __tests__ folder. ​ Check which query should be used for test For testing, just getbyRole(button, name: text in html). or data-testid&#x3D;{}. Everything that starts with data is useless to html, only for test. But the test can get the element with screen.getByTestId(“id”) . Or use the website to find test elements Testing Playground online , Testing Playground plugin to download the plugin. Websites are also available. Configuration test file The configuration of the test file is in jest.config.js in the root directory. Course can use the configuration package written by Kent C. Dodds to Simple configuration like 123456const config = require(&#x27;kcd-scripts/jest&#x27;)module.exports = &#123; ...config ConverageThreshold: &#123;&#125;,&#125; ​ Simple summary of the test Basic common verification writing Expect() Assertion Summary Expect() Assertion Summary 2","categories":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/categories/Test/"},{"name":"React-testing-library","slug":"Test/React-testing-library","permalink":"https://redre4per.github.io/categories/Test/React-testing-library/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/tags/Test/"},{"name":"React-testing-library","slug":"React-testing-library","permalink":"https://redre4per.github.io/tags/React-testing-library/"}]},{"title":"Stripe webhook","slug":"Others/Stripe/4 Stripe webhook","date":"2022-10-10T21:20:40.000Z","updated":"2022-11-10T09:34:45.359Z","comments":true,"path":"2022/10/11/Others/Stripe/4 Stripe webhook/","link":"","permalink":"https://redre4per.github.io/2022/10/11/Others/Stripe/4%20Stripe%20webhook/","excerpt":"","text":"Using webhooks First search for stripe cli, find the relevant version, download and unzip it. Select the x86_64 version. Enter cmd in the folder where the unzipped file is located, then enter stripe login to log in. After jumping to the stripe web page and logging in, go back to cmd and enter stripe listen --forward-to localhost:8000/v1/webhook . At this time, you can get the siging secret, which is valid for 90 days. E.g: 1whsec_9fd569e590734157a0d8xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Then fill this key into the .env of the backend. Update data via webhook First of all, the webhook collects data through events. The webhook will continuously monitor the interface. When the payment-related behavior occurs, such as ready to pay, paid, etc., the webhook will receive events. Because we currently only need to update the database after a payment occurs, we need to filter the events to only fire the callback function after the payment. The updated data comes from the webhook listener. But we still need the id of the database document to update the existing data. This id exists before the payment action, so it can be transmitted through the metadata field. When creating the Stripe session, we have passed the id to Stripe via metadata. So when updating the data, we can just take the data from metadata. metadata cannot store complex nested objects, so we only pass in the id, and other data can be stored in the database. webhook listening event Whenever an event such as payment intend, payment success, payment failure occurs, the webhook can listen to the event. Therefore, we need to filter the events, and then call the callback function after the event occurs to process the data in the next step. 1234567891011121314151617181920212223async function webhookHandler(req, res) &#123; const sig = req.headers[&quot;stripe-signature&quot;]; let event; try &#123; event = stripeAPI.webhooks.constructEvent(req.body, sig, endpointSecret); &#125; catch (err) &#123; console.log(&#x27;ERROR&#x27;, err.message); return res.status(400).send(`Webhook error: $&#123;err.message&#125;`); &#125; if (event.type === &#x27;checkout.session.completed&#x27;) &#123; const session = event.data.object; return fulfillOrder(session) .then(() =&gt; res.status(200)) .catch((err) =&gt; res.status(400).send(`Webhook Error: $&#123;err.message&#125;`)); &#125;&#125;const fulfillOrder = async (session) =&gt; &#123; const order = await Order.findById(session.metadata.orderId).exec(); ...&#125; Set routes in JSON raw format We cannot use webhooks without setting up routes in JSON raw format. For express.js: 1app.use(&#x27;/v1/webhook&#x27;, express.raw(&#123;type: &quot;*/*&quot;&#125;)) For nest.js: 12345678910111213141516171819//src/app.module.tsimport &#123; applyRawBodyOnlyTo, JsonBodyMiddleware, RawBodyMiddleware,&#125; from &quot;@golevelup/nestjs-webhooks&quot;;export class AppModule implements NestModule &#123; // Apply raw body parsing to the routes with path &quot;stripe/webhook&quot;, // and then to automatically apply JSON body parsing to all other routes // with the exclusion of the raw routes. configure(consumer: MiddlewareConsumer) &#123; applyRawBodyOnlyTo(consumer, &#123; method: RequestMethod.ALL, // path should be the same as webhookConfig controllerPrefix (settled in stripe module) path: &quot;stripe/webhook&quot;, &#125;); &#125;&#125; 12345678910import &#123; MongoExceptionFilter &#125; from &quot;./common/filters/mongoose-exception.filter&quot;;async function bootstrap() &#123; //bodyParser setting const app = await NestFactory.create&lt;NestExpressApplication&gt;(AppModule, &#123; bodyParser: false, &#125;); app.enableCors(); app.set(&quot;trust proxy&quot;, 1); app.useGlobalPipes() Flowchart","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Stripe payment","slug":"Others/Stripe-payment","permalink":"https://redre4per.github.io/categories/Others/Stripe-payment/"}],"tags":[{"name":"Stripe","slug":"Stripe","permalink":"https://redre4per.github.io/tags/Stripe/"},{"name":"Payment","slug":"Payment","permalink":"https://redre4per.github.io/tags/Payment/"}]},{"title":"Stripe hosted page front-end","slug":"Others/Stripe/3 Stripe hosted page front-end","date":"2022-10-07T10:49:02.000Z","updated":"2022-11-17T03:30:36.834Z","comments":true,"path":"2022/10/07/Others/Stripe/3 Stripe hosted page front-end/","link":"","permalink":"https://redre4per.github.io/2022/10/07/Others/Stripe/3%20Stripe%20hosted%20page%20front-end/","excerpt":"","text":"Stripe hosted checkout: Front-end The frontend receives the sessionID and uses this id to redirect the user to the stripe checkout page. The front-end needs to be packaged as follows: stripe package: npm i @stripe/stripe-js react stripe: npm i @stripe/react-stripe-js Then set the publish key as an environment variable and set REACT_APP_PUBLISHABLE_KEY in .env. Introduce package, configure Stripe In the front-end code, first introduce Elements &amp; loadStripe in the outermost root component src&#x2F;index.js, and then create stripePromise. After that, wrap &lt;Elements&gt; around the &lt;App/&gt; component and pass in the stripePromise parameter. This way we can use stripe objects in arbitrary components. 12345678910111213import &#123; Elements &#125; from &#x27;@stripe/react-stripe-js&#x27;;import &#123; loadStripe &#125; from &#x27;@stripe/stripe-js;&#x27;const stripePromise = loadStripe(process.env.REACT_APP_PUBLISHABLE_KEY)const root = ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;));root.render( &lt;React.StrictMode&gt; &lt;Elements stripe=&#123;stripePromise&#125;&gt; &lt;App /&gt; &lt;/Elements&gt; &lt;/React.StrictMode&gt;); After setting, you need to restart the project. Create checkout component We need to complete a checkout component to help users jump to the Stripe hosted checkout page. 12345678910111213const dataObj = &#123; line_items: line_items, customer_email: &quot;blhxp1@gmail.com&quot;, orderId: orderId &#125;; axios(&#123; method: &#x27;POST&#x27;, url: &#x27;/payment/create-checkout-session&#x27;, data: dataObj &#125;).then(response =&gt; &#123; const &#123; sessionId &#125; = response.data; stripe.redirectToCheckout(&#123; sessionId &#125;) &#125;).catch(err =&gt; &#123; console.log(err) &#125;); Create payment success and payment cancel pages We need to create payment success and payment cancel, which are used to help users jump back to our website after completing the payment. If we want to carry order information in these two pages, we need to put the data ID into the url from the Stripe backend: 12success_url: `$&#123;process.env.DOMAIN&#125;/payment?status=success&amp;orderId=$&#123;order_Id&#125;`,cancel_url: `$&#123;process.env.DOMAIN&#125;/payment?status=failure&amp;orderId=$&#123;order_Id&#125;`, How the front-end receives the id For React, the frontend can use useLocation() to receive the id. For Next.js, the front end can use the SSR method and pass in the context parameter to receive the id. 123export const getServerSideProps: GetServerSideProps = async (context) =&gt; &#123; const &#123; orderId, status &#125; = context.query;&#125;","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Stripe payment","slug":"Others/Stripe-payment","permalink":"https://redre4per.github.io/categories/Others/Stripe-payment/"}],"tags":[{"name":"Stripe","slug":"Stripe","permalink":"https://redre4per.github.io/tags/Stripe/"},{"name":"Payment","slug":"Payment","permalink":"https://redre4per.github.io/tags/Payment/"}]},{"title":"Stripe hosted page back-end","slug":"Others/Stripe/2 Stripe hosted page back-end","date":"2022-10-04T21:04:29.000Z","updated":"2022-11-10T09:30:15.119Z","comments":true,"path":"2022/10/05/Others/Stripe/2 Stripe hosted page back-end/","link":"","permalink":"https://redre4per.github.io/2022/10/05/Others/Stripe/2%20Stripe%20hosted%20page%20back-end/","excerpt":"","text":"Stripe hosted checkout: Back-end Provides a pre-build hosted payment page that can be used for a one-time payment or subscription. The advantage is that there is no need to create a custom integration, stripe already does all the UI. This is the easiest and fastest way. However, in this way, it cannot be customized and the ui cannot be changed. Process The customer selects the item they want to buy and clicks the checkout button; Initiate a request to the backend (including information about the item to be purchased) to create a checkout session; On the backend (for the item to be purchased), create a checkout session through the request Stripe Api; The Stripe API returns a session object; The session ID (a single property needed to complete the checkout) is sent to the front end. This session id value is used to redirect the user to the hosted stripe page to complete the checkout process. In this way, most of the important tasks are already done by Stripe. For our backend, we need to do a few things to set up the checkout session; for the frontend, we need to get a line items array list, which contains an array of objects, each element is an item the user wants to buy. Without these values, we cannot create a checkout session. We will also pre-populate an email address on stripe hosted checkout page. This means we also need the consumer’s mailbox. So, our request object needs at least line items. email If not passed in, customers need to enter their own email. Create Checkout session First install the backend stripe package: npm i stripe Created with the minimum required parameters. First we need to create a stripe api object on the backend in a separate stripe.js file. In the backend file, we instantiate a new stripe object and pass it a secret key. We can import this file later to use the stripe api to connect to the stripe service. 12const stripeAPI = require(&#x27;stripe&#x27;)(process.env.SECRET_KEY);module.exports = stripeAPI; Processing logic In another file, api&#x2F;checkout.js, contains the function to create the checkout session. Include the domain url in the function, because the user will be redirected to the stripe hosted page, and after the checkout is complete, the user will be redirected to your page. The parameters for stripeAPI are available in strip api documentation. The format of success_url, cancel_url is fixed. The res.json only needs to return the sessionID, because just the session id will redirect the user to the stripe hosted page. 1234567891011121314151617181920212223242526272829const stripeAPI = require(&#x27;./stripe&#x27;);async function createCheckoutSession(req, res)&#123; const domainUrl = process.env.WEB_APP_URL; //domain url, usually localhost3000 const &#123; line_items, customer_email &#125; = req.body; // session cannot be created without these two parameters if(!line_items || !customer_email)&#123; return res.status(400).json(&#123; error: &#x27;missing required session parameters&#x27;&#125;) &#125; let session; try &#123; //stripe api doc contains session = await stripeAPI.checkout.sessions.create(&#123; payment_method_types: [&#x27;card&#x27;], mode: &#x27;payment&#x27;, line_items, customer_email, success_url: `$&#123;domainUrl&#125;/success?session_id=&#123;CHECKOUT_SESSION_ID&#125;`, cancel_url: `$&#123;domainUrl&#125;/cancel`, shipping_address_collection: &#123; allowed_countries: [&#x27;GB&#x27;, &#x27;US&#x27;] &#125; &#125;); res.status(200).json(&#123; sessionId: session.id, &#125;) &#125; catch (error) &#123; console.log(error); res.status(400).json(&#123; error: &#x27;an error occurred, unable to create session&#x27;&#125;); &#125;&#125;module.exports = createCheckoutSession Postman connection test After writing the backend code, use postman to test to see if the session id can be generated. Refer to the official documentation for the format. 123456789101112131415161718&#123; &quot;line_items&quot;: [ &#123; &quot;quantity&quot;: 1, &quot;price_data&quot;: &#123; &quot;currency&quot;: &quot;aud&quot;, &quot;unit_amount&quot;: 100, &quot;product_data&quot;: &#123; &quot;name&quot;: &quot;canva test 1&quot;, &quot;description&quot;: &quot;court canva designed production, stripe demo&quot;, &quot;images&quot;: [&quot;https://jr-bookinglet-2.s3.ap-southeast-2.amazonaws.com/github/canva.jpg&quot;] &#125; &#125; &#125; ], &quot;customer_email&quot;: &quot;blhxp1@gmail.com&quot;&#125;","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Stripe payment","slug":"Others/Stripe-payment","permalink":"https://redre4per.github.io/categories/Others/Stripe-payment/"}],"tags":[{"name":"Stripe","slug":"Stripe","permalink":"https://redre4per.github.io/tags/Stripe/"},{"name":"Payment","slug":"Payment","permalink":"https://redre4per.github.io/tags/Payment/"}]},{"title":"Introduction to Stripe","slug":"Others/Stripe/1 Introduction","date":"2022-10-04T00:29:31.000Z","updated":"2022-11-10T11:55:40.346Z","comments":true,"path":"2022/10/04/Others/Stripe/1 Introduction/","link":"","permalink":"https://redre4per.github.io/2022/10/04/Others/Stripe/1%20Introduction/","excerpt":"","text":"Introduce Stripe code consists of two parts: front-end and back-end. The front end tokenizes customer information and uses stripe elements to collect sensitive information. General flow All payments need to go through the backend server. When the user is ready to pay, the backend server will send a request to set whether to create a session or a payment intend. The Stripe Api will respond with an object containing the session id or client secret. After that, they will be sent back to the front-end app, and they will be used to complete the payment. Whether it’s a one-time payment or a subscription, this is the process. The backend is the core and also connects to the stripe api. Payment gateway Handle payments at a global scale; PCI Compliance; Encrypt credit card data; Store credit card data securely; Method to realize Stripe hosted checkout Customized checkout Create stripe account Public key &amp; Secret key. In Dashboard, you can see that stripe has test mode and live mode. The secret key is used in the backend and should be placed in the .env file and cannot be exposed. Stripe dashboard Key points: View API keys: Public key and Secret key. View statistics of all payments, specific information for each payment. Check Stripe’s error message. View and deploy webhooks, locally&#x2F;online. View customer information. Set 3D secure (More - Radar - Fraud &amp; risk - Rules)","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Stripe payment","slug":"Others/Stripe-payment","permalink":"https://redre4per.github.io/categories/Others/Stripe-payment/"}],"tags":[{"name":"Stripe","slug":"Stripe","permalink":"https://redre4per.github.io/tags/Stripe/"},{"name":"Payment","slug":"Payment","permalink":"https://redre4per.github.io/tags/Payment/"}]},{"title":"Database migration","slug":"NestJS/13 Database migration","date":"2022-09-28T04:11:26.000Z","updated":"2022-11-12T00:02:21.309Z","comments":true,"path":"2022/09/28/NestJS/13 Database migration/","link":"","permalink":"https://redre4per.github.io/2022/09/28/NestJS/13%20Database%20migration/","excerpt":"","text":"Database Migration Database migrations provide a way to incrementally update the database schema and keep it in sync with the application data model, while preserving the existing data in our database. Build, run, and restore migrations. TypeORM provides us with a dedicated CLI that we can use. The migration classes are separate from the Nest application source code. This is because their lifecycle is maintained by the TypeORM CLI. Therefore, we cannot take advantage of dependency injection and other Nest specific features for database migrations. Migration Configuration Before creating a new migration, we need to create a new TypeORM configuration file and set up our database connection correctly. First create an ormconfig.js file in the root directory to configure all the ports, passwords, etc. we use from the Docker Compose file. There are some additional key values to let the TypeORM migration know where our entities and migration files will be. TypeORM migrations need to process compiled files, which Nest will output in the &#x2F;dist&#x2F;folder folder. 12345678910111213module.exports = &#123; type: &#x27;postgres&#x27;, host: &#x27;localhost&#x27;, port: 5432, username: &#x27;postgres&#x27;, password: &#x27;pass123&#x27;, database: &#x27;postgres&#x27;, entities: [&#x27;dist/**/*.entity.js&#x27;], migrations: [&#x27;dist/migrations/*.js&#x27;], cli: &#123; migrationsDir: &#x27;src/migrations&#x27;, &#125;,&#125; Create Migration File Command: npx typeorm migration:create -n filename. npx allows us to use executable packages without installation. This directive generates a new migration file in the &#x2F;src&#x2F;migrations directory. The up() is where we want to indicate what needs to be changed and how, and the down() method is where we want to undo or roll back any of those changes. Migration Instructions npm typeorm migration:run migration; npm typeorm migration:revert reverts. The commands in the courtCanva project are npm run migrate-up ; npm run migrate-down . Syntax When naming the file, use time + status + table name.js insertOne 12345module.exports = &#123; async up(db) &#123; await db.collection(&quot;documentName&quot;).insertOne(&#123;&#125;) &#125;&#125; insertMany 12345module.exports = &#123; async up(db) &#123; await db.collection(&quot;documentName&quot;).insertMany([]) &#125;&#125; updateOne 12345678910module.exports = &#123; async up(db) &#123; await db .collection(&quot;documentName&quot;) .updateOne(&#123; fieldName: &quot;value&quot; &#125;, &#123; $set: &#123; field1: &quot;value1&quot;, field2: &quot;value2&quot;,&#125;&#125;, &#123; $unset: [&quot;field3&quot;, &quot;field4&quot;] &#125;, ); &#125;,&#125;; Precautions The default value&#x2F;initial value of the schema in the database will not be generated when the database is migrated, such as isDeleted, updatedAt, etc., so you need to write it yourself. The creation time can be used with createdAt: new Date() .","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"}]},{"title":"Add index to Schema","slug":"NestJS/12 Add index to Schema","date":"2022-09-27T12:52:07.000Z","updated":"2022-11-10T03:47:28.365Z","comments":true,"path":"2022/09/27/NestJS/12 Add index to Schema/","link":"","permalink":"https://redre4per.github.io/2022/09/27/NestJS/12%20Add%20index%20to%20Schema/","excerpt":"","text":"index Indexes are special lookup tables that database search engines can use to speed up data retrieval. Without an index, Mongo must perform a collection scan, which means it must scan every document in the collection to select those that match the query. In Mongoose, indexes can be defined at the field level or at the schema level. Using a single index A common search request is to retrieve events by event name. In the schema file: 123456789101112131415import &#123; Schema &#125; from &#x27;@nestjs/mongoose&#x27;;@Schema()export class Event extends mongoose.Document &#123;@Props()type: string;@Props(&#123; index: true &#125;) //Add normal indexname: string;@Props(mongoose.SchemaTypes.Mixed)payload: Record&lt;string, any&gt;;&#125;export const EventSchema = SchemaFactory.createForClass(Event); Compound Index A single index references multiple properties. Multiple properties need to be added to EventSchema.index(&#123;&#125;). 12345678910111213141516import &#123; Schema &#125; from &#x27;@nestjs/mongoose&#x27;;@Schema()export class Event extends mongoose.Document &#123;@Props()type: string;@Props(&#123; index: true &#125;) //Add normal indexname: string;@Props(mongoose.SchemaTypes.Mixed)payload: Record&lt;string, any&gt;;&#125;export const EventSchema = SchemaFactory.createForClass(Event);EventSchema.index(&#123; name: 1, type: -1&#125;); Where 1 represents ascending order, -1 represents descending order, the same as sort() in mongoose.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"}]},{"title":"Transactions","slug":"NestJS/11 Transactions","date":"2022-09-25T03:07:52.000Z","updated":"2022-11-10T14:04:07.753Z","comments":true,"path":"2022/09/25/NestJS/11 Transactions/","link":"","permalink":"https://redre4per.github.io/2022/09/25/NestJS/11%20Transactions/","excerpt":"","text":"Transaction We perform multiple operations on the database, making sure they only happen if everything is successful. A database transaction represents a unit of work performed in a database management system, and a transaction is a reliable way to accomplish multiple tasks independently of other transactions. Note that there are other advanced techniques that leverage Nest scope providers and interceptors to automatically wrap every “write” query in a transaction. Necessity of transactions: For example, there are two tables: account table and information table, and there is a relationship between these two tables. Therefore, when we add data in one table, we have to add data to another table at the same time. However, this is a two-step operation (that is, in the first step, I need to add data in the account table, and in the second step, I need to add data in the information table). What if one of the operations fails? If the account is added successfully, but the information fails. If it is not handled, it will result in that the account has no information. So the transaction comes into play. In a transaction, all of them must be successful to be considered as a new success. Otherwise it is a failure. Add new CLI entity nest g class events/entities/event.entity --no-spec . This file is in the root directory. After creation, in the event.entity.ts file, change the class name EventEntity to Event, otherwise Entity will enter the database collection name. 123456789101112131415import &#123; Schema &#125; from &#x27;@nestjs/mongoose&#x27;;@Schema()export class Event extends mongoose.Document &#123; //Inheritance@Props()type: string;@Props()name: string;@Props(mongoose.SchemaTypes.Mixed) // means &quot;anything can happen&quot;.payload: Record&lt;string, any&gt;;&#125;export const EventSchema = SchemaFactory.createForClass(Event); payload is a generic property where we will store the event payload. These payloads are essentially a dictionary filled with values of type any . Then also add the Event to the MongooseModule.forFeature([ ]) array in coffees.module.ts : 1234567891011121314151617@Module(&#123; imports: [ MongooseModule.forFeature([ &#123; name: Coffee.name, schema: CoffeeSchema, &#125;, &#123; // add here name: Event.name, schema: EventSchema, &#125;, ]), ], controllers: [CoffeesController], providers: [CoffeesService],&#125;)export class CoffeesModule &#123;&#125; Also add the Event to the coffee schema file coffee.entity.ts: 123456789101112131415161718import &#123; Schema &#125; from &#x27;@nestjs/mongoose&#x27;;@Schema()export class Coffee extends Document &#123; //To inherit Document. @Prop() name: string; @Prop() brand: string; @Prop(&#123; default:0 &#125;) //Add here recommendations: number; @Prop([String]) flavors: string[];&#125;export const CoffeeSchema = SchemaFactory.createForClass(Coffee); //output Create transaction To create a transaction, use the Connection object from mongoose in coffees.service.ts. 12345678910111213141516171819202122232425262728293031323334353637383940import &#123; Injectable, NotFoundException &#125; from &#x27;@nestjs/common&#x27;;import &#123; InjectModel &#125; from &#x27;@nestjs/mongoose&#x27;;import &#123; Connection, Model &#125; from &#x27;mongoose&#x27;;import &#123; Coffee &#125; from &#x27;./entities/coffee.entity&#x27;;@Injectable()export class CoffeesService &#123; constructor( @InjectModel(Coffee.name) private readonly coffeeModel: Model&lt;Coffee&gt;, @InjectConnection() private readonly connection: Connection, //connection @InjectModel(Event.name) private readonly eventModel: Model&lt;Event&gt;, //Event )&#123;&#125;async findAll(paginationQuery: PaginationDto)&#123; const &#123;limit, offset&#125; = paginationQuery; return this.coffeeModel.find().skip(offset).limit(limit)exec(); &#125;; async recommendCoffee(coffee: Coffee)&#123; const session = await this.connection.startSession(); //Create a new mongo session session.startTransaction(); try &#123; //The whole session should be wrapped in try catch coffee.recommendations++; const recommendEvent = new this.eventModel(&#123; name: &#x27;recommend_coffee&#x27;, type: &#x27;coffee&#x27;, payload: &#123; coffeeId: coffee.id &#125;, &#125;); await recommondEvent.save(&#123; session &#125;); await coffee.save(&#123; session &#125;); await session.commitTransaction(); &#125; catch (err) &#123; await session.abortTransaction(); &#125; finally &#123; session.endSession(); &#125; &#125;&#125;","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"}]},{"title":"Interact with MongoDB, pagination","slug":"NestJS/10 Interact with mongoDB","date":"2022-09-24T09:47:37.000Z","updated":"2022-11-12T00:02:15.134Z","comments":true,"path":"2022/09/24/NestJS/10 Interact with mongoDB/","link":"","permalink":"https://redre4per.github.io/2022/09/24/NestJS/10%20Interact%20with%20mongoDB/","excerpt":"","text":"Inject model into service Use the @injectModel() decorator and pass in the schema name. Model&lt;schema class name&gt; is a fixed notation. Same here as express, but also write async&#x2F;await to make Promises easier to manage and more readable. Enter this.coffeeModel. here to see all available methods. Compared to mongoose in express, this.coffeeModel here is equivalent to the original Schema name (capitalized), such as Store, Category, User, etc. In the service file: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import &#123; Injectable, NotFoundException &#125; from &#x27;@nestjs/common&#x27;;import &#123; InjectModel &#125; from &#x27;@nestjs/mongoose&#x27;;import &#123; Model &#125; from &#x27;mongoose&#x27;;import &#123; Coffee &#125; from &#x27;./entities/coffee.entity&#x27;;@Injectable()export class CoffeesService &#123; constructor( @injectModel(Coffee.name) private readonly coffeeModel: Model&lt;Coffee&gt;, )&#123;&#125;async findAll()&#123; return this.coffeeModel.find().exec(); &#125;; async findOne(id: string)&#123; const coffee = await this.coffeeModel.findOne(&#123; _id: id&#125;).exec(); if(!coffee) &#123; throw new NotFoundException(`Coffee #$&#123;id&#125; not found`); &#125; return coffee; &#125;; async create(createCoffeeDto: CreateCoffeeDto)&#123; //Type verification const coffee = new this.coffeeModel( createCoffeeDto ); return coffee.save(); &#125;; async create(createCoffeeDto: CreateCoffeeDto)&#123; //Another way of writing const coffee = await this.coffeeModel.create( createCoffeeDto ); return coffee; &#125;; async update(id: string, updateCoffeeDto: UpdateCoffeeDto)&#123; const existingCoffee = await this.coffeeModel.findByIdAndUpdate(&#123; _id: id &#125;, &#123; $set: updateCoffeeDto &#125;, &#123; new: true &#125;).exec(); if(!exsitingCoffee)&#123; throw new NotFoundException(`Coffee #$&#123;id&#125; not found`); &#125;return coffee; &#125; async remove(id: string)&#123; const coffee = await this.findOne(id); return coffee.remove(); &#125;&#125; $set: Update a field in the document instead of replacing it all. In remove , there is no need to remove the manual validation (!coffee) , as findOne will automatically return an error when it cannot find the target. ​ Changes in Controller file First id should be changed from number to string. This is because in mongoDB _id is a string and not a number. If this is not changed, the ValidationPipe will try to automatically convert the “id” of any incoming object to a number, resulting in a lot of random errors. Pagination First create pagination: nest g class common/dto/pagination-query.dto --no-spec . The pagination is created with a new class name in order to hold things that are not tied to any specific field and can be reused by multiple controllers. In the pagination-query.dto file: 12345678910111213import &#123; Type &#125; from &#x27;class-transformer&#x27;;export class PaginationQueryDto &#123; @IsOptional() @IsPositive() @Type(() =&gt; Number) //This can be removed by global setting implicit conversion limit: number; @IsOptional() @IsPositive() @Type(() =&gt; Number) //This can be removed by global setting implicit conversion offset: number;&#125; In main.ts file: 12345678910111213async function bootstrap() &#123; const app = await NestFactory.create(AppModule); app.useGlobalPipes( new ValidationPipe(&#123; whitelist: true, transform: true, forbidNonwhitelisted: true, transformOptions: &#123; enableImplicitConversion: true, //Set this item &#125; &#125;) )&#125; In the controller file: 123456789@Injectable()export class CoffeesService &#123; constructor( @injectModel(Coffee.name) private readonly coffeeModel: Model&lt;Coffee&gt;, )&#123;&#125;async findAll(@Query() paginationQuery: PaginationQueryDto)&#123; return this.coffeeModel.findAll(paginationQuery).exec(); &#125;; In the service file: 12345678910111213141516import &#123; Injectable, NotFoundException &#125; from &#x27;@nestjs/common&#x27;;import &#123; InjectModel &#125; from &#x27;@nestjs/mongoose&#x27;;import &#123; Model &#125; from &#x27;mongoose&#x27;;import &#123; Coffee &#125; from &#x27;./entities/coffee.entity&#x27;;@Injectable()export class CoffeesService &#123; constructor( @injectModel(Coffee.name) private readonly coffeeModel: Model&lt;Coffee&gt;, )&#123;&#125;async findAll(paginationQuery: PaginationDto)&#123; const &#123;limit, offset&#125; = paginationQuery; return this.coffeeModel.find().skip(offset).limit(limit)exec(); &#125;;&#125; ​ Sort syntax 1234Post.find(&#123;&#125;).sort(&#x27;test&#x27;).exec(function(err, docs) &#123; ... &#125;);Post.find(&#123;&#125;).sort([[&#x27;date&#x27;, -1]]).exec(function(err, docs) &#123; ... &#125;);Post.find(&#123;&#125;).sort(&#123;test: 1&#125;).exec(function(err, docs) &#123; ... &#125;);Post.find(&#123;&#125;, null, &#123;sort: &#123;date: 1&#125;&#125;, function(err, docs) &#123; ... &#125;);","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"},{"name":"Mongoose","slug":"Mongoose","permalink":"https://redre4per.github.io/tags/Mongoose/"}]},{"title":"Mongoose model","slug":"NestJS/09 Mongoose model","date":"2022-09-23T02:07:48.000Z","updated":"2022-11-10T02:56:40.221Z","comments":true,"path":"2022/09/23/NestJS/09 Mongoose model/","link":"","permalink":"https://redre4per.github.io/2022/09/23/NestJS/09%20Mongoose%20model/","excerpt":"","text":"Data model schema These models are responsible for creating, reading and deleting documents from the Mongo database. We need to create a schema first. The schema can be created manually using NestJS decorator or mongoose. Create schema with NestJS decorator Create the schema in coffee.entity.ts in the entities folder. The file structure is: 12345678|-- src |-- coffees |-- coffees.module.ts |-- coffees.controller.ts |-- coffees.service.ts |-- dto |-- entities |-- coffee.entity.ts 12345678import &#123; Schema &#125; from &#x27;@nestjs/mongoose&#x27;;@Schema()export class Coffee extends Document&#123; //To inherit Document. name: string; brand: string; flavors: string[];&#125; //This is incomplete, see next code block The @Schema() decorator maps our Coffee class to the MongoDB collection of the same name, but with an extra ‘s’ at the end. Mongo automatically makes all collections plural and lowercase by default. The id is not needed here because mongoose adds the _id attribute by default. Define properties: @Prop() Add the @Prop() decorator to all our properties. 123456789101112131415import &#123; Schema &#125; from &#x27;@nestjs/mongoose&#x27;;@Schema()export class Coffee extends Document &#123; //To inherit Document. @Prop() name: string; @Prop() brand: string; @Prop([String]) //Because flavors is an array of strings, [String] should be passed in @Prop(). flavors: string[];&#125;export const CoffeeSchema = SchemaFactory.createForClass(Coffee); //output Introduce the mongoose model into the module file Add MongooseModule.forFeature() to the module file, passing in an Array of objects. We use forFeature() to register Mongoose in our submodule. 12345678import &#123; MongooseModule &#125; from &#x27;@nestjs/mongoose&#x27;;@Module(&#123; imports: [MongooseModule.forFeature([ //Note [], the element is an object. &#123; name: Coffee.name, //Coffee.name is obtained from coffee.entity.ts schema: CoffeeSchema, // Also obtained from coffee.entity.ts, but the final output. &#125;])], controllers: [CoffeesController], providers: [CoffeesService] &#125;) coffee.name is just a way to get the function name from a JavaScript class, which in this case gives us a string. Common spelling Ref 12@Prop(&#123; type: MongooseSchema.Types.ObjectId, ref: &quot;Price&quot; &#125;)price: Price; Do not repeat spelling 12@Prop(&#123; unique: true &#125;)email: string; default value 12345@Prop(&#123; default: false &#125;)isDeleted: boolean;@Prop(&#123; type: Date, default: new Date() &#125;) //The default is the current timecreatedAt: Date; Object notation 123456@Prop(&#123; type: Object, required: true &#125;) courtSize: &#123; name: string; length: number; width: number; &#125; Maximum and minimum writing 12@Prop(&#123; required: true, minLength: 5, maxLength: 50 &#125;)name: string; Object array writing 12@Prop(&#123; type: Array, required: true &#125;)colors: [&#123; name: string; value: string &#125;];","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"},{"name":"Mongoose","slug":"Mongoose","permalink":"https://redre4per.github.io/tags/Mongoose/"}]},{"title":"Docker Mongoose","slug":"NestJS/08 Docker Mongoose","date":"2022-09-21T10:54:02.000Z","updated":"2022-11-12T00:02:10.797Z","comments":true,"path":"2022/09/21/NestJS/08 Docker Mongoose/","link":"","permalink":"https://redre4per.github.io/2022/09/21/NestJS/08%20Docker%20Mongoose/","excerpt":"","text":"Docker containerization The benefits of using Docker: flexible, lightweight, portable, loosely coupled. They can be built locally to the cloud and run anywhere, and finally containers are loosely coupled, which means containers are highly self-sufficient and encapsulated. This allows us to replace or upgrade containers without disrupting any other containers. Essentially, a container is just a running process with some additional encapsulation features applied. This helps keep containers isolated from the host and other containers. Docker compose: is a tool for defining and running multiple container docker applications, through docker compose we can use yaml files to configure our application services. Configure MongoDB Use the Docker Compose tool and its YAML configuration to set up everything you need. Create a docker-compose.yml file in the root directory. Spacing&#x2F;indentation&#x2F;dashes in YAML all matter. The most important thing in the file is the db service, the Docker image using ‘Mongo’. A Docker image is a multi-layered file that will execute code in our docker container. In this case, it will create a Mongo database. 12345678910version: &quot;3&quot;services: db: image: mongo restart: always environment: - MONGODB_DATABASE=nest-course //database name ports: - 27017:27017 //Default port. Docker sets up the database on port 27017 and we can also access it outside of docker. Use the docker compose CLI to run the db service: docker-compose up -d . The d flag means we want to run the containers in detached mode, meaning they run in the background. If there are other services here and you want to run a specific service, you can do so by entering its name. When nothing is passed in, docker compose will generate all defined services. Use mongoose in nest Install: npm i mongoose @nestjs/mongoose. @nestjs&#x2F;mongoose is for integrating nest with mongoose. Type safety: npm i -D @type/mongoose . Install the mongoose typescript definition as a ‘dev’ dependency. @nestjs&#x2F;mongoose comes with a set of useful decorators and MongooseModule. set mongoose In app.module.ts in the root directory, add MongooseModule.forRoot(&#39;mongodb://localhost:27017/nest-course&#39;) in imports: [ ] . The second parameter is not present here, it is a configuration option. nest-course is the database name. At this point, use npm run start:dev to start the application, and mongodb can connect.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"},{"name":"Mongoose","slug":"Mongoose","permalink":"https://redre4per.github.io/tags/Mongoose/"}]},{"title":"DTO data verification","slug":"NestJS/07 DTO","date":"2022-09-20T13:04:18.000Z","updated":"2022-11-09T07:16:37.427Z","comments":true,"path":"2022/09/20/NestJS/07 DTO/","link":"","permalink":"https://redre4per.github.io/2022/09/20/NestJS/07%20DTO/","excerpt":"","text":"DTO DTO is short for data transfer object. A DTO is an object that encapsulates data and sends it from one application to another. DTOs help us define interfaces or inputs and outputs within the system. That is, the DTO defines the format of the data to be received. Similar to schema (but only validates the incoming data part). The objectId is automatically generated by the database and does not need to be verified. DTOs are just simple objects, they don’t contain any business logic, methods, or anything that needs to be tested. Generate DTO file Generated location: under the dto folder of the same level as coffees.controller.ts. 12345678|-- src |-- coffees module folder |-- coffees.module.ts //helps us keep our code organized and establish clear boundaries for the application and its functionality. |-- coffees.controller.ts |-- coffees.service.ts |-- dto |-- create-coffee.dto |-- update-coffee.dto //Different DTOs should be placed in separate files How to generate: Use nest cli: nest generate class path and name.dto --no-spec , abbreviated as nest g class path and name.dto --no-spec . For example, nest g class coffees/dto/create-coffee.dto --no-spec . --no-spec was added to avoid generating test files. DTO document In &#x2F;dto&#x2F;create-coffee.dto： 12345export class CreateCoffeeDto &#123; name: string; brand: string; flavors: string[];&#125; Use in controller DTO In coffees.controller.ts： 1234@Post()create(@Body() createCoffeeDto: CreateCoffeeDto) &#123; return this.coffeesService.create(createCoffeeDto); //Note that a DTO instance is used when creating here&#125; DTO Tag Properties readonly guarantees that the property is not modified 12345export class CreateCoffeeDto &#123; readonly name: string; readonly brand: string; readonly flavors: string[];&#125; ? guarantees that the attribute is optional. This guarantees that @Patch can update any tiny part. 12345export class UpdateCoffeeDto &#123; name?: string; //Note? Location brand?: string; //Attention? Location flavors?: string[]; //Note? Location&#125; Data validation: ValidationPipe The downside of DTOs is that we don’t know who or what is calling these requests, how to make sure the incoming data has the correct shape, or if the data is missing necessary fields. NestJS provides ValidationPipe to solve this exact problem. ValidationPipe provides a convenient way to enforce validation rules on incoming client payloads (data). Programmers can specify these rules by using simple comments in the DTO. Application is set to use ValidationPipe In src&#x2F;main.ts, add app.useGlobalPipes(new ValidationPipe()) . Also install two packages: npm i class-validator class-transformer. 1234567import &#123; ValidationPipe &#125; from &#x27;@nestjs/common&#x27;;async function bootstrap()&#123; const app = await NestFactory.create(AppModule); app.useGlobalPipes(new ValidationPipe()) await app.listen(3000);&#125; It can then be modified in the DTO file. See the class-validator documentation to see all decorators. 1234567891011import &#123; IsString &#125; from &#x27;class-validator&#x27;;export class CreateCoffeeDto &#123; @IsString() readonly name: string; @IsString() readonly brand: string; @IsString(&#123; each: true &#125;) //Indicates that each item in the array is expected to be a string. readonly flavors: string[];&#125; If the input data does not conform to the rules, it will automatically respond with a 400 BadRequest code and indicate the reason in the message. Create’s validation is reused for Update The writing in “Error” section is cumbersome and can be simplified. nestjs provides several utility functions as part of the package @nestjs&#x2F;mapped-types. These functions help us quickly perform common conversions of these types. First install the package: npm i @nestjs/mapped-types. Then change the update-coffee.dto.ts file to: 123456import &#123;PartialType&#125; from &#x27;@nestjs/mapped-types&#x27;;import &#123;CreateCoffeeDto&#125; from &#x27;./create-coffee.dto&#x27;;export class UpdateCoffeeDto extends PartialType(CreateCoffeeDto)&#123; &#125; The PartialType function is very useful because what it does for us is return the type of the class we pass to it, with all properties set to optional. And it also inherits all validation rules applied through the decorator. It also dynamically adds a single additional validation rule to each field @IsOptional() . Some properties we hope cannot be updated, such as user_id. In this case the @Exclude() decorator can be used to prevent property updates. ValidationPipe whitelist Whitelisting is used to filter out properties that should not be received by method handlers. By whitelisting acceptable properties, any properties not included in the whitelist are automatically stripped from the resulting object. Whitelisting is used by entering some options into the ValidationPipe. In main.ts: 123456async function bootstrap()&#123; const app = await NestFactory.create(AppModule); app.useGloblePipes(new ValidatePipe(&#123; whitelist: true, //add whitelist &#125;)&#125; The whitelist also has an option to stop processing requests and throw an error if there are any non-whitelisted attributes: 1234567async function bootstrap()&#123; const app = await NestFactory.create(AppModule); app.useGloblePipes(new ValidatePipe(&#123; whitelist: true, forbidNonWhitelisted: true, // throws an error when there is a non-whitelisted attribute &#125;)&#125; Guaranteed that the shape of the payload (the incoming object, i.e. the payload) is as expected As in @Post(), createCoffeeDto is not an instance of CreateCoffeeDto. This means that the payload is the shape of CreateCoffeeDto, but not an instance. ValidationPipe can help us convert this object to what we expect. Enable globally: 12345678async function bootstrap()&#123; const app = await NestFactory.create(AppModule); app.useGloblePipes(new ValidatePipe(&#123; whitelist: true, transform: true, // set here forbidNonWhitelisted: true, &#125;)&#125; This transform can also perform primitive type conversions for things like boolean and number. By default, the parameters in path and query are of type string. When adding transform: true, if we change the string in findOne(@Param(&#39;id&#39;) id: string)&#123;&#125; to a number, it will cause problems because coffeesService.findOne() expects a string as a parameter (custom in nestJS.4). Because at this time id has been changed to number type. This feature has a very slight performance impact. Automatic conversion type 1@Type(() =&gt; Number) //If the string type is passed, no error will be reported, and it will be automatically converted to the number type Validation of nested objects 12345@IsObject()@IsNotEmpty()@ValidateNested(&#123; each: true &#125;) //Must have this@Type(() =&gt; Design)readonly design: Design;","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"}]},{"title":"Modularization","slug":"NestJS/06 Modularization","date":"2022-09-17T02:41:17.000Z","updated":"2022-11-09T07:00:14.063Z","comments":true,"path":"2022/09/17/NestJS/06 Modularization/","link":"","permalink":"https://redre4per.github.io/2022/09/17/NestJS/06%20Modularization/","excerpt":"","text":"Reasonable nest architecture, create modules A well-structured architecture should employ multiple modules, each encapsulating a set of closely related functions. The function should contain controller, service, etc. Also, test files and test data files are placed here. Create module directive: nest g module module_name. This will create the module and automatically import the module file into the parent module. The structure is: 12345|--src |-- coffees module folder |-- coffees.module.ts //helps us keep our code organized and establish clear boundaries for the application and its functionality. |-- coffees.controller.ts |-- coffees.service.ts @Module decorator In the coffees.module.ts file, the decorator before the CoffeesModule class is @Module(&#123;&#125;) . It provides data to support application structure. The module decorator requires a single object whose properties describe the module and all contexts. The attributes of the @Module decorator have four kinds of content: controllers: API root, we want this module to be instantiated. exports: List the providers in the current module, which should be available everywhere. This module will be imported. imports: Allows us to list other modules of this module. providers: an array. Lists services that need to be instantiated by the nest injector. Any provider here will only be available in this module unless it is added to the exports array. Incorporate the file into the module file Included in the file as attributes of the @Module decorator: [array]. 1234import &#123;Module&#125; from &#x27;@nestjs/common&#x27;; @Module(&#123;controllers: [CoffeesController], providers: [CoffeesService]&#125;)export class CoffeesModule&#123;&#125;","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"}]},{"title":"Errors","slug":"NestJS/05 Errors","date":"2022-09-15T08:05:27.000Z","updated":"2022-11-09T06:51:32.486Z","comments":true,"path":"2022/09/15/NestJS/05 Errors/","link":"","permalink":"https://redre4per.github.io/2022/09/15/NestJS/05%20Errors/","excerpt":"","text":"Wrong choice in Nest Throwing an exception Use library-specific response objects Create interceptors and use exception filters Additionally, nest has helper methods for all common error responses, including helper classes. Throw an exception In the service file: 1234567findOne(id: string)&#123; const coffee = this.coffees.find(item =&gt; item.id === +id); if(!coffee)&#123; throw new HttpException(`Coffee #$&#123;id&#125; not found`, HttpStatus.NOT_FOUND); &#125; return coffee;&#125; ​ Help class Including NotFoundException, InternalServiceErrorException, BadRequestException, etc. 1234567findOne(id: string)&#123; const coffee = this.coffees.find(item =&gt; item.id === +id); if(!coffee)&#123; throw new NotFoundException(`Coffee #$&#123;id&#125; not found`); //Replace here, but return the same &#125; return coffee;&#125; ​ Nest’s built-in exception layer automatically catches exceptions Similar to express-error to automatically process packages. ​","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"}]},{"title":"Service","slug":"NestJS/04 Service","date":"2022-09-14T06:15:07.000Z","updated":"2022-11-09T06:40:10.479Z","comments":true,"path":"2022/09/14/NestJS/04 Service/","link":"","permalink":"https://redre4per.github.io/2022/09/14/NestJS/04%20Service/","excerpt":"","text":"Create service When creating a service, first enter nest generate service, abbreviated nest g s. Enter the name after that. service is used to process logic and can be reused after being extracted. In nest, each service is a provider. Provider The main idea of Provider is that it can inject dependencies. This means that various relationships can be created between objects, and the logic to wire object instances together can all be handled by the Nest runtime system, rather than trying to create and manage this type of dependency injection yourself. Provider in nest is a class with a decorator named @Injectable(). Provider dependency If we want to inject the provider, we can simply use the constructor. In the Contoller file, write constructor()&#123;&#125; in the Controller class. 123456789101112import &#123; CoffeesService &#125; from &#x27;./coffees.service&#x27;;@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; constructor(private readonly coffeesService: CoffeesService)&#123;&#125; @Post() @HttpCode(HttpStatus.GONE) //Decorator position, return 410GONE. create(@Body(&#x27;name&#x27;) body)&#123; return body; &#125;&#125; private: TypeScript usage that allows us to declare and initialize CoffeesService members at once in the same place. And it’s only accessible within the class itself, hence private. readonly: Ensures that the referenced service is not modified and content is only accessed from it. coffeesService : Named parameter. : CoffeesService: In typeScript, use types to manage dependencies. nest will resolve CoffeesService by creating an instance of CoffeesService and returning it to our CoffeesController , or returning an existing instance if there is one. This dependency is resolved and passed to the controller constructor, or assigned to the property specified here. Service，CRUD In service document： 12345678910111213141516171819202122232425import &#123; Coffee &#125; from &#x27;./entities/coffee.entity&#x27;; //coffee class@Injectable()export class CoffeesService &#123; private coffees: Coffee[] = [ //Create an array, using multiple instances. &#123; id: 1, name: &#x27;Shipwreck Roast&#x27;, brand: &#x27;Buddy Brew&#x27;, flavors: [&#x27;chocolate&#x27;, &#x27;vanilla&#x27;] &#125; ]; findAll()&#123;return this.coffees&#125;; findOne(id: string)&#123;item =&gt; item.id === +id&#125;; create(createCoffeeDto: any)&#123;this.coffees.push(createCoffeeDto)&#125;; update(id: string, updateCoffeeDto: any)&#123; const existingCoffee = this.findOne(id); if(exsitingCoffee)&#123;&#125; &#125; remove(id: string)&#123; const coffeeIndex = this.coffees.findIndex(item =&gt; item.id === +id); if(coffeeIndex &gt;= 0)&#123; this.coffees.splice(coffeeIndex, 1) &#125;; &#125;&#125; Use dependencies in controller In the controller file: 123456789101112131415161718192021222324252627282930@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; constructor(private readonly coffeesService: CoffeesService)&#123;&#125; @Get() findAll(@Query() paginationQuery)&#123; //const &#123;limit, offset&#125; = paginationQuery; return this.coffeesService.findAll(); &#125; @Get(&#x27;:id&#x27;) findOne(@Param(&#x27;id&#x27;) id:string)&#123; return this.coffeesService.findOne(id); &#125; @Post() create(@Body() body)&#123; return this.coffeesService.create(body); &#125; @Patch(&#x27;:id&#x27;) update(@Param(&#x27;id&#x27;) id: string, @Body() body)&#123; return this.coffeesService.update(id, body); &#125; @Delete(&#x27;:id&#x27;) remove(@Param(&#x27;id&#x27;) id: string)&#123; return this.coffeesService.remove(id); &#125;&#125;","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"}]},{"title":"Pagination @Put(), @Delete()","slug":"NestJS/03 Put, Delete, Pagination","date":"2022-09-14T02:19:51.000Z","updated":"2022-11-12T00:01:53.362Z","comments":true,"path":"2022/09/14/NestJS/03 Put, Delete, Pagination/","link":"","permalink":"https://redre4per.github.io/2022/09/14/NestJS/03%20Put,%20Delete,%20Pagination/","excerpt":"","text":"Status code problem Nest will give a default status code of 200 when the request is successful. But we can also customize the status code and return. Nest does not need to memorize all status codes, you can use @HttpCode(HttpStatus. Prompt) to select the prompt status, which will automatically return the corresponding status code. 12345678910import &#123; Controller, Get, Param, Post, Body &#125; from &#x27;@nestjs/common&#x27;;@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; @Post() @HttpCode(HttpStatus.GONE) //Decorator position, return 410GONE. create(@Body(&#x27;name&#x27;) body)&#123; return body; &#125;&#125; @HttpCode(HttpStatus.hint) is placed before the callback function, which means that the result returned by the callback function after it must be the only definite status. @Res() native express response processing method The @Res() decorator can be used in endpoint method parameters, allowing us to use native express response handling methods. 1234567@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; @Get() findAll(@Res() response)&#123; response.status(200)send(&#x27;This action returns all coffees&#x27;); &#125;&#125; This approach is flexible and provides header manipulation, library specific functionality, etc., but should be used with care. It has the disadvantage of losing compatibility with Nest features that rely on Nest’s standard response handling, such as interceptors and the @HttpCode() decorator. It also makes the code harder to test and has to mock the response object. Put and Patch Put replaces the entire resource, so we need to include the entire object in the request payload. Patch is different in that it only modifies part of the resource. We could even just update a single property of the resource if we wanted to. The corresponding methods for Put and Patch are update . 1234567@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; @Patch(&#x27;:id&#x27;) update(@Param(&#x27;id&#x27;) id: string, @Body() body)&#123; //Pay attention to the spelling return `This action updates #$&#123;id&#125; coffee`; &#125;&#125; Pay attention to the spelling here. When using Params, Query or req.body parameters, you must first declare the corresponding @ decorator. In addition, if it is all res.body, it should be written as @Body() body , () cannot be lost. Delete The corresponding method of Delete is remove() . 1234567@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; @Delete(&#x27;:id&#x27;) remove(@Param(&#x27;id&#x27;) id: string)&#123; //remove, note that id is also passed in return `This action removes #$&#123;id&#125; coffee`; &#125;&#125; ​ Pagination We want to use path parameters: identify a specific resource, and when using query parameters: filter or sort that resource. The @Query decorator in Nest is used to get all or a specific part of query parameters. 12345678@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; @Get() findAll(@Query() paginationQuery)&#123; const &#123; limit, offset&#125; = paginationQuery; return `This action returns all coffees. Limit: $&#123;limit&#125;, offset: $&#123;offset&#125;`; &#125;&#125;","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"}]},{"title":"Controller, @Get(), @Post()","slug":"NestJS/02 Controller, Get, Post","date":"2022-09-13T13:11:29.000Z","updated":"2022-11-09T06:16:13.281Z","comments":true,"path":"2022/09/13/NestJS/02 Controller, Get, Post/","link":"","permalink":"https://redre4per.github.io/2022/09/13/NestJS/02%20Controller,%20Get,%20Post/","excerpt":"","text":"Generate a controller by running the Nest CLI Command: nest generate controller, which can be abbreviated as nest g co. Then enter the name of the controller. (If you don’t want to generate test files, you should type nest g co --no-spec ) After running, nest will help us create a folder containing controller and spec files. At this time, the app.module.ts file will automatically introduce this controller to the controllers array. If you want to create a controller in a subfolder of src, the command can be rewritten as nest generate controller modules/abc. If you want to see the simulated output, you can use nest generate controller modules/abc --dry-run. He doesn’t actually create the file. URL access and controller matching mechanism Nest uses @Controller(&#39;route&#39;) to match controller and url. 12@Controller(&#x27;coffees&#x27;) //It can be accessed when accessing http://localhost:3000/coffees with GET.export class CoffeesController &#123;&#125; When controller is empty, it will return 404 and error message. Also note that methods like Controller and Get&#x2F;Post are imported from @nestjs&#x2F;common. Build http handler, Get First introduce Methods such as Get from @nestjs&#x2F;common. The corresponding methods for Get are findAll() and findOne. 123456789import &#123; Controller, Get &#125; from &#x27;@nestjs/common&#x27;;@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; @Get() findAll()&#123; return &#x27;This action returns all coffees&#x27;; &#125;&#125; Nested Paths In a class decorated with @Controller(&#39;primary path&#39;), secondary paths can be nested. 1234567@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; @Get(&#x27;flavors&#x27;) //Put the secondary route here. findAll()&#123; return &#x27;This action returns all coffees&#x27;; &#125;&#125; At this time, visit localhost:3000&#x2F;coffees&#x2F;flavors to access the content. Use routing parameters (dynamic path) You can use route parameters by writing (&#39;:id&#39;) in the decorator, and import Param from @nestjs&#x2F;common. The @Param() decorator allows us to take all incoming request parameters and use them in the body of the method. When nothing is passed inside the @Param() decorator, it receives all request parameters, let’s access params.id from the object. 123456789import &#123; Controller, Get, Param &#125; from &#x27;@nestjs/common&#x27;;@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; @Get(&#x27;:id&#x27;) //Put the secondary route here. findOne(@Param() params)&#123; return `This action returns #$&#123;params.id&#125; coffees`; &#125;&#125; When the @Param() decorator passes in a parameter, first declare the parameter type, and then use the parameter directly. 123456789import &#123; Controller, Get, Param &#125; from &#x27;@nestjs/common&#x27;;@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; @Get(&#x27;:id&#x27;) findOne(@Param(&#x27;id&#x27;) id: string)&#123; //The parameter type is declared here. return `This action returns #$&#123;id&#125; coffees`; &#125;&#125; ​ Post and @Body decorators The @Body decorator is used to get all or specific parts of request.body. Note that both Post and Body are imported from @nestjs&#x2F;common. The corresponding method of Post is create . 123456789import &#123; Controller, Get, Param, Post, Body &#125; from &#x27;@nestjs/common&#x27;;@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; @Post() create(@Body() body)&#123; return body; &#125;&#125; As with the @Param decorator, it is possible not to access the body as a whole, but a specific part. 123456789import &#123; Controller, Get, Param, Post, Body &#125; from &#x27;@nestjs/common&#x27;;@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; @Post() create(@Body(&#x27;name&#x27;) body)&#123; //Incoming parameters return body; &#125;&#125; The problem with this way is that if only certain properties are accessed, other properties will not be validated.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"}]},{"title":"Introduction to Nest.js","slug":"NestJS/01 Introduction","date":"2022-09-13T11:31:49.000Z","updated":"2022-11-09T05:39:45.112Z","comments":true,"path":"2022/09/13/NestJS/01 Introduction/","link":"","permalink":"https://redre4per.github.io/2022/09/13/NestJS/01%20Introduction/","excerpt":"","text":"Difference between NestJS and NodeJS NestJS is a framework that lets programmers focus on the application problem at hand rather than the tiny implementation details like setting up TypeScript, API routing, error handling, middleware setup, etc. Think of NestJS as a layer on top of NodeJS itself, abstracting away difficult tasks, tools and boilerplate code, and adding a complete toolkit for application development. NestJS uses express as the bottom layer by default, or you can choose Fastify or others (but you need to set up a compatible library). Before using NestJS First install NodeJS, version 12 or 13 at least. View in Terminal: node --version. Install cli: npm i -g @nestjs/cli. Check the version number of nest after installation: nest --version. Nest cli nest cli is a companion tool for nestJS, which can help us generate files, run, compile and even bundle our applications. It contains many commands, which can be viewed with nest --help. Create your first nest application In Terminal, enter nest new. Then follow the prompts to select the name and package manager. After creation, enter cd new file name, npm run start, you can open and browse to localhost: 3000 to open the file. Nest folder structure Inside the Nest app, everything has a defined structure. In the folder, there are many files that are familiar before, but be aware of a specific unique file called Nest cli json . The entry file of nest is the main.ts file under src. Nest files are created with NestFactory.create(AppModule). AppModule is the root module of our application and contains everything our application needs to run. It consists of many small modules that combine to form a complete application. After opening the app.module.ts file, you can see the decorator @Module(). Decorators can be used on classes or other methods. The first layer in @Module(&#123; &#125;) is the controllers and providers of the entry-level file app.modules.js, if not, delete it. After that, import: [] is used to load other modules. Folders for these modules are placed in the src directory. controller and service basic Controller is a class, but with the @Controller() decorator. Controllers are used to handle specific requests. The controller needs to use service to separate the logic. In the app.controller.ts file: 123456789@Controller()export class AppController&#123; constructor(private readonly appService: AppService)&#123;&#125; @Get() getHello(): string&#123; return this.appService.getHello(); &#125;&#125; In the app.service.ts file: 123456@Injectable()exports class AppService &#123; getHello(): string&#123; return &#x27;Hello World!&#x27;; &#125;&#125; API test software Insomnia &amp; Postman Start Nest in dev mode npm run start: dev. This mode integrates nodemon functionality.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"}]},{"title":"Custom hooks","slug":"React/H10 Custom hooks","date":"2022-09-03T11:57:27.000Z","updated":"2022-11-12T01:25:47.973Z","comments":true,"path":"2022/09/03/React/H10 Custom hooks/","link":"","permalink":"https://redre4per.github.io/2022/09/03/React/H10%20Custom%20hooks/","excerpt":"","text":"Where to use With custom Hooks, component logic can be extracted into reusable functions. React Hooks means that components should be written as pure functions as much as possible. If external functions and side effects are required, use hooks to “hook” external code in. React Hooks are those hooks. Custom hooks rules **A custom Hook is a function whose name starts with “use“, and other Hooks can be called inside the function. **React will treat functions starting with use differently from other functions. Therefore, functions other than Custom hooks cannot begin with use. scenes to be used The main usage scenarios of Custom hooks: Extract the business logic layer Encapsulate general logic Monitor browser status Split complex components Use Cases Written by myself in the CourtCanva project. scenes to be used: If you write it with a package function, you need to package the function in useEffect(), which will lead to code redundancy. That is, the various states obtained by useStoreSelector() cannot be directly called in external functions, but need to be passed in through parameters. At this time, the encapsulation function requires a large number of parameters, and functions such as useDispatch() are also passed in as parameters. In this case, using a custom Hook is the best choice. This can simplify the code and does not need to pass in the Redux state from the outside, because the custom Hook can call the Redux state or other Hooks internally. 12345678910111213141516171819202122232425import &#123; useStoreSelector &#125; from &quot;@/store/hooks&quot;;import useCourt from &quot;@/hooks/useCourt&quot;;import &#123; setCourtDataUrl &#125; from &quot;@/store/reducer/canvasControlSlice&quot;;import &#123; switchRuler &#125; from &quot;@/store/reducer/buttonToggleSlice&quot;;import &#123; resetAll &#125; from &quot;@/store/reducer/canvasControlSlice&quot;;const useImageDataUrl = (stageRef: RefObject&lt;Konva.Stage&gt;) =&gt; &#123; const dispatch = useDispatch(); const &#123; borderLength &#125; = useCourt(); const selectedColor = useStoreSelector((state) =&gt; state. courtColor. selectedColor); const rulerState = useStoreSelector((state) =&gt; state. buttonToggle. isRulerOn); useEffect(() =&gt; &#123; if (!stageRef.current) return; dispatch(resetAll()); rulerState ? dispatch(switchRuler(false)) : null; const image = stageRef.current.toDataURL(&#123; pixelRatio: 1.5, &#125;); dispatch(setCourtDataUrl(image)); rulerState ? dispatch(switchRuler(true)) : null; &#125;, [selectedColor, borderLength]);&#125;;export default useImageDataUrl;","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"},{"name":"Hooks","slug":"Hooks","permalink":"https://redre4per.github.io/tags/Hooks/"}]},{"title":"List of My VSCode plugins","slug":"Others/VScode plugins","date":"2022-07-03T01:26:48.000Z","updated":"2022-11-12T03:17:54.122Z","comments":true,"path":"2022/07/03/Others/VScode plugins/","link":"","permalink":"https://redre4per.github.io/2022/07/03/Others/VScode%20plugins/","excerpt":"","text":"Auto Close Tag Auto Rename Tag HTML Snippets Babel ES6&#x2F;ES7 Debugger for Chrome ESLint JavaScript (ES6) code snippets Code Spell Checker Node.js Modules Intellisense React-Native&#x2F;React&#x2F;Redux snippets for ES6&#x2F;ES7 TSLint vscode-styled-components Color Highlight Custom CSS and JS Loader EditorConfig for VS Code File Templates Git History (git log) Material Icon Theme Prettier Theme — Seti-Monokai Docker Dev Containers glean JS CodeFormer: Javascript Refactoring &amp; Code Automation Live Server Live Share Tailwind CSS intelliSence vscode-styled-components VSCode React Refactor Wallaby.js","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Other","slug":"Others/Other","permalink":"https://redre4per.github.io/categories/Others/Other/"}],"tags":[{"name":"VSCode","slug":"VSCode","permalink":"https://redre4per.github.io/tags/VSCode/"}]},{"title":"useEffect","slug":"React/H02 useEffect","date":"2022-06-18T13:12:05.000Z","updated":"2022-11-12T01:14:16.486Z","comments":true,"path":"2022/06/18/React/H02 useEffect/","link":"","permalink":"https://redre4per.github.io/2022/06/18/React/H02%20useEffect/","excerpt":"","text":"useEffect() side effects Pure functions can only perform data calculations. Where should operations that do not involve calculations (such as generating logs, storing data, changing application status, etc.) be written? Functional programming refers to operations that have nothing to do with data calculations as “side effects” (side effect). If the function directly contains operations that produce side effects, it is no longer a pure function, and we call it an impure function. Pure functions can contain side effects only through indirect means (i.e. through other function calls). ​ useEffect() basic usage For example, we want the page title (document.title) to change when the component loads. Then, the operation of changing the page title is a side effect of the component and must be implemented through useEffect(). By default, useEffect is executed every time the component renders. 12345678import React, &#123; useEffect &#125; from &#x27;react&#x27;;function Welcome(props) &#123; useEffect(() =&gt; &#123; document.title = &#x27;Loading complete&#x27;; &#125;); return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; ​ useEffect() second parameter Sometimes, we don’t want useEffect() to be executed every time it is rendered. At this time, we can use its second parameter, use an array to specify the dependencies of the side effect function, and re-render only when the dependencies change. 123456function Welcome(props) &#123; useEffect(() =&gt; &#123; document.title = `Hello, $&#123;props.name&#125;`; &#125;, [props.name]); return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; In the above example, the second parameter of useEffect() is an array, which specifies the dependencies of the first parameter (side effect function) (props.name ). The side effect function executes only when this variable changes. If the second parameter is an empty array, it indicates that the side effect parameter does not have any dependencies. Therefore, the side effect function will only be executed once after the component is loaded into the DOM, and will not be executed again after the component is re-rendered. useEffect() purpose Any side effects can be introduced using useEffect(). Its common uses are as follows. data fetching event monitoring or subscription (setting up a subscription) changing the DOM output log (logging) The most common usage is to fetch data, execute useEffect() only once when the component is mounted, and use setState() to put the fetched data into the state. The return value of useEffect() Side effects occur as components are loaded, and may need to be cleaned up when the component is unloaded. If there is any content mounted on dom in useEffect(), you need to use return to clear it. Otherwise, problems will occur, such as memory overflow causing more and more cards. useEffect() allows returning a function that is executed when the component is unmounted, cleaning up side effects. useEffect() does not return any value if there is no need to clean up side effects. In actual use, since the side effect function is executed every time it is rendered by default, the cleanup function will not only be executed once when the component is unloaded, but will also be executed once every time the side effect function is re-executed. Used to clean up side effects from the last render. Use the return value of useEffect() to interrupt outstanding network requests Both axios and fetch have similar methods to interrupt network requests, such as abort() method. You can put the API request in useEffect() and the abort() method in return. At this time, if the API is called repeatedly by triggering useEffect, abort() in the return of the previous useEffect will be triggered. If the previous API request was not completed, it will be interrupted. Notes for useEffect() There is one caveat when using useEffect(). If there are multiple side effects, and there is no relationship between them, multiple useEffect() should be called, and should not be written together. useEffect() does not want to return any value. Therefore, if you put a timer in it, because the timer will return the thread number, it will generate a value. If you don’t use const x=, you will get an error.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"},{"name":"Hooks","slug":"Hooks","permalink":"https://redre4per.github.io/tags/Hooks/"}]},{"title":"useState","slug":"React/H01 useState","date":"2022-06-16T02:28:47.000Z","updated":"2022-11-12T01:08:08.921Z","comments":true,"path":"2022/06/16/React/H01 useState/","link":"","permalink":"https://redre4per.github.io/2022/06/16/React/H01%20useState/","excerpt":"","text":"Basic usage 1const [count, setCount] = useState(initialState) count is to read state, setCount is to update state, and initialState is initial value. ​ State is an array Because React rendering only checks a shallow copy of state, React will not re-render if you only change the value in the array, rather than changing the address of the array. The solution is to copy the original array and reassign it to the state after changing it. State is an object Because React rendering only checks a shallow copy of state, React will not re-render if you only change the value in the object, rather than changing the object address. The solution is to copy the original object and reassign it to the state after the change. Arrow function update Official website. If the new state was computed using the previous state, a function can be passed to setState. The function will receive the previous value, and return an updated value. Here is an example setState that uses two forms of the counter component: The “+” and “-“ buttons use the functional form because the updated value is based on the previous value. But the “reset” button uses the normal form because it always sets the count back to the initial value. If your update function returns the exact same value as the current state, subsequent re-renders will be skipped entirely. 1234567891011function Counter(&#123;initialCount&#125;) &#123; const [count, setCount] = useState(initialCount); return ( &lt;&gt; Count: &#123;count&#125; &lt;button onClick=&#123;() =&gt; setCount(initialCount)&#125;&gt;Reset&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+&lt;/button&gt; &lt;/&gt; );&#125; Arrow functions update state in a way that makes React execute this line before going to the next line. In the normal setState(value) method, sometimes React will execute out of order due to performance optimization. State self-change in useState() Sometimes the state in useState() is used for self-increment and self-decrement, etc. At this time, it is impossible to write code like setCount(count++);, because const [count, setCount] = useState(0); when initially defined, count is a constant. Any direct modification of the state will report an error. But you can use setCount(count+1); instead. Another way is to write an arrow function in setCount(), and then evaluate the formal parameters. The value of the formal parameter is count, which is the first parameter of useState(). 123const increment = () =&gt; &#123; setCount((prev) =&gt; prev + 1);&#125; ​ The value of useState in the callback function will not change In the code below, the number on the page is always 1 greater than the console’s number. This is because the count value passed into the callback function will not change in the callback function. When setCount() is passed for the second time, its parameter count is still obtained from the outside, not the previous line in the callback function, so only 1 is added each time. 1234567891011121314const Footer = () =&gt; &#123; const [count, setCount] = useState(0); const handleCount = () =&gt; &#123; setCount(count+1); setCount(count+1); //Second time. console.log(count); &#125; return( &lt;footer&gt; &lt;p&gt;count: &#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;handleCount&#125;&gt;click me&lt;/button&gt; &lt;/footer&gt; )&#125; ​ useState() note React will run all the code on the component when it re-renders. Therefore, if setState() is not triggered by an event, it will cause re-rendering all the time, causing errors. This is because the state drives the data. Every time the state is set, it will re-render, and then call setState() to set the state again during rendering, infinite loop. If you only want to render once, use useEffect(). When using TS, such as useState&lt;String&gt;(&quot;&quot;), when must the type be defined? If the initial value of the parameter is null, the type needs to be declared. Such as useState&lt;String | null&gt;(&quot;&quot;); double type. The types that can be inferred in ts do not need to be written.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"},{"name":"Hooks","slug":"Hooks","permalink":"https://redre4per.github.io/tags/Hooks/"}]},{"title":"Responsive design","slug":"CSS/R01 Responsive design","date":"2022-05-11T11:12:37.000Z","updated":"2022-11-12T05:40:42.762Z","comments":true,"path":"2022/05/11/CSS/R01 Responsive design/","link":"","permalink":"https://redre4per.github.io/2022/05/11/CSS/R01%20Responsive%20design/","excerpt":"","text":"Responsive Layout One page corresponds to multiple devices. When the device screen&#x2F;pc webpage size changes, the page layout (not the element&#x2F;text size) will be changed automatically. Therefore, there is no need to write mobile pages separately. make suitable choices Bad choice: Choose popular fixtures. The downside is that devices come in a variety and are updated. A good choice: do a survey on 4 types of equipment, each with a width range. The downside is that equipment can still change. The perfect choice: by visual design. Responsive Development Principles of Responsive Development It is to use media queries to set the layout and style for devices of different widths, so as to adapt to the purpose of different devices. Device division Size interval (size refers to width) Layout container (usually) width setting Very Small Screen (Mobile) &lt;768px 100% Small screen devices (tablets) &gt;&#x3D;768px ~ &lt;992px 750px Moderate devices (desktop monitors) &gt;&#x3D;992px ~ &lt;1200px 970px widescreen devices (large desktop monitors) &gt;&#x3D;1200px 1170px Responsive layout container Responsive requires a parent as a layout container to cooperate with child elements to achieve change effects. The principle is to change the size of the layout container through media queries under different screens, and then change the arrangement and size of the sub-elements inside, so as to realize different page layout and style changes under different screens. Common widths of layout containers are shown in the table above. The container is a little less than the screen to make the page centered and aligned with blanks on both sides, which looks better. You can use media query to write .container &#123;&#125; by yourself in four cases. Media query Responsive design should be realized through media query. 12345@media only screen and (max-width: 600px) &#123; body &#123; background-color: lightblue; &#125;&#125; only screen is because there is a printer, speech and screen reader. For example, when the page supports printing, you can write only printer to define what content should be displayed. max-width: 600px is the old design scheme, that is, laptop is preferred. min-width: 600px Modern design is mobile-first. Such as Tailwind, Chakra. In addition, there are also horizontal&#x2F;flat parameters, such as orientation: landscape. These are advanced actions, for phones and tablets.","categories":[{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"https://redre4per.github.io/categories/HTML-CSS/"},{"name":"CSS","slug":"HTML-CSS/CSS","permalink":"https://redre4per.github.io/categories/HTML-CSS/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://redre4per.github.io/tags/CSS/"}]},{"title":"Reference","slug":"DataBase/MongoDB/7 Reference","date":"2022-04-30T02:38:05.000Z","updated":"2022-11-12T00:00:29.822Z","comments":true,"path":"2022/04/30/DataBase/MongoDB/7 Reference/","link":"","permalink":"https://redre4per.github.io/2022/04/30/DataBase/MongoDB/7%20Reference/","excerpt":"","text":"The schema part of the associated code In the schema we care about two pieces of information: the type of the association id (type), and which collection the association is (ref). The association of mongoose can only store id, and cannot store other fields because it is not supported. If you want to store fields other than id, you need to write the corresponding logic to get the fields. If it is to many, it is necessary to use association attribute s: [&#123; &#125;], if it is one to one, it is necessary to Use Associative property: &#123; &#125; . Example for many-to-many bidirectional association: 12345//schema 1courses: [&#123; type: mongoose.Types.ObjectId, //If the id type is String, write String. ref: &#x27;Course&#x27; //The model name associated with the collection, note that it is capitalized.&#125;] 12345//schema 2students: [&#123; type: mongoose.Types.ObjectId, ref: &#x27;Student&#x27;&#125;] ​ The controller part of the associated code Divided into two parts: add association and delete association. Add association Note here that in a many-to-many relationship, addCourseToStudent() and addStudentToCourse() are the same thing. Here you need to get the id information of the two parties you want to associate, and this information is written on the url: /v1/students/:id/courses/:code. If it is to add an association, the method is POST. What needs to be guaranteed is that the variable names (:id, :code) on the url must be consistent with those in const &#123; &#125; = req.params. After getting the id, first verify whether the (two) ids exist. In addition, since two id objects need to be used to verify the existence of the function, it is necessary to import the schema of another id object, such as const Course = require(&#39;../modules/course&#39;); 1234567891011121314151617181920async function addCourseToStudent(req, res)&#123; const &#123; id, code &#125; = req.params; //Take two ids const student = await Student.findById(id).exec(); //Verify that id1 exists const course = await Course.findById(code).exec(); //Verify that id2 exists if (!student || !course) &#123; //Process when there is no id return res.status(404).json(&#123; error: &#x27;Category or Subcategory not found&#x27;, &#125;); &#125; student.courses.addToSet(course._id); //It is recommended to use addToSet instead of push to avoid repetition course.students.addToSet(student._id); //Two-way binding //If it is a one-to-one relationship, that is, the associated id is not an array, it only needs to be written as student.course = course._id await student.save(); //save await course.save(); //save return res.json(student);&#125; After writing, export this function and register the route in the routing file. 1studentRouter.post(&#x27;/:id/courses/:code&#x27;, addCourseToStudent) Remove association is very similar to adding. Just change the function name in the add code to removeCourseToStudent and then addToSet() to pull(). Also, the request method should be changed from POST to DELETE. There are two logics for deletion, one is to delete whether there is a connection or not; the other is to detect whether there is a connection first, and then delete it. Usually don’t care, because the front end will know whether there is a relationship when fetching data, and the delete option will pop up when there is a relationship. If it is a one-to-one relationship, simply reassign the resource of ref to undefined. Schema and path issues for two-way binding In two-way binding, the ref in the schema must be written by both parties. However, in the controller and router, only one of them needs to be coded, because when the unilateral controller is coded, the schema of both sides will be directly introduced, and _id will be added to both sides and saved on both sides. Get the associated data after creating the association: populate() In the getXXXById() function in the controller file, add populate(&#39;field&#39;) after the findById(id) function. 123456async function getStudentById(req, res)&#123; const &#123;id&#125; = req.params; const student = await Student.findById(id).populate(&#x27;course&#x27;).exec(); if(!student)&#123;return ...&#125;; res.json(student);&#125; If the document corresponding to the query id is not associated, populate() will not report an error, but only the associated item will not be displayed. The principle here is that the principle of populate is that mongoose sends two requests to the database and splices them together. This is determined by the database structure of mongoose. All data cannot be obtained in one request, so splicing exists on the server side. Instead, sql is stitched together in the database. But mongodb also supports database-side splicing processing, which uses aggregation. Later optimization may be used, and populate can be used in the initial stage. populate() also supports fetching only a subset of fields. Same as MongoDB section 2.3.5. (id will be retrieved by default) 1const student = await Student.findById(id).populate(&#x27;course&#x27;,&#x27;name description&#x27;) .exec(); populate() can also fetch multiple nested data with two-paragraph chaining, but this is not recommended. However, this is the only way to fetch multiple associated resources. Because a single populate() can only be selected from the same resource, even with multiple attributes. Scenarios for populate() When fetching all the data, generally only metadata is needed, so there is no need to populate (resource waste). Generally, populate() is done when fetching a specific document. If two resources are associated and you want to fetch them at the same time, you can call populate() in a chain. Decide which fields populate() selects in the front end Sometimes there are too many fields associated with the resource, and the required fields must be selected from the front end (API control). 1234567async function getStudentById(req, res)&#123; const &#123; id &#125; = req.params; const &#123; fields &#125; = req. query; const student = await Student.findById(id).select(&#x27;&#x27;).populate(&#x27;course&#x27;).exec(); //Get the student&#x27;s if(!student)&#123;return ...&#125;; res.json(student);&#125; ​ Remove related associations when deleting resources When mongoose finds that the associated resource does not exist, it will not report an error. But this results in a lot of invalid data being present. 123456789101112async function deleteStudentById(req, res)&#123; const &#123;id&#125; = req.params; const student = await Student.findByIdAndDelete(id).exec(); if(!student)&#123;return...&#125;; await Course.updateMany(&#123; students:student._id&#125;, &#123; //:?.? $pull:&#123; students:student._id &#125; &#125;).exec(); res.sendStatus(204);&#125; Both sides of a bidirectional association delete the association. The code logic is the same. In the one-to-one relationship, because it is not an array, $pull cannot be used, otherwise the error “MongoServerError: Cannot apply $pull to a non-array value” will appear. The $unset operator should be used instead, with the same syntax. 123456789101112async function deleteRootCategoryId(req, res) &#123; const &#123; id &#125; = req.params; const rootCategory = await RootCategory.findByIdAndDelete(id).exec(); if (!rootCategory) &#123;&#125; await SubCategory.updateMany(&#123; parentCategory: rootCategory._id &#125;, &#123; $unset: &#123; parentCategory: rootCategory._id &#125; &#125;).exec() res.sendStatus(204);&#125; Summary The associated code is divided into three parts: schema (two-way and two-way), controller (two-way one-way&#x2F;two-way), and router (two-way one-way). In the controller, there are three parts to be added and rewritten: Add an association function (two-way and one-way) Delete the associated function (two-way and one-way) The function to find a single resource plus populate() (both sides) Delete the function of a single resource plus delete the associated code (both sides)","categories":[{"name":"Database","slug":"Database","permalink":"https://redre4per.github.io/categories/Database/"},{"name":"MongoDB","slug":"Database/MongoDB","permalink":"https://redre4per.github.io/categories/Database/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://redre4per.github.io/tags/MongoDB/"}]},{"title":"Error handling","slug":"DataBase/MongoDB/6 Error handling","date":"2022-04-27T23:12:52.000Z","updated":"2022-11-12T00:00:30.899Z","comments":true,"path":"2022/04/28/DataBase/MongoDB/6 Error handling/","link":"","permalink":"https://redre4per.github.io/2022/04/28/DataBase/MongoDB/6%20Error%20handling/","excerpt":"","text":"Method 1: try catch wraps the async request 1234567891011async function addStudent(req, res)&#123; const &#123;firstName, lastName, email&#125; = req.body; const student = new Student(&#123; firstName, lastName, email&#125;); try&#123; await student.save(); &#125; catch (e)&#123; console.log(e); return res.send(e); &#125; res.status(201).json(student);&#125; Catch errors when writing async await. ​ Method 2: Use .catch to get the error of promise 123456789async function addStudent(req, res)&#123; const &#123;firstName, lastName, email&#125; = req.body; const student = new Student(&#123; firstName, lastName, email&#125;); student.save().then().catch(e =&gt; &#123; //promise.catch console.log(e); return res.send(e); &#125;) res.status(201).json(student);&#125; Catch errors when writing promises. ​ Method 3: Callback function 1234567891011async function addStudent(req, res)&#123; const &#123;firstName, lastName, email&#125; = req.body; const student = new Student(&#123; firstName, lastName, email&#125;); student.find(error, result) =&gt; &#123; //callback function, similar to promise style if(error)&#123; console.log(e); return res.send(e); &#125; &#125; res.status(201).json(student);&#125; It is used to catch errors when writing callback functions. ​ Method selection If you are writing a new project yourself, you can choose the writing method at will. It is recommended to use the async await writing method. If it is to take over the existing code, write it in the way of the company’s current code. Writing in actual development (try catch method extension) The try catch method wraps the await code. And try catch can expand the scope, that is, wrap the entire C&#x2F;R&#x2F;U&#x2F;D function of the route handler (such as addStudeny()), that is, catch the error of the route handler. Likewise, this error handling applies to all route handlers. In the following writing method, the purpose of the function is to wrap the function passed in as a parameter in a try catch, and register it on the path as a middleware after wrapping. 12345678910function tryCatch(routeHandler)&#123; //Definition, in the student folder in the controllers file return async (req, res, next) =&gt; &#123; //Return a middleware, because this middleware needs to be registered on the path. try&#123; await routeHandler(req, res, next); &#125; catch(e)&#123; next(e); //Pass the error object to the error handling middleware. &#125; &#125;&#125;tryCatch(addStudent); Common errors are usually passed to the error handling middleware with next(e). And more specific errors will be handled directly in the function. For example, method one is often mixed with this method. Common errors are passed into the error handling middleware in this method, and specific errors are handled in the function using the method of method 1. Fetch errors directly with the express-async-errors package It enters the express framework for try catch operation. Install: npm i express-async-errors --save This package is for express@4 version. In the express@5 version, the official has built this function. (@4.18 for p3) This package should be imported under the index.js file. 1234const express = require(&#x27;express&#x27;);require(&#x27;express-async-errors&#x27;); //Use the express-async-errors package immediately after using the express packageconst User = require(&#x27;./models/user&#x27;);... In addition, const a = require(&#39;a&#39;) is written because a is exported in the file. But it should be noted that whether the file is exported or not has no effect on the execution of the code inside the file, that is, when require(&#39;a&#39;), the code inside the a file has been executed once. And express-async-errors has made changes to the express object in the code, no need to export. The error returned at this time is an error interpretation of express, which is difficult to read and needs further processing. For handling captured errors, you can create an errorHandler.js file in the middleware folder (&#78;&#x6f;&#100;&#x65;&#x2e;&#106;&#115;&#x40;&#52;&#46;&#x35;): 123456module.exports = (error, req, res, next) =&gt; &#123; console.log(error); return res.status(500).json(&#123; error:&#x27;Error! Please try later&#x27;, &#125;)&#125; ErrorHandler.js is referenced in index.js and registered on the app. (Written before connectToDB) 1app.use(errorHandler); At this time, an error is returned, which is status code 500, and the returned JSON content is customized. Therefore, how to handle errors is actually based on the logic in errorHandler.js. 500 is an under-the-radar error, and a series of if&#x2F;else or switch should actually be used to handle various errors. The logic in it is to detect the type of error and then handle it. like: 1234567891011module.exports = (error, req, res, next) =&gt; &#123; if(error.name === &#x27;validationError&#x27;)&#123; //Original method, because it is unknown whether there is a name attribute in error. //To find the error property by breakpoint or documentation. return res.status(400).json(error); //This is to pass the error object to the front end. But actually only the message is needed. &#125; //In fact, the development environment returns all the information, and the production environment only needs to return the message. console.log(error); return res.status(500).json(&#123; error:&#x27;Error! Please try later&#x27;, &#125;)&#125; Compatible with the production environment and the development environment: 1234567module.exports = (error, req, res, next) =&gt; &#123; if(error.name === &#x27;validationError&#x27;)&#123; if(process.env.NODE_ENV === &#x27;production&#x27;)&#123; return res.status(400).json(&#123; error: error.message&#125;); &#125; return res.status(400).json(error); &#125; A better way to detect: 1234567891011module.exports = (error, req, res, next) =&gt; &#123; if(error instanceof CustomError)&#123;&#125;&#125;next(new CustomError(&#x27;xxxxx&#x27;)); // throw errorclass CustomError extends Error &#123; constructor(message)&#123; super(message); &#125;&#125; ​ handling more bugs If there are too many errors, the errorHandler.js file will be too long. The file should be removed at this time. The structure should then be: 12345|-- middleware |-- error |-- index.js //Introduce all error handling files and export them uniformly |-- validationErrorHandler.js //If the error is a validation error, return it; if not, use `next()` to pass to the next file. |-- xxxxErrorHandler.js At this time, it should also be imported with app.use() in index.js in the root directory.","categories":[{"name":"Database","slug":"Database","permalink":"https://redre4per.github.io/categories/Database/"},{"name":"MongoDB","slug":"Database/MongoDB","permalink":"https://redre4per.github.io/categories/Database/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://redre4per.github.io/tags/MongoDB/"}]},{"title":"Project structure","slug":"Express/8 Project structure","date":"2022-04-16T06:23:58.000Z","updated":"2022-11-10T14:01:16.978Z","comments":true,"path":"2022/04/16/Express/8 Project structure/","link":"","permalink":"https://redre4per.github.io/2022/04/16/Express/8%20Project%20structure/","excerpt":"","text":"Create a project First create the src folder in the project folder, then create the entry file index.js in it, then run npm init -y . Then install express, dotenv, cors, morgan, Mongoose packages. npm i express dotenv cors morgan mongoose. morgan can show which requests are sent to the server. Project Structure (Orientation 1) 123456789101112131415161718192021--package.json--package-lock.json--src |-- index.js //Entry file (server.js, app.js) |-- routes |-- tasks.js //(task router) (or named task.routes.js) |-- users.js //(user router) (or named users.routes.js) |-- index.js //(Import all the routers above and make a unified export) |-- controllers // (logical processing part) |-- tasks.js //(task Controller) (or named tasks.controllers.js) |-- users.js //(user Controller) (or named users.controllers.js) |-- models |-- tasks.js //(task Controller) The format design of the task data in the database. Used for ORM (object relational mapping, used to interact with the database). |-- middleware |-- error-middleware |-- xxxErrorHandler.js |-- authGuard |-- cors |-- utils //(Helper function, shared function, db) There is a high probability. |-- db |-- config //Project configuration (environment variable processing), not necessarily. ​ Other project structures There are other splitting methods for this splitting direction, possibly merging routes and controllers, which is also very common. In the above split method, there is no logic in routes, it just points to controllers. Another way to split is to add a layer of services. The logic of services is separated from controllers. If it is removed, controllers will not be responsible for logic processing. Each additional layer of the project becomes more complex.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Express.js","slug":"Back-end/Express-js","permalink":"https://redre4per.github.io/categories/Back-end/Express-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"Express.js","slug":"Express-js","permalink":"https://redre4per.github.io/tags/Express-js/"}]},{"title":"Mongoose","slug":"DataBase/MongoDB/4 Mongoose","date":"2022-04-16T03:58:04.000Z","updated":"2022-11-12T00:00:32.345Z","comments":true,"path":"2022/04/16/DataBase/MongoDB/4 Mongoose/","link":"","permalink":"https://redre4per.github.io/2022/04/16/DataBase/MongoDB/4%20Mongoose/","excerpt":"","text":"Mongoose Introduction Mongoose is a package that uses promises and async&#x2F;await. Mongoose is an ORM (object relational mapper) or ODM (object data mapping), which is specific to Mongodb. It encapsulates functions such as CRUD, provides new interfaces, and is more convenient. There are similar packages for other databases like the sequelize package for databases like mySQL. In actual development, there is rarely direct interaction with the database, and the ORM library is used for CRUD. If you pursue the ultimate efficiency, you may write an ORM library by hand, because the popular ORM library is aimed at most users. Data is fetched from the database to the server, and it will go through the Mongoose layer in the middle. Mongoose will convert json raw data into Object in JS, so that we can operate Mongoose objects by operating on Object. There’s some performance loss here, and sometimes you don’t need to convert, you need to optimize yourself. ​ Keywords in Mongoose Schema, Model, Document are keywords in Mongoose. schema is the data design diagram, the fields that list the data, etc. Model (corresponding to collection in Mongodb) is to create a model through schema drawings. One use is to generate a document (create a model instance), which needs to be passed in the fields defined in the schema. Another use of Model is collection operations on data, you can add documents, search the entire collection, etc. document is slightly different from document in Mongodb, it is similar to document in Mongodb. It is a JS object and is created by Mongoose. Therefore, it is not only the data in bson format in the database, but also supports the API in Mongoose to process data more conveniently. 123const schema = new mongoose.Schema(&#123;name: String&#125;);const Model = mongoose.model(&#x27;Model&#x27;, schema);const document = new Model(&#123;name: &#x27;document&#x27;&#125;) ​ Install Mongoose npm i mongoose Because Mongoose is used to create a model for a resource, it should be placed in the models folder under src. ​ Processing of pictures in the database There are generally two ways to process images. Save the base64 image directly to the database. In this case, if the image is large, each read will be slower. Not recommended. The database will not store data directly, but first upload the image to the image bed (such as github, AWS S3), and the platform will return the url and then store it in the database.","categories":[{"name":"Database","slug":"Database","permalink":"https://redre4per.github.io/categories/Database/"},{"name":"MongoDB","slug":"Database/MongoDB","permalink":"https://redre4per.github.io/categories/Database/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://redre4per.github.io/tags/MongoDB/"}]},{"title":"Relationships","slug":"DataBase/MongoDB/3 Relationships","date":"2022-04-15T11:36:45.000Z","updated":"2022-11-12T00:00:34.274Z","comments":true,"path":"2022/04/15/DataBase/MongoDB/3 Relationships/","link":"","permalink":"https://redre4per.github.io/2022/04/15/DataBase/MongoDB/3%20Relationships/","excerpt":"","text":"Association (similar to sql) In sql, the association may be 1-to-many, and the many parts may be 0, 1, and Many. The data in Mongodb is stored in the form of an array, so it may be 0 data, regardless of whether it is 0 or not. The principals associated in Mangodb are documents in the collection. There are one-to-one, one-to-many, and many-to-many associations in MongoDB. Associations are further divided into embedded and referenced. Embedded: directly embed another document into the current document and become an Object of it. 123456_id: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;)name: &quot;derek&quot;address: Objectcity: &quot;sydney&quot;address: &quot;01234 Yesenia Loop&quot;postcode: 3456 The above is a one-to-one situation. In the one-to-many case, multiple additional documents form an array, each element of which is an object. 1234567891011_id: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;)name: &quot;derek&quot;address: Array 0: Objectcity: &quot;sydney&quot;address: &quot;01234 Yesenia Loop&quot;postcode: 3456 1: Objectcity: &quot;brisbane&quot;address: &quot;166 adelaide street&quot;postcode: 4000 The many-to-many case is more complicated than the reference form. Because when you need to modify the embedded Object, because of many-to-many, it corresponds to multiple documents, then you need to scan the entire collection. So in many-to-many, the reference form is generally used. Reference : The reference is in one document and stores the _id of another associated document. One-on-one time: Reference 123_id: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;)name: &quot;derek&quot;address: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxx111&quot;) In another collection 12345_id: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;)city: &quot;sydney&quot;address: &quot;01234 Yesenia Loop&quot;postcode: 3456student: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;) In a one-to-many case, the _ids of multiple other documents will form an array, each element being an _id. Reference 12345_id: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;)name: &quot;derek&quot;address: Array 0: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx1&quot;) 1: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx2&quot;) In another collection 1234567891011_id: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx1&quot;)city: &quot;sydney&quot;address: &quot;01234 Yesenia Loop&quot;postcode: 3456student: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;)------------------------------------------------_id: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx2&quot;)city: &quot;brisbane&quot;address: &quot;166 adelaide street&quot;postcode: 4000student: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;) There is no change in the many-to-many case, except that the other multiple documents also use an array to represent the associated documents. Reference 12345_id: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;)name: &quot;derek&quot;address: Array 0: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx1&quot;) 1: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx2&quot;) In another collection 123456789101112131415_id: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx1&quot;)city: &quot;sydney&quot;address: &quot;01234 Yesenia Loop&quot;postcode: 3456student: Array 0: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;) 1: ObjectId(&quot;yyyyyyyyyyyyyyyyyyyyyyyyy&quot;)---------------------------------------------_id: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx2&quot;)city: &quot;brisbane&quot;address: &quot;166 adelaide street&quot;postcode: 4000student: Array 0: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;) 1: ObjectId(&quot;yyyyyyyyyyyyyyyyyyyyyyyyy&quot;) ​ Two-way binding and one-way binding in Reference If you use document1 (such as students), you only need to know document2 (such as address), and you don’t need to know which document1 (student) is in document2 (address) at all, just use a one-way association. But if you want to search document1’s information from document2, you need two-way binding. Normalization and de-Normalization De-Normalization is duplication, such as duplicating another document data in Embedded, and normalization is the opposite. In practice, it is common to copy a small piece of data in another document, such as city in address, without copying other details in address. The advantage of this is that there is no need to use the populate form to fetch data through the associated operation document (performance-intensive), and the query time is faster. But the disadvantage is that if the address is updated, the copied information needs to be updated. There is a trade-off, considering which operations users use read&#x2F;write more. one to millions relationship An extreme example of unilateral binding. There is a 16mb limit for a single document in Mongodb, some smaller in other databases. For example, there is one data file and one million sensor files. At this time, data cannot be stored in the sensor file because it takes up too much space. At this time, the sensor should be bound one-way with data. Embedded and referenced usage scenarios If you can do embedded, try to do it, especially in the case of one-to-one relationship. If it is one to several, you can consider embedded, but it depends on the scene. If you think the number of couples in one to couple will not expand to hundreds, you can use it. If it’s a pair of hundreds or more, consider using citations If it is a pair of millions, consider unilateral binding references If reading requirements are much greater than writing requirements, de-normalization should be considered to copy frequently read data to improve query efficiency. Index The purpose of index is to help sort and find faster. Two common types of indexes are sort ordering and unique uniqueness. By default, there is only _id index (guaranteed uniqueness) in the collection. Aggregation Aggregation pipeline is to modify or add to a certain raw data, similar to middleware, here called stage. Data can be filtered&#x2F;added and passed to subsequent stages. Aggregation operations can be implemented entirely on the server side, but the performance is much worse. Because databases are designed to manipulate data, and Node.js is not. Therefore, the operation of data should be done on the database side as much as possible. Also, all data is manipulated on the server side, a lot of data is transferred, and a lot of data is useless. The best way is to operate the data on the database side now, and then pass it to the server. Transaction Transactions are combined data operations, such as bank transfers, adding money and subtracting money to be combined in a transaction. It can guarantee that different data operations succeed or fail at the same time. The transaction function can be added later.","categories":[{"name":"Database","slug":"Database","permalink":"https://redre4per.github.io/categories/Database/"},{"name":"MongoDB","slug":"Database/MongoDB","permalink":"https://redre4per.github.io/categories/Database/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://redre4per.github.io/tags/MongoDB/"}]},{"title":"CORS","slug":"Express/7 CORS","date":"2022-04-14T13:39:21.000Z","updated":"2022-11-10T13:47:11.721Z","comments":true,"path":"2022/04/14/Express/7 CORS/","link":"","permalink":"https://redre4per.github.io/2022/04/14/Express/7%20CORS/","excerpt":"","text":"Interface cross domain problem There are two main solutions to solve the interface cross-domain problem: CORS (mainstream solution, recommended) JSONP (flawed solution, only supports GET requests) Use cors middleware to solve cross-domain problems cors is a third-party middleware for Express. Cross-domain problems can be easily solved by installing and configuring cors middleware. Steps for usage: Run npm install cors install middleware Use const cors = require(&#39;cors&#39;) import middleware Call app.use(cors()) before routing Configure middleware What is CORS CORS (Cross-Origin Resource Sharing) consists of a series of HTTP response headers that determine whether the browser prevents front-end JS code from obtaining resources across domains. By default, the browser’s same-origin security policy prevents web pages from obtaining resources across domains. However, if the interface server is configured with CORS-related HTTP response headers, the cross-domain access restriction on the browser side can be lifted. Precautions: CORS is mainly configured on the server side. The client browser can request the CORS-enabled interface without any additional configuration. CORS is compatible with browsers. Only browsers that support XMLHttpRequest Level2 can normally access the server-side interface with CORS enabled, such as IE10+, Chrome4+, FireFox3.5+. CORS related response headers Access-Control-Allow-Orign Access-Control-Allow-Orign: &lt;origin&gt;|* : where the origin parameter value specifies the out-of-domain URL that is allowed to access the resource. For example the following field value will allow only requests from http://itcast.cn: 1res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;http://itcast.cn&#x27;) If the specified value is the wildcard *, it means that requests from any domain are allowed: 1res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;) Access-Control-Allow-Headers By default, CORS only supports the client to send 9 request headers to the server (the client request header is not within these 9, the request fails): Accept, Accept-Language, Content-Language, DPR, Downlink, Save-Data, Viewport-Width, Width, Content-Type (values are limited to text&#x2F;plain, multipart&#x2F;form-data, application&#x2F;x-www-form -urlencoded one of the three) If the client sends additional request header information to the server, it needs to declare the additional request header on the server side through Access-Control-Allow-Headers, otherwise the request will fail. 1res.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;Content-Type, X-Custom-Header&#x27;) Access-Control-Allow-Methods By default, CORS only supports client-side GET, POST, and HEAD requests. If the client wants to request the server’s resources through PUT, DELETE, etc., it needs to specify the HTTP methods allowed by the request through Access-Control-Allow-Methods on the server side. . 1res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;POST, GET, DELETE, HEAD&#x27;) 1res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;*&#x27;) ​ Classification of CORS Requests When the client requests the CORS interface, according to the difference of request method and request header, the CORS request can be divided into two categories classes, which are: Simple request: Both conditions are met: The request method must be one of GET, POST, HEAD The HTTP header information must not contain custom headers, which need to be within the nine request headers in Section 4.7.4.2 Preflight request: As long as the request meets any of the following conditions, a preflight request must be made The request method is a request method other than GET, POST and HEAD The request header contains custom header fields The data in application&#x2F;json format is sent to the server Before the browser and the server formally communicate, the browser will send an OPTION request for preflight to know whether the server allows the actual request, so this OPTION request is called a preflight request. After the server successfully responds to the preflight request, it will send the real request with real data. The difference between a simple request and a preflight request: In a simple request, the client and the server only make one request, while the preflight request is twice (OPTION preflight request and real request).","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Express.js","slug":"Back-end/Express-js","permalink":"https://redre4per.github.io/categories/Back-end/Express-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"Express.js","slug":"Express-js","permalink":"https://redre4per.github.io/tags/Express-js/"}]},{"title":"Interface (Summary)","slug":"Express/6 Interface","date":"2022-04-14T11:47:07.000Z","updated":"2022-11-10T13:46:29.408Z","comments":true,"path":"2022/04/14/Express/6 Interface/","link":"","permalink":"https://redre4per.github.io/2022/04/14/Express/6%20Interface/","excerpt":"","text":"Create interface steps (summarize previous lessons) Create the basic server: app.js 123456const express = require(&#x27;express&#x27;)const app = express()//main codeapp.listen(80, function()&#123; console.log(&#x27;Express server running at http://127.0.0.1&#x27;)&#125;) Create an API routing module apiRouter.js routing module 1234const express = require(&#x27;express&#x27;)const apiRouter = express.Router()//main codemodule.exports = apiRouter app.js import and register routing module 12const apiRouter = require(&#x27;./apiRouter.js&#x27;)app.use(&#x27;/api&#x27;, apiRouter) ​ Write a GET interface 12345678apiRouter.get(&#x27;/get&#x27;, (req, res) =&gt; &#123; const query = req.query //req.query can access the parameters sent to the server in the form of query strings, see 4.1.8 for details. res.send(&#123; status: 0, //0 succeeds, 1 fails msg:&#x27;GET request succeed&#x27;, data:query &#125;)&#125;) ​ Write POST interface 12345678apiRouter.post(&#x27;/post&#x27;, (req, res) =&gt; &#123; //Get the URL-encoded data sent by the client to the server through the request body const body = req.body //req.body object, which can access the request body data, see 4.5.5 for details. res.send(&#123; status: 0, //0 succeeds, 1 fails msg:&#x27;POST request succeed&#x27;, data:body &#125;)&#125;) Note: If you want to get the request body data in URL-encoded format, you must configure the middleware: 1app.use(express.urlencoded(&#123;extended:false&#125;)) ​ Interface cross domain problem The above GET&#x2F;POST interface does not support cross-domain requests. (It appears that postman can request success, but the request in the html page cannot be successful.) ​","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Express.js","slug":"Back-end/Express-js","permalink":"https://redre4per.github.io/categories/Back-end/Express-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"Express.js","slug":"Express-js","permalink":"https://redre4per.github.io/tags/Express-js/"}]},{"title":"Middleware classification","slug":"Express/5 Middleware classification","date":"2022-04-13T13:18:48.000Z","updated":"2022-11-10T13:37:00.281Z","comments":true,"path":"2022/04/13/Express/5 Middleware classification/","link":"","permalink":"https://redre4per.github.io/2022/04/13/Express/5%20Middleware%20classification/","excerpt":"","text":"Classification of middleware Express officially divides common middleware usage into five categories: Application-level middleware Route-level middleware Error-level middleware Express built-in middleware Third-party middleware Application level middleware Via app.use() or app.get() or app.post() , Middleware bound to the app instance, called application-level middleware. (That is, the example in Section 4.4.) 123456app.use((req, res, next) =&gt; &#123; next()&#125;)app.get(&#x27;/&#x27;, mw1, (req, res) =&gt; &#123; res.send(&#x27;Home page.&#x27;)&#125;) ​ Route level middleware Middleware bound to an express.Router() instance is called a route-level middleware. Its usage is no different from application-level middleware. The difference is that the application-level middleware is bound to the app instance, and the route-level middleware is bound to the router instance: 123456789const app = express()const router = express.Router()router.use(function(req, res, next)&#123; //Route-level middleware console.log(&#x27;Time: &#x27;, Date.now()) next()&#125;)app.use(&#x27;/&#x27;, router) //register route and add prefix ​ Error level middleware The role of the error level middleware: It is specially used to capture the exception errors that occur in the entire project, thereby preventing the problem of the project from crashing abnormally. When an error occurs in the code, it can be directly caught by the error middleware (the code jumps to the error middleware), similar to catch(). If the error middleware is not written, the project will crash when an error occurs and cannot continue to run. In the function processing function of the error level middleware, must have 4 formal parameters, which are (err, req, res, next) from front to back. Error level middleware must be registered after all routes. 12345678910111213141516app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; //Route throw new Error(&#x27;Error in server!&#x27;) //Throw a custom error res.send(&#x27;Home page.&#x27;)&#125;)const middleware1 = (req, res) =&gt; &#123; //Route if token not exist &#123; next(new Error(&#x27;error&#x27;)) // use next() to throw an error return; &#125; next()&#125;)app.use(function(err, req, res, next)&#123; //Error level middleware console.log(&#x27;Error happened: &#x27; + err.message) //Print error message on the server res.send(&#x27;Error! &#x27; + err.message) //Response error message to client&#125;) There are generally multiple error middleware, and each error middleware is responsible for one type of error. When calling the next error middleware, the error needs to be passed on in the form of next() parameter. However, even with multiple error middleware, there is no guarantee that all errors are caught 100%. So check if the error was passed to the last error middleware (the last error middleware doesn’t handle errors, it’s the bottom line). If passed, it should return a 500 status code (bad choice, but only write a 500 status code), and log the error for later fixes. How to handle errors in the error handler, determine the statue code, and extract the information from the error object Errors are not written by themselves 12345const errorM1 = (error, req, res, next) =&gt; &#123; //error usually passes an object, although a string can be passed. if(error.type === &#x27;validationError&#x27;)&#123; res.status(400).json(&#123;error:error.message&#125;); &#125;&#125; Errors are self-written and detected with instanceof. This method can detect whether the former is an instance of the latter. If the former is inherited by the latter via new constructs or extends, it counts as an instance of the latter. 12345const errorM1 = (error, req, res, next) =&gt; &#123; if(error instanceof CustomError)&#123; res.status(400).json(&#123;error:error.message&#125;); &#125;&#125; Registration error middleware Registered globally in app.use(), before app.listen(). Express built-in middleware Since Express version 4.16.0, Express has built-in 3 commonly used middleware to improve development efficiency and experience: express.static The built-in middleware for fast hosting of static resources (detailed in Section 4.2), such as HTML files, images, CSS styles, etc., has no compatibility. express.json parses the request body data in JSON format (with compatibility, only available in 4.16.0+ version). The request body data can be generated in postman, select body-raw-rightmost drop-down menu and select JSON. Object in JSON format, attribute name must be added with &quot; &quot;. The req.body property can be used in the server to receive the request body data sent by the client. By default, req.body equals undefined if no middleware for parsing form data is configured. The parsed data will be mounted in req.body and can be accessed later. 1app.use(express.json()) //Global middleware. There is no need to add parameters/attributes in (), because it is a global analysis. express.urlencoded parses request body data in URL-encoded format (compatibility, only available in 4.16.0+ versions). Basically the same as express.json usage. Select body-(x-www-form-urlencoded) on postman. 1app.use(express.urlencoded(&#123; extended:false &#125;)) //Global middleware, fixed writing ​ Third-party middleware It is not an official built-in Express, but a middleware developed by a third party. Before express 4.16.0, the body-parser third-party middleware was often used to parse request body data. Third-party middleware needs to be downloaded and configured to be used. Steps for usage: Run npm install middleware package_name to install the middleware Use require to import middleware (requires path) Call app.use() to register and use middleware Custom middleware case Manually emulate a middleware like express.urlencoded to parse the form data POSTed to the server. step: Define middleware Listen to the data event of req (as long as the data event is triggered, it proves that data is sent to the server) In the middleware, you need to listen to the data event of the req object to get the data sent by the client to the server (use .on to listen). If the amount of data is relatively large and cannot be sent all at once, the client will cut the data and send it to the server in batches. Therefore, the data event may be triggered multiple times. Each time the data event is triggered, the obtained data is only a part of the complete data, and the received data needs to be spliced manually. 1234let str = &#x27;&#x27; //Used to store the request body data sent by the clientreq.on(&#x27;data&#x27;, (chunk) =&gt; &#123; //.on method binds events. str += chunk //splicing request body data&#125;) //Next() is not written here because it is not a separate middleware, but it is placed inside the same middleware with the end event below. Listen to the end event of req (end triggering proves that the data has been sent and the server has completely received the form data) 123req.on(&#x27;end&#x27;, () =&gt; &#123;console.log(str)&#125;) Use the querystring module to parse the request body data 12345const qs = require(&#x27;querystring&#x27;)req.on(&#x27;end&#x27;, () =&gt; &#123;const body = qs.parse(str) next()&#125;) Mount the parsed data object as req.body (because express uses req.body to receive the request body data from the client, here we need to replace the original data with data in a new format) The upstream middleware and downstream middleware and routes share the same req and res. Therefore, we can mount the parsed data as a custom attribute of req and name it req.body for downstream use. 123456const qs = require(&#x27;querystring&#x27;)req.on(&#x27;end&#x27;, () =&gt; &#123;const body = qs.parse(str) req.body = body next()&#125;) Encapsulate custom middleware into modules 1234//custom-body-parser.js moduleconst qs = require(&#x27;querystring&#x27;)function bodyParser(req, res, next)&#123;/* Omit other code, in fact, put the previous steps into a middleware */&#125;module.exports = bodyParser //encapsulated into a module 12const myBodyParser = require(&#x27;custom-body-parser&#x27;)app.use(myBodyParser) //call the module","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Express.js","slug":"Back-end/Express-js","permalink":"https://redre4per.github.io/categories/Back-end/Express-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"Express.js","slug":"Express-js","permalink":"https://redre4per.github.io/tags/Express-js/"}]},{"title":"Middleware","slug":"Express/4 Middleware","date":"2022-04-12T08:35:04.000Z","updated":"2022-11-10T13:20:58.112Z","comments":true,"path":"2022/04/12/Express/4 Middleware/","link":"","permalink":"https://redre4per.github.io/2022/04/12/Express/4%20Middleware/","excerpt":"","text":"The concept of middleware Middleware refers specifically to the intermediate processing links of business processes. The calling process of Express middleware is that when a request arrives at the Express server, multiple middleware can be called continuously, so as to perform Preprocessing. Format of Express Middleware The middleware of Express is essentially a function processing function (the formal parameters are different from ordinary functions, and there is more next). In the formal parameter list of the middleware function, must contain the next parameter. And the route handler only contains req and res. The next function is the key to realize multiple middleware continuous calls, it means that the flow relationship Pass to the next middleware or route. After the business processing of the current middleware is completed, must call the next function. 1234567const express = require(&#x27;express&#x27;)const app = express()app.get(&#x27;/&#x27;, (req, res, next) =&gt; &#123; //Middleware function next();&#125;)app.listen(80, () =&gt; &#123;console.log(&#x27;server running at http://127.0.0.1&#x27;)&#125;) Define a simplest middleware function 1234const mw = function(req, res, next)&#123; console.log(&#x27;This is easist Middleware function&#x27;); next();&#125; ​ Globally effective middleware any request initiated by the client, after reaching the server, will trigger the middleware, which is called the globally effective middleware. By calling app.use(middleware function), you can define a middleware that is globally effective: 123456const mw = function(req, res, next)&#123; console.log(&#x27;This is easist Middleware function&#x27;); next();&#125;app.use(mw) //Register as globally effective middleware Other routes can be written as usual. In this way, after the server receives the request, it will call the middleware function mw first, and then continue to match the calling route. A simplified form of the global middleware (replace the function with an anonymous function): 1234app.use(function(req, res, next)&#123; console.log(&#x27;This is easist Middleware function&#x27;); next();&#125;) ​ The role of middleware in development Between multiple middleware, share the same req and res. Based on this feature, we can uniformly add custom properties or methods to the req or res object in the middleware of upstream for the downstream of is used by middleware or routing. For example, add req.a = 10 on middleware 1 and res.c = 30 on middleware 2. In this way, in the final route, the property value can be obtained by accessing req.a and res.c. For example, we want to get the time when the server received the request. If you don’t use middleware, you need to write a time acquisition function in each route. If you use middleware, you only need to get the function at the time when the middleware is written, then assign the function value to req.time , and then the route can get the value from req.time . Define multiple global middleware Multiple global middleware can be defined consecutively using app.use(). After the client request arrives at the server, will call in the order defined by the middleware. E.g: 1234567891011app.use(function(req, res, next)&#123; //The first global middleware console.log(&#x27;call 1st global middleware&#x27;); next();&#125;)app.use(function(req, res, next)&#123; //The second global middleware console.log(&#x27;call 2nd global middleware&#x27;); next();&#125;)app.get(&#x27;/user&#x27;, (req, res) =&gt; &#123; //Requesting this route will trigger the above two middleware in turn res.send(&#x27;Home page.&#x27;)&#125;) ​ Locally effective middleware Do not use the middleware defined by app.use(), which is called a locally effective middleware, such as: 12345678910const mw1 = function(req, res, next)&#123; console.log(&quot;This is middleware 1&quot;) next()&#125;app.get(&#x27;/&#x27;, mw1, function(req, res)&#123; //mw1 middleware only takes effect in the current route. That is, the middleware that takes effect locally res.send(&#x27;Home page.&#x27;)&#125;)app.get(&#x27;/user&#x27;, function(req, res)&#123; //mw1 middleware will not affect the following routes. res.send(&#x27;User page.&#x27;)&#125;) ​ Define multiple local middleware These two methods are equivalent in the code. 12app.get(&#x27;/&#x27;, mw1, mw2, function(req, res)&#123; res.send(&#x27;Home page.&#x27;) &#125;)app.get(&#x27;/&#x27;, [mw1, mw2], function(req, res)&#123; res.send(&#x27;Home page.&#x27;) &#125;) ​ Precautions Be sure to register middleware before routing. Because it is matched from top to bottom, the route will no longer match after the response. The request sent by the client can be processed by calling multiple middleware continuously. The next function must be called after the middleware is executed. If not called, the request cannot continue processing backwards. In order to prevent code logic confusion, do not write code after calling the next function. When multiple middlewares are called continuously, the req and res objects are shared among multiple middlewares.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Express.js","slug":"Back-end/Express-js","permalink":"https://redre4per.github.io/categories/Back-end/Express-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"Express.js","slug":"Express-js","permalink":"https://redre4per.github.io/tags/Express-js/"}]},{"title":"Route","slug":"Express/3 Route","date":"2022-04-10T22:25:38.000Z","updated":"2022-11-10T13:19:00.566Z","comments":true,"path":"2022/04/11/Express/3 Route/","link":"","permalink":"https://redre4per.github.io/2022/04/11/Express/3%20Route/","excerpt":"","text":"Route Concept Routing is a mapping relationship. In Express, routing refers to the mapping between client requests and server processing functions. The route in Express consists of three parts, which are request type, requested URL address, and processing function. The format is as follows: 1app.METHOD(PATH, HANDLER) For example, a simple route: 123456app.get(&#x27;/&#x27;, function(req, res)&#123; res.send(&#x27;Hello World!&#x27;)&#125;)app.post(&#x27;/&#x27;, function(req, res)&#123; res.send(&#x27;Got a POST request&#x27;)&#125;) Route matching process Whenever a request arrives at the server, needs to be matched by the route first, and only after the match is successful, the corresponding processing function will be called. When matching, it will be matched in the order of routing. If the request type and request URL match successfully at the same time, then Express will Transfer this request to the corresponding function for processing. The matching is performed according to the defined sequence. When the matching is successful, the following routes will not be matched again (that is, the preceding routes have higher priority). If the match is successful, the corresponding function will be called, and if the match is unsuccessful, the match will continue. For routes registered by methods such as app.get(), the path needs to be completely matched, and the request method must be completely matched to take effect. But app.use() is special, because express uses regular expressions to match (that is, the path of app.use() parameter 1 can be written as positive side expression, usually not necessary). In regular expressions * means match everything. and app.use() adds a * after the incoming string parameter, so as long as the path at the beginning of the incoming string is considered a successful match, it does not need to be completely match. We also use app.use(express.json()) when registering global routes, that is, the first parameter is not written. In fact, the first parameter here is * (app.use() added for the path itself), but it is omitted, and the result is that all paths can be matched. Simple usage of route The easiest way to use a route in Express is to mount the route to the app, such as: 123456const express = require(&#x27;express&#x27;)const app = express()app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; res.send(&#x27;Hello World!&#x27;) &#125;)app.post(&#x27;/&#x27;, (req, res) =&gt; &#123; res.send(&#x27;Got a POST request&#x27;) &#125;)app.listen(80, () =&gt; &#123;console.log(&#x27;server running at http://127.0.0.1&#x27;)&#125;) ​ Modularization of route In order to facilitate the modular management of routes, Express does not recommend mounting routes directly to the app, but recommends extracting routes into separate modules. Proceed as follows: Create a .js file corresponding to the routing module Call the express.Router() function to create a route instance object (in the route module file) 12const express = require(&#x27;express&#x27;)const router = express.Router() Mount the specific route to the routing instance object (in the routing module file) 12router.get(&#x27;/user/list&#x27;, (req, res) =&gt; &#123; res.send(&#x27;Get user list.&#x27;) &#125;)router.post(&#x27;/user/add&#x27;, (req, res) =&gt; &#123; res.send(&#x27;Add new user.&#x27;) &#125;) Use module.exports to share routing objects outward (in routing module file) 1module.exports=router Register the routing module with the app.use() function (in the main file) 12const userRouter = require(&#x27;./router/user.js&#x27;) //Import routing moduleapp.use(userRouter) //register route Note: The purpose of the app.use() function is to register the global middleware.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Express.js","slug":"Back-end/Express-js","permalink":"https://redre4per.github.io/categories/Back-end/Express-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"Express.js","slug":"Express-js","permalink":"https://redre4per.github.io/tags/Express-js/"}]},{"title":"MongoDB structure, terminal, CRUD","slug":"DataBase/MongoDB/2 MongoDB terminal CRUD","date":"2022-04-10T02:05:31.000Z","updated":"2022-11-12T00:00:35.666Z","comments":true,"path":"2022/04/10/DataBase/MongoDB/2 MongoDB terminal CRUD/","link":"","permalink":"https://redre4per.github.io/2022/04/10/DataBase/MongoDB/2%20MongoDB%20terminal%20CRUD/","excerpt":"","text":"Mongodb structure Databases Server: After installing mongodb, when the mongodb program is started, the databases server is started. Databases: There are multiple databases in the databases server. Collections: There are multiple collections in each database. For example, in a school system, teachers and students are separate collections. Documents: There are multiple documents in each collection, similar to json (ie object) format. For example &#123;_id: ObjectId(&#39;xxx1&#39;), name: &#39;Tom&#39;, grade: 9&#125; is a document. Fields: In the json-like format file of Document, each key is a field. There are multiple clients that can access the database mongo shell: command line program mongodb compass: graphical interface, all operations are realized by clicking, similar to the github desktop version. script: code, such as JS type of data Data types are similar to JS. Common data such as: _id: int32 (The default is ObjectId, which contains some random numbers and machine physical information to ensure non-repetition) Name: Text (string) Hobbies: array (array of string) Address: object (embeded document) Wishes: array (array of documents) Boolean Number (can be subdivided into int32 (default), int64, float) Date (ISODate (default), timestamp) Mongodb command line basic operations, add, delete, modify and check show dbs: Display database information, databases in database server. Default admin, config and local. show collections: Display all collection names in the current database. use databaseName: create a new database (when the database name does not exist), or switch to a database (when the database name exists). Add a single new collection and documents (additional): 1db.collection.insertOne() The db object refers to the currently used database, such as the school database. The collection name is to create a new collection collection (if the collection name does not exist), or use an existing collection collection in the database (if the collection name exists). insertOne() is to add document, the parameter is document (object, ie json). like: 1db.students.insertOne(&#123;&quot;name&quot;:&quot;mason&quot;&#125;) Return log information: 1234&#123; &quot;acknowledged&quot; : true, #Indicates that the server has received the request &quot;insertedId&quot; : ObjectId(&quot;6291fd3083ebd0086fc7152a&quot;) #Mongodb automatically creates an ID&#125; You can also add multiple documents at a time, that is, pass an array with multiple documents in the array: 1db.students.insertOne([&#123;&quot;name&quot;:&quot;Raymond&quot;&#125;,&#123;&quot;name&quot;:&quot;Siri&quot;&#125;]) Multiple _ids will be generated corresponding to multiple documents. Find the data in the current collection (find multiple) (check), and return the result 1db.collection.find() #such as db.students.find() 1&#123; &quot;_id&quot; : ObjectId(&quot;6291fe3f83ebd0086fc7152b&quot;), &quot;name&quot; : &quot;Derek&quot; &#125; #Return result Find data in the current collection (find one, and be the first data in the current collection) 1db.collection.findOne() Find the specified condition data, the condition is that the value of a field is xxx. Note that the key here does not have &quot; &quot; . 1db.collection.findOne(&#123;name:&quot;max&quot;&#125;) find() actually has a second parameter, which is the display condition (which fileds are displayed in the returned result). The field value to be displayed in the display condition is 1, and the default is 0. But _id defaults to impressions, i.e. the value is 1. 1db.students.find(&#123;&#125;, &#123;name:1, _id:0&#125;) Update data (change single) (change). Receive two parameters, parameter 1 is how to filter the data (find the first matching document), parameter 2 is what to update the found document. The operator operator is used when updating, which is called update operator: $set:&#123;&#125; . 1db.collection.updateOne(&#123;name:&quot;Derek&quot;&#125;,&#123;$set:&#123;&quot;name&quot;:&quot;James&quot;&#125;&#125;) It is also possible to add new fields: 1db.collection.updateOne(&#123;name:&quot;James&quot;&#125;,&#123;$set:&#123;&quot;Hobbies&quot;:[&quot;football&quot;,&quot;gaming&quot;]&#125;&#125;) Update data (change multiple) to match all eligible documents. 1db.collection.updateMany(&#123;name:&quot;James&quot;&#125;,&#123;$set:&#123;&quot;Hobbies&quot;:[&quot;football&quot;,&quot;gaming&quot;]&#125;&#125;) There is also a db.collection.replaceOne() method for complete replacement. Delete a document. Filter first, then delete the target document. The syntax is the same as search, means the key does not have &quot; &quot; . 1db.collection.deleteOne() 1db.students.deleteOne(&#123;name:&quot;Derek&quot;&#125;) Delete multiple documents. Note that deleteMany(&#123;&#125;) operation is very dangerous, which means that all documents can be matched and all documents in the current collection will be deleted. This command is not used during development. 1db.collection.deleteMany() Note that if you delete all documents in the current collection, the collection still exists; to delete the current collection, the command is db.collectionname.drop(). Information including indexes will also be deleted. Delete a document. Filter first, then delete the target document. The syntax is the same as search, means the key does not have &quot; &quot; . 1db.collection.deleteOne() 1db.students.deleteOne(&#123;name:&quot;Derek&quot;&#125;) Delete multiple documents. Note that deleteMany(&#123;&#125;) operation is very dangerous, which means that all documents can be matched and all documents in the current collection will be deleted. This command is not used during development. 1db.collection.deleteMany() Note that if you delete all documents in the current collection, the collection still exists; to delete the current collection, the command is db.collection.drop(). Information including indexes will also be deleted. MongoDB command line related tips The tab key can be filled with the collection name, that is, just write a collection name at the beginning. The logic is the same as the Node.js path. If the data brackets in the inserted document are missing (a bracket is not closed), the returned result will be ... . The solution is to type both open and closed when parentheses are entered, and then return the input content. You can also pass in an empty document: &#123;&#125; . Still unique because of the _id. You can also specify _id when adding a document, such as: 1db.students.insertOne(&#123;&quot;_id&quot;:&quot;6291fe3f83ebd0086fc7152b&quot;,&quot;name&quot;:&quot;mason&quot;&#125;) This works fine. But compared to the automatically generated id, the specified _id is not wrapped in ObjectId(), means the type is different. The _id specified by yourself is of type string, and the automatically generated _id is of type ObjectId. There will be a third-party package to help us type conversion during development, so don’t care. operator operator operator will start with $. Official Detailed Documentation update operator Update operator. $set query operator query operator. $exists, the syntax is { field: { $exists: } } . When boolean is true, $exists matches documents that contain fields, including documents whose field value is null; when boolean is false, $exists returns documents that do not contain the corresponding field. projection operator display operator (for fetching data)","categories":[{"name":"Database","slug":"Database","permalink":"https://redre4per.github.io/categories/Database/"},{"name":"MongoDB","slug":"Database/MongoDB","permalink":"https://redre4per.github.io/categories/Database/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://redre4per.github.io/tags/MongoDB/"}]},{"title":"Host static resources","slug":"Express/2 Host static resources","date":"2022-04-09T05:56:21.000Z","updated":"2022-11-12T00:01:22.298Z","comments":true,"path":"2022/04/09/Express/2 Host static resources/","link":"","permalink":"https://redre4per.github.io/2022/04/09/Express/2%20Host%20static%20resources/","excerpt":"","text":"express.static() express.static() can be very convenient to create a static resource server. It can specify a directory to be hosted as a static resource folder, and can access all files under the directory folder. For example, the images, CSS files, and JS files in the public directory can be opened to the outside world through the following code. 1app.use(express.static(&#x27;./public&#x27;)) //Write the folder path, such as ./clock. If not, write the absolute path. Once configured, you can access all files in the public directory: http://127.0.0.1/images/bg.jpg http://127.0.0.1/css/style.css http://127.0.0.1/js/login.js Note: Express looks for files in the specified static directory, and provides access paths to resources. However, the name of the directory where static files are stored (eg public) will not appear in the URL. Hosting multiple static resource directories To host multiple static resource directories, call express.static() multiple times. When accessing static resource files, the express.static() function will look for the required files according to the order in which the directories are added (for example, both folders have index.html, which is written in front. After the first folder finds the file will not look back). 12app.use(express.static(&#x27;./public&#x27;))app.use(express.static(&#x27;./files&#x27;)) Mounted path prefix If you want to mount the path prefix before the hosted static resource access path, you can use the following methods. 1app.use(&#x27;/public&#x27;, express.static(&#x27;public&#x27;)) Once configured, you can access files in the public directory through addresses with a &#x2F;public prefix: http://127.0.0.1/public/images/bg.jpg http://127.0.0.1/public/css/style.css http://127.0.0.1/public/js/login.js","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Express.js","slug":"Back-end/Express-js","permalink":"https://redre4per.github.io/categories/Back-end/Express-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"Express.js","slug":"Express-js","permalink":"https://redre4per.github.io/tags/Express-js/"}]},{"title":"npm and package","slug":"Express/1 Express basics","date":"2022-04-08T09:04:42.000Z","updated":"2022-11-12T00:54:44.859Z","comments":true,"path":"2022/04/08/Express/1 Express basics/","link":"","permalink":"https://redre4per.github.io/2022/04/08/Express/1%20Express%20basics/","excerpt":"","text":"Introduction to Express Express is a fast, open and minimal web development framework based on the Node.js platform. Express is similar to the built-in http module of Node.js, and is specially used to create web servers. The essence of Express: it is a third-party package on npm that provides a convenient way to quickly create a web server. If you don’t use Express, you need to use the native http module. But the http built-in module is very complicated to use, and the development efficiency is low; Express is further encapsulated based on the built-in http module, which can greatly improve the development efficiency (similar to the relationship between Web API and jQuery). What Express can do For front-end programmers, two common servers are: Web site server: a server dedicated to providing external Web page resources. API interface server: a server dedicated to providing API interfaces to the outside world. Express can create both types of servers quickly and easily. Install Express Terminal command: npm i express@4.17.1 Create a web server 123456const express = require(&#x27;express&#x27;)const app = express()app.listen(80, () =&gt; &#123; console.log(&#x27;express server running at http://127.0.0.1&#x27;)&#125;) ​ Listening for GET&#x2F;POST requests Through the app.get() app.post() methods, you can listen to the client’s GET request. 12app.get(&#x27;Request URL&#x27;, function(req, res)&#123;&#125;)app.post(&#x27;Request URL&#x27;, function(req, res)&#123;&#125;) ​ Respond content to client The res.send() method can send the processed content to the client. (res.send() default status code is 200) 123456app.get(&#x27;/user&#x27;, (req, res) =&gt; &#123; res.send(&#123;name:&#x27;zs&#x27;, age:20, gender:&#x27;male&#x27;&#125;)&#125;)app.post(&#x27;/user&#x27;, (req, res) =&gt; &#123; res.send(&#x27;request succeed&#x27;)&#125;) res.json() method is the same as res.send() method. The difference is that res.send() has a check to check if the incoming object is in string or json format or something else. If it is a json object, it will be returned in json format. This is equivalent to res.send() with the res.json() method built-in. Writing the res.json() method is equivalent to being more explicit, making sure to transfer the object back in json format. When writing, generally choose the res.json() method. If you want to return only the response status code, you can use res.sendStatus(), such as: 1res.sendStatus(204) Just set the status code without returning: 1res.status(201) //will return a response object 1res.status(201).json(&#123;&#125;) //Return the corresponding data at the same time ​ Return question The return in app.get(&#39;/&#39;, (req, res) =&gt; &#123; return &#125;) is a matter of personal code style. In most cases, adding or not adding return is the same. But there is a situation where return must be added, that is, if logic judgments such as if are involved in the callback function to generate branches. In branches, return must be added to each branch to ensure that the code in other branches that follow will not be executed. In addition, the following two return methods are also different: 12res.send(&#x27;Hello world&#x27;);return; 1return res.send(&#x27;Hello world&#x27;); From the results of running the code, there is no difference between the two writing methods. But if TS type checking is involved, it will result in different types being returned: the first writing method returns undefined, and the second returns the respond type. How to get data from req body fetch data req.body can retrieve the data in the request body sent by the client. Used for POST, PUT, PATCH requests. 12const &#123;name&#125; = req.body;res.send(&#123;name&#125;) //This is ES6 abbreviation, it should be res.send(&#123;name: name&#125;) query param to get data req.query can retrieve the parameters sent by the client to the server from the URL in the form of query string. Defaults to an empty object, used for GET requests. 12345app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; //The client uses ?name=tom&amp;age=20 to send parameters in the form of query strings console.log(req.query.name) //Can be accessed with the properties in req.query console.log(req.query.age) res.send(req.query)&#125;) route param (/:id ) to get data (get dynamic parameters in the URL) The req.params object can be accessed in the URL through the dynamic parameters matched by : . The string after : can be written arbitrarily, as long as it is reasonable and legal, and the final result returned by the req.params object is &#123;&quot;:the latter string&quot;:&quot;dynamic parameters requested by the client&quot;&#125; . For example /my/article/:id , where id is not a static value, but a dynamic parameter (dynamically matched parameter value). req.params defaults to an empty object. route param can be used for GET, POST, PUT, DELETE four operations, but in most cases it is id. 1234app.get(&#x27;/user/:id&#x27;, (req, res) =&gt; &#123; //The client request is http://127.0.0.1/1, and the id is 1. console.log(req.params) res.send(req.params) //The returned result is &#123;&quot;id&quot;:&quot;1&quot;&#125;&#125;) There can also be multiple dynamic parameters, such as 1app.get(&#x27;/user/:id/:name&#x27;, (req, res) =&gt; &#123;&#125; Server-side requests should be http://127.0.0.1/1/Tom .","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Express.js","slug":"Back-end/Express-js","permalink":"https://redre4per.github.io/categories/Back-end/Express-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"Express.js","slug":"Express-js","permalink":"https://redre4per.github.io/tags/Express-js/"}]},{"title":"Introduction to MongoDB","slug":"DataBase/MongoDB/1 MongoDB basic","date":"2022-04-08T05:03:11.000Z","updated":"2022-11-12T00:00:36.866Z","comments":true,"path":"2022/04/08/DataBase/MongoDB/1 MongoDB basic/","link":"","permalink":"https://redre4per.github.io/2022/04/08/DataBase/MongoDB/1%20MongoDB%20basic/","excerpt":"","text":"Install You need to download the package. After decompression and installation, you need to create a \\data\\db file in the root directory of the C drive to store the data: cd C:\\md &quot;\\data\\db&quot; . The way to start Mongodb is to enter the command line in the folder C:\\Program Files\\MongoDB\\Server\\5.0\\ bin, and then enter the command: 1mongod --dbpath c:\\data\\db After the server starts, you can find Listening on address: 127.0.0.1, port: 27017 (default port number) in the pop-up information. At this point, enter the following command to connect to the database. The interface at this time is the mongo shell, which is based on the JS engine. The cls command clears the screen. 1C:\\mongodb\\bin\\mongo.exe Another startup method is the configuration file, which is used during deployment. SQL and non-SQL Another understanding of non-SQL (or no SQL) is not only SQL. It can not only do the functions of relational databases, but also functions that relational databases cannot. There are four main categories of non-SQL: document-oriented: data is stored in the form of documents, such as mongodb, dynamodb, firebase key-value: cache database, such as redis graph-oriented: a database (graph theory) based on graphs, such as neo4j column-family: for big data, such as cassandra Mongodb introduction Mongo comes from humongous (huge) and is used to process huge data. Documents are stored in a json-like (key-value pair) form, which is strictly called BSON (binary JSON). It has some types that json does not support, such as _id: ObjectId(&#39;xxx&#39;) does not exist in json, it is a type created by mongodb. 1234&#123; _id: ObjectId(&#x27;xxx&#x27;), //A unique identifier used to represent data. name: &#x27;yyy&#x27;&#125; Flexibility or schemaless Schema is the design diagram of the data, which defines which properties and fields the data has. Schema is not a strictly prescribed design diagram, so data can be stored without schema. For example, collection (collection, corresponding to table in sql), contains multiple data of the same type (document), but there is no hard requirement, and the data can also be of different types. The only thing to make sure is that the _id (data identifier) cannot be repeated, like: 1234567891011121314[ &#123; _id: ObjectId(&#x27;xxx1&#x27;), name: &#x27;yyy&#x27;&#125;, &#123; _id: ObjectId(&#x27;xxx2&#x27;), name: &#x27;yyy&#x27;&#125;, &#123; _id: ObjectId(&#x27;xxx3&#x27;), username: &#x27;yyy&#x27; //Different data types can also be received.&#125;] However, we will avoid doing this during development, and still ensure that the data has a fixed structure for easy traversal.","categories":[{"name":"Database","slug":"Database","permalink":"https://redre4per.github.io/categories/Database/"},{"name":"MongoDB","slug":"Database/MongoDB","permalink":"https://redre4per.github.io/categories/Database/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://redre4per.github.io/tags/MongoDB/"}]},{"title":"Publish package","slug":"NodeJS/14 publish package","date":"2022-04-06T12:58:51.000Z","updated":"2022-11-10T12:39:34.930Z","comments":true,"path":"2022/04/06/NodeJS/14 publish package/","link":"","permalink":"https://redre4per.github.io/2022/04/06/NodeJS/14%20publish%20package/","excerpt":"","text":"Initialize the basic structure of the package The folder my-package of the new key package, as the root directory of the package In the my-package folder, new key the following three files: package.json package management configuration file The entry file of the index.js package README.md package description file Initialize package.json 123456789&#123; &#x27;name&#x27;:&#x27;my-package&#x27;, //name attribute and package folder name can be different. But the package name is ultimately determined by the name attribute. //The package name is unique. You should go to npm to retrieve the package name before naming it. &#x27;version&#x27;:&#x27;1.0.0&#x27;, //Default initial version number &#x27;main&#x27;:&#x27;index.js&#x27;, //When the outside world imports a folder through require(), it will be automatically searched through the main attribute &#x27;description&#x27;:&#x27;Time and HTMLEscape formatting function&#x27;, //Users can see it in npm search &#x27;keywords&#x27;:[&#x27;my-package&#x27;, &#x27;dateFormat&#x27;, &#x27;escape&#x27;], //Search keywords &#x27;license&#x27;:&#x27;ISC&#x27; //Open source protocol, the default ISC protocol.&#125; ​ Develop features in your own package: escape HTML, restore HTML Used to escape user input. If the user input has html related characters, it will cause a display error. 12345678910function htmlEscape(htmlStr)&#123; return htmlStr.replace(/&lt;|&gt;|*|&amp;/g, (match) =&gt; &#123; //Regular, g is a global match switch(match)&#123; case &#x27;&lt;&#x27;: return &#x27;&amp;lt;&#x27; case &#x27;&gt;&#x27;: return &#x27;&amp;gt;&#x27; case &#x27;*&#x27;: return &#x27;&amp;quot;&#x27; case &#x27;&amp;&#x27;: return &#x27;&amp;amp;&#x27; &#125; &#125;)&#125; 12345678910function htmlUnescape(str)&#123; return htmlStr.replace(/&amp;lt;|&amp;gt;|&amp;quot;|&amp;amp;/g, (match) =&gt; &#123; switch(match)&#123; case &#x27;&amp;lt;&#x27;: return &#x27;&lt;&#x27; case &#x27;&amp;gt;&#x27;: return &#x27;&gt;&#x27; case &#x27;&amp;quot;&#x27;: return &#x27;*&#x27; case &#x27;&amp;amp;&#x27;: return &#x27;&amp;&#x27; &#125; &#125;)&#125; There is also a formatted time function in the example, which is very simple not to record. Function modular split in the package Split the corresponding functions into src -&gt; function1.js. For example, split the function of formatting time into src-&gt;dataFormat.js, and split the function of processing HTML strings into src-&gt;htmlEscape.js. In index.js, import two modules to get the methods that need to be shared externally. In index.js, use module.exports to share the corresponding method. Because some modules have multiple functions, the spread operator ...function1 should be used directly to expose them all (even if there is only one function in the module). Write a README document Written in markdown format. There is no mandatory requirement for the content, as long as the description of the function, usage, and precautions of the clear package can be written. For example, the README document includes: Installation method Import method Format time function Escape HTML function Restore HTML function Open Source Protocol When writing, you can paste the code, start with a newline ```js, and end with ``` after a newline. The title should start with ##. Open Source Protocol ISC. Release Package Register an npm account (on the npm official website) Log in to your npm account (in the terminal) and execute npm login . Fill in the account password and email according to the prompts. Note that before running the command, you must first switch the download server address to the official server of npm (the official server in AU), otherwise it will cause the release of the package to fail. Run the npm publish command (move to the root directory of the package to publish, no need to write the package name in the command) to publish the package to npm. Package names must not be repeated. Log in to npm and click on yourself -&gt; package to view the package. Remove published package Run the npm unpublish package name --force command to delete it. But note: The npm unpublished command can only delete packages published within 72 hours. After exceeding it can never be deleted. Packages deleted by npm unpublished cannot be published repeatedly within 24 hours. Be careful when publishing packages, try not to publish meaningless packages on npm.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"npm","slug":"npm","permalink":"https://redre4per.github.io/tags/npm/"}]},{"title":"Package structure","slug":"NodeJS/13 package structure","date":"2022-04-06T05:12:37.000Z","updated":"2022-11-10T12:38:17.345Z","comments":true,"path":"2022/04/06/NodeJS/13 package structure/","link":"","permalink":"https://redre4per.github.io/2022/04/06/NodeJS/13%20package%20structure/","excerpt":"","text":"Classification of packages Project package: The packages installed in the node_modules directory of the project are all project packages. Project packages can also be subdivided into two categories: Development dependency packages: The packages recorded in the devDependencies node will only be used during development. Core dependency package: The package recorded in the dependencies node will be used during development and after the project is launched. Global package: When executing the npm install command, if the -g parameter is provided, the package will be installed as a global package. Global packages are installed by default in the C:\\Users\\User Directory\\AppDate\\roaming\\npm\\node_modules directory. Installation command: npm i package name -g; uninstall command: npm uninstall package name -g Only tool-like packages are necessary for global installation because they provide useful terminal commands. To determine whether a package needs to be installed globally before it can be used, you can refer to the official instructions for use. i5ting_toc i5ting_toc is a small tool that can convert md documents into html pages, using steps: 12npm install -g i5ting_toci5ting_toc -f path to md file to convert -o Canonical package structure A standard package, the composition structure must meet 3 requirements: Packages must exist as separate directories The package management configuration file package.json must be included in the top-level directory of the package Package.json must contain three properties: name (package name), version (version number) and main (package entry). When the outside world imports a package through require(), it imports the file pointed to by the main attribute.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"npm","slug":"npm","permalink":"https://redre4per.github.io/tags/npm/"}]},{"title":"npm and package","slug":"NodeJS/12 npm and package","date":"2022-04-04T11:06:37.000Z","updated":"2022-11-10T12:37:42.309Z","comments":true,"path":"2022/04/04/NodeJS/12 npm and package/","link":"","permalink":"https://redre4per.github.io/2022/04/04/NodeJS/12%20npm%20and%20package/","excerpt":"","text":"Package Third-party modules in Node.js are also called packages (just by a different name). Packages are encapsulated based on built-in modules, providing a more advanced and convenient API, which greatly improves development efficiency. Source of packages: Packages are developed by third-party individuals or teams and are free for everyone to use. Packages in Node.js are free and open source. The download site for packages is npm, which is the largest package sharing platform in the world. The server address of npm is http://registry.npmjs.org/ , which cannot be opened directly but can be downloaded using tools. The name of this package management tool is Node Package Manager, or npm package management tool for short. This package management tool is installed on the user’s computer along with the Node.js installation package. You can run the npm -v command in the terminal to check the version number. Install the package in the project npm install the full name of the package: Install the package (latest version) in the project. When executed, the package name and version number will be recorded in package.json. npm i package full name : Installed package, shorthand. For the usage of the package, you can go to npmjs to search for the package name and find Documentation, which is the documentation. If you want to find a package, generally do not search directly on npm, but Google search package name + npm. After finding it, click in to see if the README is detailed, which represents the user’s experience. Then go to the code repository on GitHub to see how many stars (&lt;1000 means not popular), and issues. Looking at issues can see whether developers reply and provide solutions, which is very important for niche packages. Also look at Pull requests to see when was the last merge. An active package may have a merge every one or two months. If it has not been updated for a long time (and there is no special statement in the README), it means it is not active. Try not to select this package. In addition, it is best to create a new project and try the package before installing the package to verify the results. @ symbol: install the specified version of the package. For example npm i moment@2.22.2 . If you have already installed other versions of the package and want to reinstall it, you do not need to uninstall the original version package, but directly execute the new command. Semantic version specification for packages: the first digit is the major version, the second digit is the feature version, and the third digit is the bugfix version. The rule of version number promotion is that as long as the previous version number increases, the latter version number will be zeroed. After initial packaging: node_modules and package-lock.json After the first package, there is an additional folder called node_modules and a configuration file of package-lock.json under the project folder. node_modules folder is used to store all packages that have been installed into the project. When require() imports a third-party package, it looks for and loads the package from this directory. package-lock.json configuration file is used to record the download information of each package in the node_modules directory, such as package Name, version number, download address. This file can record the version number of each package when you install the package (such as installing express), and lock it. Reinstalling the package in the future, and the package-lock.json file exists, will be installed according to the version in package-lock.json. Note: Do not manually modify any code in node_modules and package-lock.json, the npm package management tool will automatically maintain it. If you want to manually change the version, just use @ to follow the corresponding version package. If the package-lock.json file is deleted, the original file cannot be restored. You can only use npm install to regenerate the package-lock.json of the current package version. Package management configuration file: package.json npm stipulates that in the project root directory, a package management configuration file called package.json must be provided to record configuration information related to the project: Project’s name, version number, description, etc. Which packages are used in the project which packages will only be used during development Which packages are needed for development and deployment The problem of multi-person collaboration The third-party package is too large. For example, the entire project volume is 30.4M, the third-party package is 28.8M, and the project source code volume is 1.6M. This makes it difficult to share project source code among team members. Solution: We only upload the source code (1.6M) when we share, and remove node-modules (the removal method is to write node_modules&#x2F; in the .gitIgnore file), others from the Internet Download third-party packages. But how do we let others know which third-party packages we use? Record the packages in the project: The package.json configuration file is used to record which packages are installed by the project. After removing node-modules in this way, the project source code can be shared among team members. Note: During project development, be sure to add the node_modules folder to the .gitignore ignore file. Quickly create package.json npm init -y Create a new package.json file in the directory where the command is executed. After creating a new project folder, the first thing to do is to execute this command first, and it only needs to be executed once during project development. Note that the above command can only be successfully run in the English directory, so Chinese and spaces should not appear in the project folder. npm install full name of package The package name and version number will be recorded in package.json when the installation command is executed. Without npm init, there is no package.json file, but there are still node-modules and package-lock.json files. This results in failure to log installed packages. package.json and package-lock.json If there is no package-lock.json, npm will install according to the package version in package.json; if there is package-lock.json, it will be installed according to the version of package-lock.json. Package-lock.json file change problem After manual modification of package-lock.json, if a new package is installed without saving, it will cause an error to be reported because it cannot be saved. The solution is to simply close the file window (without saving it) and reopen it. The new package installed after opening will exist, and manual changes will be rolled back, just rewrite. Another solution is to force-save (with the current version) and reinstall the new package. dependencies node The dependencies node is created in the package.json file after running the npm install package_full_name command. It is used to record which packages are installed using the npm install package_full_name command. Install all packages at once When we get a project with node_modules removed, we need to download all the packages to the project before we can run the project, otherwise the following error will be reported: 1Error: Cannot find module &#x27;moment&#x27; You can run npm install (shortened to npm i) to install all dependencies at once. Uninstall package, update package npm uninstall package full name This command can uninstall the specified package. There is no shorthand for this command. After successful uninstallation with this command, the uninstalled package will be removed from dependencies in package.json. npm outdated can count the version of the package you use and the latest version of the package. Not commonly used, you can look at it before updating. npm update updates the package based on the Wanted version. uncommonly used. devDependencies node If some packages are only used during the development phase of the project and will not be used after the project is launched, it is recommended to record these packages in the devDependencies node. Correspondingly, if some packages need to be used after development and project launch, it is recommended to record these packages in the dependencies node. The npm install packagename --save-dev command can log packages to the devDependencies node. is abbreviated as npm i package name -D . npx Packages that previously needed to be installed globally, such as nodemon and creat-react-app, need to be installed globally: npm -i -g package_name . But many times we don’t want the package to be installed globally, you can use npx instead. npx will follow the package, then cache it, and delete it after a period of time. This way the package will not be resident in the computer. (nor in package.json) Benefit: No need to occupy memory space, and no need to manually update, always the latest version. Global installation and computer replacement problems Global installation is generally used when you want to use the package from the command line. Global installation will not be recorded in the dependency, so it cannot be installed automatically when changing computers. Global installs are best replaced with npx. Script usage in npm scripts is an object in package.json. Equivalent to a shortcut, that is, to create a new name for the command line command. 123&quot;script&quot;: &#123; &quot;start&quot;: &quot;nodemon index.js&quot; //&quot;short name&quot;: &quot;long command&quot;&#125;, To run a custom command line command, the standard format is npm run custom command.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"npm","slug":"npm","permalink":"https://redre4per.github.io/tags/npm/"}]},{"title":"Loading mechanism of module","slug":"NodeJS/11 Loading mechanism of module","date":"2022-04-02T12:36:57.000Z","updated":"2022-11-10T11:36:00.215Z","comments":true,"path":"2022/04/02/NodeJS/11 Loading mechanism of module/","link":"","permalink":"https://redre4per.github.io/2022/04/02/NodeJS/11%20Loading%20mechanism%20of%20module/","excerpt":"","text":"Prioritize loading from cache Modules are cached after the first load. This means that multiple calls to require() will not cause the module’s code to be executed multiple times. Whether it is a built-in module, a user-defined module, or a third-party module, they will be loaded from the cache first, thereby improving the loading efficiency of the module. Loading mechanism of built-in modules Built-in modules are modules officially provided by Node.js, and built-in modules have the highest loading priority. For example, if a third-party module and a built-in module have duplicate module names, require(&#39;module name&#39;) always returns the built-in module, even if there is a third-party module package with the same name in the node_modules directory. Custom module loading mechanism When loading a custom module with require(), you must specify a path identifier starting with ./ or ../. When loading a custom module, if no path identifier is specified, node will load it as a built-in module or a third-party module, resulting in a failure to load. Also, when importing a custom module using require(), if the file extension is omitted, Node.js will in order to try to load the following files separately: Load by exact filename Completing .js extension loading Completing .json extension loading Completing .node extension loading Failed to load, the terminal reports an error Loading mechanism of third-party modules If the module identifier passed to require() is not a built-in module and does not start with ./ or ../, Node.js will start from the current module’s parent directory, trying to start from the &#x2F;node_modules file folder to load third-party modules. If the corresponding third-party module is not found, it will be moved to the next parent directory and loaded until the root directory of the file system. Directories as modules When passing a directory as a module identifier to require() for loading, there are three loading methods: Find a file called package.json in the loaded directory, and look for the main property, which serves as the entry for require() loading. If there is no package.json file in the directory, or the main entry does not exist or cannot be resolved, Node.js will try to load the index.js file in the directory. If the above two steps fail, Node.js will report an error: Error: Cannot find module &#39;xxx&#39; .","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"}]},{"title":"Share members in module","slug":"NodeJS/10 Share member in module","date":"2022-04-02T08:07:47.000Z","updated":"2022-11-10T11:36:26.699Z","comments":true,"path":"2022/04/02/NodeJS/10 Share member in module/","link":"","permalink":"https://redre4per.github.io/2022/04/02/NodeJS/10%20Share%20member%20in%20module/","excerpt":"","text":"module object In each .js custom module there is a module object, which stores information about the current module. After printing there is: 1234567891011121314151617Module &#123; id: &#x27;.&#x27;, path: &#x27;D:\\\\Front-end\\\\Nodejs&#x27;, exports: &#123;&#125;, #Important attributes, members can be shared externally through exports, the default value is an empty object. filename: &#x27;D:\\\\Front-end\\\\Nodejs\\\\prac1.js&#x27;, loaded: false, children: [ Module &#123; id: &#x27;D:\\\\Front-end\\\\Nodejs\\\\prac1a.js&#x27;, ... #here omitted &#125;], paths: [ &#x27;D:\\\\Front-end\\\\Nodejs\\\\node_modules&#x27;, &#x27;D:\\\\Front-end\\\\node_modules&#x27;, &#x27;D:\\\\node_modules&#x27; ]&#125; module.exports object In a custom module, you can use the module.exports object to share the members of the module for external use. The default value is &#123;&#125;. Outside When importing a custom module with the require() method, what you get is the object pointed to by module.exports. If the custom module does not export any objects, the result of printing require(&#39;./js1&#39;) from the outside world is &#123;&#125;, which is the default value of exports. Ways to share members: 1234module.exports.username = &#x27;Derek&#x27; //Mount properties to the module.exports objectmodule.exports.sayHello = function()&#123; //mounting method console.log(&#x27;Hello!&#x27;)&#125; Note that the shared members here exist as attributes of module.exports. If you define a variable&#x2F;function first, and then share the variable&#x2F;function name, it cannot be shared. Note: When using the require() method to import a module, the result of the import is always based on the object pointed to by module.exports. That is to say, if you define some properties of module.exports first, and then assign a new object to module.exports, the result of the export is a new object (because the new object is new address); whereas if you first assign a new object to module.exports and then add some properties, it will export the new object with the added properties. exports object Since module.exports is complicated to write, in order to simplify the code, Node.js provides the exports object. By default, exports and module.exports point to the same object. The default final shared result is still based on the object pointed to by module.exports. Mistakes in using module.exports and exports: When you use .attribute = to attach objects, the two are common; but when you use .exports = &#123;&#125; to directly assign objects, exports are created by yourself, which is directly related to module.exports The given objects are not the same. If you use .exports = &#123;&#125; to directly assign the object, and then want to use module.exports.attribute = to add attributes, then you should use module.exports = exports to point to exports The object is assigned to module.exports. To prevent confusion, it is recommended not to use both module.exports and exports in the same module.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"}]},{"title":"Modularization","slug":"NodeJS/09 Modularization","date":"2022-03-31T14:29:34.000Z","updated":"2022-11-10T11:36:17.812Z","comments":true,"path":"2022/04/01/NodeJS/09 Modularization/","link":"","permalink":"https://redre4per.github.io/2022/04/01/NodeJS/09%20Modularization/","excerpt":"","text":"Modular Concept Modularization refers to the process of dividing the system into several modules layer by layer from top to bottom when solving a complex problem. For the entire system, modules are units that can be combined, disassembled and replaced. In programming, modularization is complying with fixed rules, splitting a large file into multiple small modules that are independent and interdependent. The benefits of code modular splitting are: Improve code reusability Improve the maintainability of the code On-demand loading can be achieved modularity specification is the rules that need to be followed when the code is modularized and combined. For example, what syntax is used to reference the module, and what syntax is used in the module exposed members. Classification of modules in Node.js Node.js divides modules into three categories according to their different sources: Built-in modules (built-in modules are officially provided by Node.js, such as fs, path, http, etc.) Custom module (every .js file created by the user is a custom module. A relative path needs to be added when loading) Third-party modules (unofficial, need to be downloaded before use) Load Module The three modules above can be loaded using the require() method. Using the require() method will execute the code in the loaded module. 123const fs = require(&#x27;fs&#x27;) //direct loadingconst custom = require(&#x27;./custom.js&#x27;) //different from loading other modules, custom modules need to write relative pathsconst moment = require(&#x27;moment&#x27;) //Unlike built-in modules, third-party modules need to be downloaded in advance Note that the .js suffix can be omitted when loading custom modules using the require() method. Module scope in Node.js Similar to the function scope, members such as variables, methods defined in a custom module can only be accessed within the current module. This module-level access restriction is called a module scope. 123456//js1const username = &#x27;Derek&#x27;function sayHello()&#123; console.log(&#x27;Hello, I am &#x27; + username)&#125;sayHello() 12const js1 = require(&#x27;./js1&#x27;)console.log(js1) //In this case, Derek can be accessed normally, because functions and variables are in the same file. But note here that if sayHello() is written in the second file instead of js1, then an error sayHello() will be reported as undefined. The benefit of module scope is to prevent global variable pollution. The introduction of .js files in native JS does not have this mechanism, that is, variables in the imported files can be directly accessed (not accessible in strict mode). Modular Specifications in Node.js Node.js follows the CommonJS modularity specification. CommonJS specifies the characteristics of modules and how modules depend on each other: Inside each module, the module variable represents the current module. The module variable is an object whose exports property (ie module.exports) is the external interface. Loading a module is actually loading the module.exports attribute of the module. The require() method is used to load modules.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"}]},{"title":"Http module","slug":"NodeJS/08 Http module","date":"2022-03-31T10:36:05.000Z","updated":"2022-11-10T10:50:45.093Z","comments":true,"path":"2022/03/31/NodeJS/08 Http module/","link":"","permalink":"https://redre4per.github.io/2022/03/31/NodeJS/08%20Http%20module/","excerpt":"","text":"http module The http module is officially provided by Node.js and is used to create a web server module. Through the http.createServer() method, you can easily turn an ordinary computer into a Web server to provide Web resource services to the outside world. The difference between a server and an ordinary computer is that web server software such as IIS and Apache are installed on the server. In Node.js, we don’t need to use third-party web server software like IIS and Apache. Because you can use the http module to write server software and provide web services to the outside world. import http module 1const http = require(&#x27;http&#x27;) ​ Server related concepts IP address: It can be obtained by ping the domain name in the terminal. Enter 127.0.0.1 in the browser to access your computer as a server. Domain name and domain name server: The domain name (Domain Name) is a string corresponding to the IP address one-to-one, and this correspondence is stored in the domain name server (DNS, Domain name server). Port number: There may be multiple web services in one computer, each web service corresponds to a unique port number. The client’s network request will be handed over to the corresponding web service through the port number for processing. In practice, port 80 in url can be omitted. ​ Create web server step Import the http module 1const http = require(&#x27;http&#x27;) Create a web server instance You can quickly create a web server instance by calling the http.createServer() method. 1const server = http.createServer() Bind the request event to the server to monitor client requests. Bind the request event to the server using the .on() method of the server instance. Whenever a client sends a request to the server, the request event is fired and the event handler is called. 123server.on(&#x27;request&#x27;, (req,res)=&gt;&#123; console.log(&#x27;client visit our web server.&#x27;)&#125;) Start the server The current web server instance can be started by calling the .listen() method of the server instance. The first parameter is the port number, and parameter 2 (callback function) will be called after the startup is successful. 123server.listen(80, ()=&gt;&#123; console.log(&#x27;http server running at http://127.0.0.1&#x27;)&#125;) Stop the server with CTRL+C. Same as scaffolding. After the server modifies the code, the server must be restarted for the code to take effect. ​ req request object As long as the server receives the client’s request, it will call the server.on() bound request event handler for the server. If you want to access client-related data or properties in the event handler, you can use the req request object: req.url : The url address requested by the client (not the client address, but the target address you want to request. The address is not the complete address, but starts from the part after the port number.) req.method : the client’s method request type (GET, POST, etc.) res response object In the server’s request event handler, If you want to access server-related data or properties, you can use the res response object. For example, after the client accesses the server, if it wants to display the server content on the client’s web page, it needs to use the res response object. The res response object is the second parameter in the callback function. If you want to use res instead of req, you also need to complete req. The res.end() parameter is a string, which is sent to the client. Solve the problem of Chinese garbled characters When calling the res.end() method to send Chinese content to the client, there will be garbled characters. At this time, you need to manually set the encoding format. 1res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;) Both parameters are fixed notation. Respond to different content according to different urls step: Get the url address of the request Set the default corresponding content to 404 Not found Determine whether the user request is / or /index.html home page Determine whether the user request is the /about.html page (If Chinese is involved,) set the Content-Type response header to prevent Chinese garbled characters Response content to client using res.end() Code: 123456789101112131415161718const http = require(&#x27;http&#x27;)const server = http.createServer()server.on(&#x27;request&#x27;, function(req, res)&#123; const url = req.url let content = &#x27;&lt;h1&gt; 404 Not Found! &lt;/h1&gt;&#x27; if (url === &#x27;/&#x27; || url === &#x27;/index.html&#x27;)&#123; content = &#x27;&lt;h1&gt; main page &lt;h1&gt;&#x27; &#125;else if (url === &#x27;/about.html&#x27;)&#123; content = &#x27;&lt;h1&gt; about page &lt;h1&gt;&#x27; &#125; res.setHeader(&#x27;Content-type&#x27;, &#x27;text/html; charset=utf-8&#x27;) res.end(content)&#125;)server.listen(80, ()=&gt;&#123; console.log(&#x27;server running at http://127.0.0.1&#x27;)&#125;)","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"}]},{"title":"Split file example, Regex","slug":"NodeJS/07 Divide file example, Regex","date":"2022-03-30T22:52:54.000Z","updated":"2022-11-10T10:48:42.620Z","comments":true,"path":"2022/03/31/NodeJS/07 Divide file example, Regex/","link":"","permalink":"https://redre4per.github.io/2022/03/31/NodeJS/07%20Divide%20file%20example,%20Regex/","excerpt":"","text":"Case Requirements The file that needs to be split is an index.html file with HTML, style, and JS code mixed together. The requirement is to split this mixed file into three files, index.html, index.css, and index.js, and put these three files in the same clock folder. Case steps Import the required fs and path modules and create regular expressions. Regular expressions are used to split &lt;style&gt; and &lt;script&gt; code in mixed files. 12const regStyle = /&lt;style&gt;[\\s\\S]*&lt;\\/style&gt;/const regScript = /&lt;script&gt;[\\s\\S]*&lt;\\/script&gt;/ Note here that [\\s\\S] matches everything. \\s matches all whitespace, including newlines, \\S is not whitespace, excluding newlines. &lt;\\/style&gt; is to avoid the effect of escape characters. Use the fs module to read the html mixed file that needs to be processed. Customize the method of splitting css code 123456789function resolveCSS(htmlStr)&#123; const r1 = regStyle.exec(htmlStr) //Extract the style tag and the code in the tag in the mixed page string const newCSS = r1[0].replace(&#x27;&lt;style&gt;&#x27;, &#x27;&#x27;).replace(&#x27;&lt;/style&gt;&#x27;, &#x27;&#x27;) //Remove tags fs.writeFile(path.join(__dirname, &#x27;./clock/index.css&#x27;), newCSS, err=&gt;&#123; if(err) return console.log(err.message) console.log(&#x27;write in CSS style succeed!&#x27;) &#125;)&#125; The exec() method is used to retrieve a match of a regular expression in a string. The parameter is a string, and an array is returned, which stores the matching results. If no match is found, the return value is null. The 0th element of this array is the text that matches the regular expression. The 1st element is the text (if any) that matches the 1st subexpression of the RegExpObject, and the 2nd element is the text that matches the 2nd subexpression of the RegExpObject ( if any), and so on. RegExpObject has multiple subterms because it can be written in the form const regex1 = RegExp(&#39;foo*&#39;, &#39;g&#39;). Customize the method of splitting JS code (same as above) Customize the method of splitting html code 12345678910function resolveHTML(htmlStr)&#123; const newHTML = htmlStr .replace(regStyle, &#x27;&lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;/&gt;&#x27;) .replace(regScript, &#x27;&lt;link src=&quot;./index.js&quot;&gt;&lt;/script&gt;&#x27;) fs.writeFile(path.join(__dirname, &#x27;./clock/index.html&#x27;), newHTML, err=&gt;&#123; if(err) return console.log(err.message) console.log(&#x27;write in HTML page succeed!&#x27;) &#125;)&#125; ​ Precautions fs.writeFile() can only be used to create a file, not a path. That is to say, the case is to manually create the clock folder first. If it is not created, writing to the file will fail. Repeatedly calling fs.writeFile() to write to the same file, the newly written content will overwrite the previous old content.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"}]},{"title":"Path route module","slug":"NodeJS/06 Path route module","date":"2022-03-29T01:16:59.000Z","updated":"2022-11-10T10:47:22.665Z","comments":true,"path":"2022/03/29/NodeJS/06 Path route module/","link":"","permalink":"https://redre4per.github.io/2022/03/29/NodeJS/06%20Path%20route%20module/","excerpt":"","text":"path path module The path module is officially provided by Node.js and is used to process paths. It has methods for dealing with paths, such as path.join() to join paths, path.basename() to parse filenames, etc. import path module 1const path = require(&#x27;path&#x27;) Path splicing: path.join() The path.join() method can join multiple path fragments into a complete path string. 1path.join([...paths]) The parameter …paths is of type string and is a sequence of path fragments. The return value is the assembled path string. But in path fragments, be aware that ../ will cause the previous layer of the path to be canceled. Whereas ./ does not negate the previous path. If you need to offset the upper two layers of paths, you should use ../../ . 12const pathStr = path.join(&#x27;/a&#x27;, &#x27;/b/c&#x27;, &#x27;../&#x27;, &#x27;./d&#x27;, &#x27;e&#x27;) //result is \\a\\b\\d\\econst pathStr2 = path.join(__dirname, &#x27;./files/1.txt&#x27;) //The complete absolute path can be spliced out. In the future, operations involving path splicing should be handled with the path.join() method, and do not use + for string splicing. The reason is that if you thank a . such as ./ , the path will be wrong after splicing with a plus sign. But path.join() will take care of the extra . . 1fs.readFile(path.join(__dirname, &#x27;/files/1.txt&#x27;), &#x27;utf8&#x27;, function()&#123;&#125;) Get the filename in the path: path.basename() The path.basename() method can get the last part of the path, which is usually used to get the filename in the path. 1path.basename(path[, ext]) Parameter 1: required parameter, path string. Parameter 2: Optional parameter, indicating the file extension. If the second parameter is not passed in, the returned result is the file name with the extension, such as index.html. Add the second parameter passed in, such as &#39;.html&#39;, and the returned result is the file name without extension, such as index. 12path.basename(filePath1) //The result is index.htmlpath.basename(filePath1, &#x27;.html&#x27;) //The result is index Get the file extension in the path: path.extname() The path.extname() method can get the extension part of the path. The return value is an extension starting with .. 1path.extname(path)","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"}]},{"title":"Dynamic route combine","slug":"NodeJS/05 Dynamic route combine","date":"2022-03-28T06:57:01.000Z","updated":"2022-11-10T10:47:09.529Z","comments":true,"path":"2022/03/28/NodeJS/05 Dynamic route combine/","link":"","permalink":"https://redre4per.github.io/2022/03/28/NodeJS/05%20Dynamic%20route%20combine/","excerpt":"","text":"The reason for the problem with the path When using the fs module to operate files, if the provided operation path is relative path starting with ./ or ../, the problem of dynamic path splicing error is prone to occur. . The reason is that when the code is running, will dynamically splicing out the full path of the operated file based on the directory where the node command is executed. means the actual path is the current directory + relative path. If the directory when executing the node command is a folder of JS files, there will be no error. But if the directory has been moved to another location, it is not possible to find the JS file by completing the path after the node command (and before the JS file). That is to say, the completed paths are all invalid. 12cd../ #movement pathnode .\\code\\prac1.js #Complete the path after the node command, and the result will fail. Solve dynamic splicing problem with absolute path Using an absolute path as the first parameter in fs.readFile() will solve the problem. Absolute paths start from a drive letter. In VScode, you can right-click the file and copy the path to get the absolute path, such as D:\\Front-end\\Nodejs\\files\\article1.txt . But in JS \\ is an escape character. So you need to change \\ to \\\\ to get the real path, such as D:\\\\Front-end\\\\Nodejs\\\\files\\\\article1.txt . The disadvantage of this method is that it is not portable and not conducive to maintenance. __dirname solves the problem of dynamic splicing __dirname (double underscore prefix) indicates the directory where the current question is located. The value represented by __dirname does not change with the directory in which the node command is executed. Use __dirname to concatenate the relative path of the file (remove the .) to solve. 1fs.readFile(__dirname + &#x27;/files/article1.txt&#x27;, &#x27;utf8&#x27;, function()&#123;&#125;) Note here that the relative path . of the same level should be removed, because . itself is a shorthand for path. When using the fs module, you must use the __dirname writing method. For a better writing method, see the path module section.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"}]},{"title":"fs module, read","slug":"NodeJS/04 fs module, write","date":"2022-03-27T10:07:52.000Z","updated":"2022-11-10T10:15:31.068Z","comments":true,"path":"2022/03/27/NodeJS/04 fs module, write/","link":"","permalink":"https://redre4per.github.io/2022/03/27/NodeJS/04%20fs%20module,%20write/","excerpt":"","text":"**Write content to the specified file: fs.writeFile() ** 1fs.writeFile(path, data[, options], callback) Parameter 1: Required parameter, string, indicating the path of the file. Parameter 2: Required parameter, indicating the content to be written. Parameter 3: An optional parameter, indicating what encoding format to read the file in. The default is utf8. Parameter 4: Required parameter. After the file is read, the read result will be obtained through the callback function. Called whether the write succeeds or fails. For example: in utf8 encoding format, read the contents of the specified file, and print the values of err and dataStr: 1234const fs = require(&#x27;fs&#x27;)fs.writeFile(&#x27;./files/12.txt&#x27;, &#x27;added information&#x27;, &#x27;utf8&#x27;, function(err)&#123; console.log(err)&#125;) If the writing is successful, the err value is null (so do not write err.message directly here, because the callback function will be executed regardless of success or failure, and there is no message on success). If the read fails, the err value is an error object. Determine whether the file is written successfully According to whether err can be converted to true: if(err)&#123;return...&#125; If err can be turned to true, it means that the err object is not null and the writing fails. fs.writeFile() writing mechanism fs.writeFile() writes to replace the file contents, not append to the original contents. When no file is specified, a new file is created and then the contents are written. But if no directory is specified, an error will be reported. Append content to the specified file appendFile() 1fs.appendFile(filepath, data[, options], callback_function); Parameter 1: Required parameter, string, indicating the path of the file. Parameter 2: Required parameter, indicating the content to be written. Parameter 3: An optional parameter, indicating what encoding format to read the file in. The default is utf8. Parameter 4: Required parameter. After the file is read, the read result will be obtained through the callback function. Called whether the write succeeds or fails. Basically the same as fs.writeFile(). Appends do not automatically wrap or whitespace. Append content to the specified file synchronously appendFileSync() 1fs.appendFileSync(filepath, data[, options]); Parameter 1: Required parameter, string, indicating the path of the file. Parameter 2: Required parameter, indicating the content to be written. Parameter 3: An optional parameter, indicating what encoding format to read the file in. The default is utf8.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"}]},{"title":"fs module, read","slug":"NodeJS/03 fs module, read","date":"2022-03-26T22:31:08.000Z","updated":"2022-11-10T11:40:57.822Z","comments":true,"path":"2022/03/27/NodeJS/03 fs module, read/","link":"","permalink":"https://redre4per.github.io/2022/03/27/NodeJS/03%20fs%20module,%20read/","excerpt":"","text":"fs filesystem module The fs module is a module for manipulating files and has a series of methods and properties. Such as fs.readFile() fs.writeFile(). Import fs module Before using the fs module to manipulate files, you need to import it: 1const fs = require(&#x27;fs&#x27;) The require() method takes a string to write to a module. The fs module is available in the node installation package. **Read the contents of the specified file: fs.readFile() ** 1fs.readFile(path[, options], callback) Parameter 1: Required parameter, string, indicating the path of the file. Parameter 2: An optional parameter, indicating what encoding format to read the file in. The default is utf8. Parameter 3: Required parameter. After the file is read, the read result will be obtained through the callback function. For example: in utf8 encoding format, read the contents of the specified file, and print the values of err and dataStr: 123456const fs = require(&#x27;fs&#x27;)fs.readFile(&#x27;./files/11.txt&#x27;, &#x27;utf8&#x27;, function(err, dataStr)&#123; console.log(err) console.log(&#x27;-----&#x27;) console.log(dataStr)&#125;) If the read was successful, the err value is null. If the read fails, dataStr is undefined and err is an error object. Determine whether the file is read successfully It can be determined whether the err object is null. if(err === null)&#123;&#125; or if (err)&#123;return...&#125; . The two spellings are logically opposite. Note that when an error is thrown, err is the error object, and err.message is the error message based on the err code.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"}]},{"title":"Installation","slug":"NodeJS/02 Installation","date":"2022-03-26T10:26:32.000Z","updated":"2022-11-10T10:11:36.369Z","comments":true,"path":"2022/03/26/NodeJS/02 Installation/","link":"","permalink":"https://redre4per.github.io/2022/03/26/NodeJS/02%20Installation/","excerpt":"","text":"Installation should select LTS version Node.js The official website has two installed versions, LTS and Current. LTS is the long-term stable version. For the pursuit of stability and enterprise-level projects, it is recommended to install the LTS version. Current is the early adopter version of new features. For users who want to try new features, it is recommended to install the Current version. However, there may be hidden bugs or security holes in the Current version, so it is not recommended to use Node.js in the Current version in enterprise-level projects. After downloading, select all to install by default. View the version number of installed Node.js Open a terminal and type node -v to see the version number. Execute Javascript code in Node.js environment Open Terminal Switch to the path of the js file to be executed. You can use cd to switch to the target path, or open the target folder and enter cmd, or open the target folder and then hold shift and right-click the blank area to open powershell. Enter node js filename. Note that the file name should be written with a .js suffix. (There is a shortcut key tab in the terminal to quickly complete the file path. For example, there is a js file in the directory: prac1.js. Just enter node p and press tab to complete the path and filename.) nodemon Usefulness: When writing a Node.js project, if the code is modified, it needs to be manually closed frequently and then restarted, which is very cumbersome. The nodemon tool can monitor changes in project files. When the code is modified, nodemon will automatically restart the project for us, which greatly facilitates development and testing. Install (globally): npm install -g nodemon Startup file: nodemon js file path ​","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"}]},{"title":"Introduction","slug":"NodeJS/01 Basic","date":"2022-03-26T07:04:08.000Z","updated":"2022-11-10T10:10:47.698Z","comments":true,"path":"2022/03/26/NodeJS/01 Basic/","link":"","permalink":"https://redre4per.github.io/2022/03/26/NodeJS/01%20Basic/","excerpt":"","text":"Javascript related Components of JS in the Browser JS core syntax: variable&#x2F;data type, loop&#x2F;branch&#x2F;judgment, function&#x2F;scope&#x2F;this, etc… WebAPI: DOM manipulation, BOM manipulation, Ajax manipulation, etc… How JS is executed in the browser Browsers have Javascript parsing engines. Different browsers use different engines, among which Chrome’s V8 parsing engine has the best performance. Why JS can manipulate DOM and BOM Each browser has built-in API functions such as DOM and BOM, so the JS in the browser can call them. The JavaScript runtime environment in the browser The runtime environment refers to the necessary environment for the code to function properly. The browser is the operating environment. Take Chrome as an example: To execute JS code normally, it requires V8 engine, built-in API (DOM, BOM, XMLhttp, JS built-in objects, Canvas, etc.). The JS code to be executed calls the built-in API, and then handed over to the V8 engine to run. Therefore, you cannot call built-in APIs such as DOM without the browser environment. Can JS be used for back-end development? Back-end development languages: Java, Python, PHP. The running environment of JS for back-end development is Node.js. ie Node.js is a backend runtime environment. Introduction to Node.js Node.js is a Javascript runtime environment based on the Chrome V8 engine. Node.js operating environment: V8 engine, built-in API (fs, path, http, JS built-in objects, querystring, etc.). So in-browser APIs like DOM, BOM, and Ajax cannot be called from Node.js. Node.js only provides basic functions and APIs, but there are many powerful tools and frameworks based on Node.js: Express framework, quickly build web applications Electron framework for building cross-platform desktop applications restify framework, quickly build API interface projects Read, write and operate databases, create practical command-line tools to assist front-end development, etc… Node.js Learning Pathway JS learning path in the browser: JS basic syntax, browser built-in API (DOM, BOM, etc..), third-party libraries (jQuery, etc.). Node.js learning path: JS basic syntax (same as browser), Node.js built-in API modules (fs, path, http, etc.), third-party API modules (express, mysql, etc.). nodemon Usefulness: When writing a Node.js project, if the code is modified, it needs to be manually closed frequently and then restarted, which is very cumbersome. The nodemon tool can monitor changes in project files. When the code is modified, nodemon will automatically restart the project for us, which greatly facilitates development and testing. Install (globally): npm install -g nodemon Startup file: nodemon js file path The reason for wanting to install a package globally is usually that we want to run the package directly from the command line, like nodemon and create-react-app. If .ps1 is not digitally signed. The script will not execute on the system. pops up, enter the command first. 1Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass ​","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"}]},{"title":"Flex","slug":"CSS/A01 Flex","date":"2022-02-27T03:19:01.000Z","updated":"2022-11-12T05:28:42.875Z","comments":true,"path":"2022/02/27/CSS/A01 Flex/","link":"","permalink":"https://redre4per.github.io/2022/02/27/CSS/A01%20Flex/","excerpt":"","text":"flex layout features Traditional layout: good compatibility, cumbersome layout, limited, cannot be well laid out on the mobile side. flex is a one-dimensional layout. Flex flexible layout: easy to operate, simple layout, easy to use on mobile, poor browser support on PC, not supported&#x2F;partially supported below IE11. Recommendation: Use traditional layout for PC side page layout, and flex layout for mobile terminal&#x2F;PC side without considering compatibility issues. Flex layout principle flex is the abbreviation of flexible box, flexible layout, used to provide maximum flexibility for the box model, any container can specify flex layout. An element that uses flex layout is called flex container; all its child elements automatically become container members, called flex item. After the parent element sets the flex layout, the float, clear and vertical-align properties of the child element will be invalid. (floats are out. And flex can center elements vertically, so vertical-align doesn’t work). Summary: It is to control the position and arrangement of the child boxes by adding the flex property display:flex; to the parent box. Note the difference with display:block. display : Property Value Description Tailwind flex flex layout flex Common attributes of flex layout parents flex-direction: Set the direction of the main axis (not important) Main and Cross axes: rows and columns, x-axis and y-axis. The default main axis is horizontal to the right and the cross axis is vertical downward. The main axis and the side axis will change, depending on who is set as the main axis in flex-direction, and the rest is the side axis. And our child elements are arranged according to the main axis. For example: display:flex; flex-direction: row; Property Value Description Tailwind row default, left to right row-reverse right to left column top to bottom flex-col column-reverse bottom to top justify-content: Set the arrangement of sub-elements on the main axis The justify-content attribute defines the alignment of the flex item on the main axis, and the main axis must be determined before use. Property Value Description Tailwind flex-start default, start at head, left to right if main axis is x-axis flex-end align from the end center align at the center of the main axis (horizontally if the main axis is the x-axis) space-around Divide the remaining space equally (without borders) space-between First paste the two sides, and then divide the remaining space equally (important) justify-between flex-wrap: Set whether the child element wraps By default, items are arranged on a single line (axis). The flex-wrap attribute defines that the default is not to wrap in the flex layout. If the cumulative width of the child elements exceeds the container, the width of the child elements will be automatically reduced and placed in the parent element. If you don’t want to shrink the child elements automatically, but want the extra child elements to wrap automatically, you can use flex-wrap: wrap property. Property Value Description Tailwind nowrap default, no newline wrap line break wrap-reverse Lines are wrapped and children are reversed diagonally. align-items: Set the arrangement of sub-elements on the side axis (single line) If you just want to lay out elements on a single axis, the previous flex-direction is enough. But if you want elements to be laid out on the main axis + side axis at the same time (such as centering the main axis + centering the side axis), you need align-items. Property Value Description Tailwind flex-start top to bottom flex-end bottom to top center squeeze together and center (vertically center) items-center stretch default? Stretch to the height of the parent element (When using it, do not give height to the child element) baseline the baseline to align the content with align-content: Set the arrangement of sub-elements on the side axis (multiple lines) Used for requirements that cannot be implemented in the layout align-items. align-items can only be aligned on the top&#x2F;bottom&#x2F;center, without space-around in justify-content, etc. align-content sets the arrangement of sub-items on the side axis, and can only be used when the sub-item appears in a new line (multiple lines), and it has no effect under a single line. Property Value Description Tailwind flex-start start alignment at the head of the cross axis flex-end start alignment at the end of the cross axis center display in the middle of the side axis space-around Children divide the remaining space equally on the cross axis space-between The child items are distributed at both ends on the side axis, and then divide the remaining space equally stretch Default value, set the height of the child element to equal the height of the parent element The difference between align-content and align-items align-items is suitable for single-line cases, only top alignment, bottom alignment, centering and stretching. align-content is suitable for newlines (multiple lines), and a single line is invalid. You can set attribute values such as top alignment, bottom alignment, centering, stretching, and evenly distributing the remaining space. flex-flow: Composite attribute, equivalent to setting flex-direction and flex-wrap at the same time Shorthand for setting the main axis direction flex-direction and whether to wrap flex-wrap. 1flex-flow: row wrap; gap: margin between child elements. The difference with margin is that all items can inherit gap directly, instead of writing margin for each item. Property Value Description Tailwind gap spacing between child elements gap-[]&#x2F;-8 Common properties of flex layout children Number of flex sub-items The flex attribute defines the allocation of remaining space to sub-items, and uses flex to indicate how many number of copies. For example, to make a navigation bar with search, the left and right small buttons are fixed, and the middle search bar is adaptive. E.g: 1234567891011121314section &#123; /*parent element*/ display:flex&#125;section div:nth-child(1) &#123; /*fixed size, no need to write flex*/ width:100px; height: 150px;&#125;section div:nth-child(3) &#123; /*fixed size, no need to write flex*/ width:100px; height: 150px;&#125;section div:nth-child(2) &#123; /*1 point is all free space, adaptive*/ flex:1&#125; The three child elements in the parent element bisect the width, such as 123456p &#123; display:flex; width:60%; height:150px;&#125;p span &#123;flex:1&#125; /* Don&#x27;t give the width and height, directly divide it into 3 equal parts, one for each. No width is given, the sum of their widths is the width of the parent element */ do not evenly distribute element widths, such as 123456p &#123; display:flex; width:60%; height:150px;&#125;p span:nth-child(2) &#123;flex:2&#125; /*The child element number 2 occupies two shares, here is 50%, and the other two boxes take one share, each 25%*/ align-self controls the arrangement of sub-items on the side axis The align-self property allows a single item to have a different alignment than other items, overriding the align-items property. The default value is auto, which indicates that the align-items property of the parent element is inherited. If there is no parent element, it is equivalent to stretch. 123section div:nth-child(1) &#123; align-self:flex-end; /*A single child element has a different layout from other child elements*/&#125; The order attribute defines the order of the child items (before and after) The smaller the value, the higher the ranking, the default is 0. Note, not the same as z-index. 123section div:nth-child(2) &#123; order:-1; /*sort by number size*/&#125; flex-basis, flex-grow, flex-shrink It means that the child element stretches proportionally when the width of the parent element is sufficient; or when the width of the parent element is insufficient, Compression ratio. flex-grow: sub-element stretching ratio allocation, the default value is 0, and cannot be negative. If the value is 1, it is fixed and cannot be enlarged. flex-shrink: Sub-element compression ratio allocation, the default value is 1, which cannot be negative. If the value is 0, it is fixed and cannot be reduced any more. flex-basis: The basic size of the child element, the default value is auto. It is not a fixed execution value, but a recommended value, the benchmark value; the real value is determined by grow and shrink. If flex-basis: 0px , the fixed size cannot be scaled. 12345678910.red&#123; flex-grow: 1; flex-shrink: 1; flex-basis: 100px;&#125;.blue&#123; flex-grow: 2; flex-shrink: 2; flex-basis: 100px;&#125; Detailed Tutorials and Exercises Detailed tutorial: https://css-tricks.com/snippets/css/a-guide-to-flexbox/ Exercise 1: https://flexboxfroggy.com/#zh-cn Exercise 2: http://www.flexboxdefense.com/ Exercise 3: http://tom.infinityfreeapp.com/html/shapes.html","categories":[{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"https://redre4per.github.io/categories/HTML-CSS/"},{"name":"CSS","slug":"HTML-CSS/CSS","permalink":"https://redre4per.github.io/categories/HTML-CSS/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://redre4per.github.io/tags/CSS/"}]},{"title":"CSS skills 2","slug":"CSS/02 CSS skills 2","date":"2022-02-19T21:14:32.000Z","updated":"2022-11-12T05:05:11.424Z","comments":true,"path":"2022/02/20/CSS/02 CSS skills 2/","link":"","permalink":"https://redre4per.github.io/2022/02/20/CSS/02%20CSS%20skills%202/","excerpt":"","text":"Variable Variables are defined with --, referenced with var(--varName), and can be accessed by JS. 123:root &#123; //declare in the top root of css--variables and assign values --logo-size:60px;&#125; 1width:var(--logo-size) / 2; //reference variable .active processing in css Use .active in html to manipulate elements, such as adding a .active class to an element (the element can have multiple classes). At the same time, there may be multiple .active to operate on multiple elements. In order to avoid multiple names, you can use .toggle.active &#123;&#125; in css (no spaces in the two selectors, parallel relationship) to select a specific .active. Dynamic effects of interactive elements a button element, the button is stretched when the mouse is moved in: 1a &#123;transition:0.2s;&#125; //The extension has an animation process 1a:hover &#123;letter-spacing: 6px;&#125; // lengthen when the mouse moves in a element button, the button jumps when the mouse moves in: 1.social li a &#123;transition:0.5s;&#125; 123.social li a:hover&#123; transform:translateY(-10px); //The default direction of the Y axis is downward, and a negative value is required for upward jump.&#125; The upper page shrinks to reveal the hidden lower page: 1.showcase &#123;transition:0.5s ease-in-out;&#125; //ease-in-out is soft scaling. ​ Remove the default style of li In ul or ol, set list-style: none;. ​ Uncover the hidden bottom page Hidden pages generally only take up part of the viewport, so they need width. Note that this width will be used many times later, so it is best to set it to the variable --menu: 300px. 1234.showcase.active &#123; //The original upper page is opened from the right and moved to the left. right:var(--menu-width); width: calc(100%-var(--menu-width)); //Calculation when the unit is not uniform. If not changed, it will cause the page to exceed the left border.&#125; The text in the hidden interface still needs to use absolute positioning, and in order to match the div width of the text with the hidden interface, you should use 1.menu &#123;width: var(--menu-width);&#125; JS for Toggle Button Import the JS file: at the bottom of the body, &lt;script src=&#39;&#39;/&gt;. Both buttons and elements that need to change (such as the parent page) require DOM manipulation. Toggle the active class: menuToggle.classList.toggle(&#39;active&#39;). pseudo-element Used before&#x2F;after an element requires content and color attributes. 1234.home&gt;.text&gt;h3::after &#123; content: &quot;abc&quot;; color: #c66;&#125; Decorative pseudo-element: 123456.ribbon::after &#123; content: &quot;Look at this orange box.&quot;; background-color: #FFBA10; border-color: black; border-style: dotted;&#125; background-color and background background can not be set to color, but set to gradient color. Shadow effect Use box-shadow. Its first value is the deflection axis of x, the second value is the deflection axis of y, the third value is the degree of blurring (the higher the shadow, the more blurred, 0-100), the fourth value is the color, which can be Use rgba. E.g: 1box-shadow: 25px 25px 75px rgba(0,0,0,0.25); Note that this effect is a one-sided shadow on the x-axis and y-axis, and only two sides can be considered at the same time. The four sides should use two layers of box-shadow. If you think one layer of shadow is too thin, you can also add multiple layers of shadow. Instead of writing another box-shadow, change the comma after rgba to continue writing the next layer of shadow. 1box-shadow: 25px 25px 1px rgba(0,0,0,0.25), 10px 10px 70px rgba(0,0,0,0.25); Built-in shadow properties: inset. Its first and second values can be negative (positive for upper left, negative for lower right). It casts a shadow within the element’s bounds. The purpose of the built-in shadow is to cooperate with the external shadow to make bump effect. 1box-shadow:inset -5px -5px 15px rgba(0,0,0,1); 1234box-shadow: 25px 25px 1px rgba(0,0,0,0.25),10px 10px 70px rgba(0,0,0,0.25),inset -5px -5px 15px rgba(0,0,0,1),inset 5px 5px 15px rgba(0,0,0,0.5); //Inner and outer shadows to generate a three-dimensional effect.","categories":[{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"https://redre4per.github.io/categories/HTML-CSS/"},{"name":"CSS","slug":"HTML-CSS/CSS","permalink":"https://redre4per.github.io/categories/HTML-CSS/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://redre4per.github.io/tags/CSS/"}]},{"title":"CSS skills 1","slug":"CSS/01 CSS skills 1","date":"2022-02-17T16:06:13.000Z","updated":"2022-11-12T04:55:06.671Z","comments":true,"path":"2022/02/18/CSS/01 CSS skills 1/","link":"","permalink":"https://redre4per.github.io/2022/02/18/CSS/01%20CSS%20skills%201/","excerpt":"","text":"Web site folder directory design index.html src &gt; style.css src &gt; script.js src &gt; assets &gt; video &gt;videos &amp;&amp; src &gt; assets &gt; images &gt; svgs Resource Site Videos and pictures: https://www.pexels.com/ svg icon: https://remixicon.com/ https://fontawesome.com/ https://svgsilh.com/ icon download and use Web Design Ideas A layered approach can be adopted: the hidden menu is placed on the bottom layer, the background image&#x2F;video is placed on the upper layer, the filter is placed on the upper layer, and finally the real HTML body is placed on the top layer. Note here that layering only needs to be implemented with z-index, there is no need to have html layers, and there is no need to put pictures&#x2F;videos in css and use bg to do it. Uncover the hidden layer: The upper element of z-index (the entire upper page) can be positioned absolutely, and the edge to be opened after setting, such as right:0;. In this way, you can set right:Npx when you want to open it later. Fixed-height web pages: For single-page web pages that do not scroll, the height should be set to min-height: 100vh. vh is the viewing height. Code abbreviation and naming Create a label with a class name: section.showcase will create &lt;section class=&#39;showcase&#39;&gt;&lt;/section&gt;. The first line at the top of the website can be called header or nav. Each slightly larger element inside can be given a class name. Multi-line label generation: (li&gt;a&gt;img)*3. This abbreviated structure can be used to jump to the input of the structure with the tab key. Random paragraphs: Lorem * n Multiply as many paragraphs as you want. video Video settings: mute mute; autoplay autoplay; loop playback loop. Video as background: 12345678position: absolute; //It must be absolute, because the background occupies the entire webpage.top:0;left:0; //fix absolute positionwidth: 100%;height:100%; //Video resolution may be different from web page, that is, there are upper and lower black bordersobject-fit:cover; //Solutions with different resolutions. You can remove black borders and change the background video according to the width and height of the webpage.opacity:0.8; //Make the video transparent, and the upper text can be displayed.z-index:0; //The video is at the bottom. It is not necessary to write this setting. Filter: You can directly give the video a div of the same level as html, class&#x3D;’overlay’. Then overlay on top of the video. 1234567position: absolute;top:0;left:0;width: 100%;height:100%; //The previous setting is consistent with the videobackground-color:var(--overlay-color) //Theme color, it is best to set it in a variable form. But the default is opaque.mix-blend-mode:overlay; //The theme color, video, and background color of the text layer will be superimposed. 1background-color: rgba(255,255,255,0.5) //Another way of processing filter color. It is not suitable for dealing with the theme color, and the color will be blurred. button Generally, buttons are not made with button, but with a tag. The a tag is also transparent (that is, blocks can be placed in the inline), so you can set a div inside the a tag. If there is no specific link button, href&#x3D;’#’, click to refresh the current page. Using the a tag as a button needs to ensure that the text cannot be reduced too small, nor can it wrap. So set it to display:inline-block;. The characteristic of the inline part here is that multiple a will flow to the next line when the window is reduced; and the characteristic of the block part is that the text inside a will not become smaller or wrap due to extrusion. That is, it looks like inline on the outside, but it is a block inside. Note that if the img icon is set inside the a tag, it also needs to be set as an inline-block element. The underline also needs to be removed when the a tag is used as a button: text-decoration: none;. Space between each letter in the text: letter-spacing: 2px;. The button should appear larger: padding: 10px 30px;. Changes on mouseover: cursor: pointer. text group Generally, a website will have text groups with different font styles stacked together. In practice, you can use a div.text to wrap these text groups, and then subdivide them with tags such as h2, h3, and p. The advantage of this is that div.text can be used as a whole element and laid out together with the header&#x2F;nav and footer of the website. Case problem: It should be changed in css with text-transform: uppercase; instead of uppercase directly in html, because it may be fixed in the future. The text in the p paragraph may need to be limited, that is, it can be reduced but not too long. max-width:Npx; svg with switchable icons svg image When using it, download it first, and then use the img tag directly in html. Switchable icons such as menu and close are usually not added in html. That is, the fixed icon is written into html, and the variable icon is written into css. When writing, use background: url(). The switching function can use .active, just write the link and configuration item of another icon. At this time, because the icon becomes the background, it will repeat and not be centered. So use: 123background-repeat: no-repeat; //no repeatbackground-size: 30px; //svg The size of the vector image can be changed at will, and the size of the downloaded vector image varies greatly.background-position: center; //center The svg icon has a special black and white discoloration, use filter:invert(1); to invert the color of black and white. Temporarily hide an element display: none in css. Or comment out the html code directly. Change css font In the google fonts site, search for Poppins in the upper right corner. You can select all fonts and load them all in Poppins. After that, directly import Poppins’ link: @import .... This just imports css, but it doesn’t work yet. You should * &#123;box-sizing: border-box;&#125; before changing the font. This is because if width:100px, border:3px, the overall length is 106px. After setting box-sizing, the overall length is still 100px, that is, the border will not exceed the width. 12345* &#123;box-sizing: border-box; margin: 0; padding: 0; font-family:&#x27;Poppins&#x27;, sans-serif; //Find fonts from left to right. There may be no network in front of it, so it can&#x27;t be used.&#125; The reason why it is not written in the body here is that the elements in the body are inherited, while * directly selects all elements. If the margin of a certain layer under the body is changed, then its lower layer will inherit the new margin, resulting in uncertainty. Change the font in a sub-element: font-size attributes generally use rem units, such as 5rem; but line-height should not use rem, but em, such as 1em. Because rem runs according to the default font size of the browser, and after changing font-size in a sub-element (such as responsive), the em below it will go according to the size of font-size. If it is set to rem, it will cause a height limit error. 123font-size: 5rem;font-weight: 800;line-height: 1em; One way to do this is to set :root&#123;font-size:62.5%;&#125;. In this way, the default 16px is changed to 10px, 1rem&#x3D;10px, which is convenient for calculation. For example, the width of 80px can be directly written as 8rem. At the same time, you can directly change the font-size when you need to change the size. This approach is standard in large projects.","categories":[{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"https://redre4per.github.io/categories/HTML-CSS/"},{"name":"CSS","slug":"HTML-CSS/CSS","permalink":"https://redre4per.github.io/categories/HTML-CSS/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://redre4per.github.io/tags/CSS/"}]},{"title":"Axios instance, Interceptor, Cancel request","slug":"Axios/5 Axios instance, interceptor, cancel","date":"2022-01-28T08:04:52.000Z","updated":"2022-11-12T00:31:12.061Z","comments":true,"path":"2022/01/28/Axios/5 Axios instance, interceptor, cancel/","link":"","permalink":"https://redre4per.github.io/2022/01/28/Axios/5%20Axios%20instance,%20interceptor,%20cancel/","excerpt":"","text":"Axios creates an instance object to send a request Usefulness: The interface data for many projects does not come from a single server. When using the Axios object to send requests to different servers, if the default configuration (protocol, domain name, port, etc.) is made, it can only meet the needs of the first server, and the second server cannot set the default configuration. And Axios can solve this problem by creating instance objects. Different servers use different Axios instance objects, and then set different default configurations. Instance objects created by Axios function almost exactly like Axios objects. 12345678910const axios1 = axios.create(&#123; //Axios creates an instance object baseURL:&#x27;http://localhost:3000&#x27;, timeout: 2000&#125;);axios1(&#123; url:&#x27;/posts&#x27;,&#125;).then(response =&gt; &#123; console.log(response);&#125;) Instance objects created by Axios can also send requests with encapsulated methods, such as get( ), post( ), request( ), etc. 123Axios1.get(&#x27;/posts&#x27;).then(response =&gt; &#123; console.log(response);&#125;) ​ Axios Interceptor Interceptors are some functions, which are divided into request interceptor interceptors.request and response interceptor interceptors.response. Request Interceptor can use some functions to process and detect the parameters and content of the request, and then send or cancel, similar to a checkpoint. Response Interceptor can preprocess the result before processing it. For example, remind&#x2F;record the failure result, format and process the data result, if there is no problem after processing, it will be handed over to its own callback function for processing, and if there is a problem, the interceptor will handle it by itself. It is also a similar level. Request Interceptor and Response Interceptor .use( ) has two callbacks for success and failure, the principle is implemented by then( ). 1234567axios.interceptors.request.use(function(config)&#123; //Set request interceptor console.log(&#x27;request interceptor, success&#x27;); return config;&#125;, function(error)&#123; console.log(&#x27;request interceptor, failed&#x27;); return Promise. reject(error);&#125;) 1234567axios.interceptors.response.use(function(response)&#123; //Set response interceptor console.log(&#x27;response interceptor, success&#x27;); return response;&#125;, function(error)&#123; console.log(&#x27;Response interceptor, failed&#x27;); return Promise. reject(error);&#125;) 12345678axios(&#123; //send request method:&#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27;&#125;).then(response =&gt; &#123; console.log(&#x27;custom success result&#x27;);&#125;).catch(reason =&gt; &#123; console.log(&#x27;Custom failure callback&#x27;);&#125;) The result of this code running is ‘request interceptor success’, ‘response interceptor success’, ‘custom success result’. The sequence is to take the successful callback of the request interceptor first, then the successful callback of the response interceptor, and then the successful callback of axios. If the request interceptor returns a failure, that is, return Promise.reject() or throw &#39;there is a problem with the parameter&#39; (Promise syntax), then you cannot go through the successful callback of the response interceptor, and you will go directly to the response The callback of the interceptor failure, and the custom success callback cannot be executed, only the failure callback (such as catch). Execution order of multiple request&#x2F;response interceptors If the same axios object has multiple request interceptors and response interceptors, such as: 12345678910111213141516171819202122axios.interceptors.request.use(function(config)&#123; console.log(&#x27;request interceptor, success -1&#x27;); return config;&#125;);axios.interceptors.request.use(function(config)&#123; console.log(&#x27;request interceptor, success -2&#x27;); return config;&#125;);axios.interceptors.response.use(function(response)&#123; console.log(&#x27;Response interceptor, success -1&#x27;); return response;&#125;);axios.interceptors.response.use(function(response)&#123; console.log(&#x27;Response interceptor, success -2&#x27;); return response;&#125;);axios(&#123; //send request method:&#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27;&#125;).then(response =&gt; &#123; console.log(&#x27;custom success result&#x27;);&#125;) The result is ‘request number 2’, ‘request number 1’, ‘response number 1’, ‘response number 2’, ‘custom success result’. That is, the request interceptor is executed first, and the response interceptor is executed first. config parameter and response parameter config is the configuration object, use config.params = &#123;a:100&#125;; config.timeout = 2000; to configure. 12345axios.interceptors.request.use(function(config)&#123; config.params = &#123;a:100&#125;; config.timeout = 2000; return config;&#125;); response is the response result object, which is actually the response result created by Axios by default (axios.3.6). If you don’t want to process the whole object, but only a part of it, you can return response.data, so that only a specific part is processed. In the following code, the returned result only has the data attribute in the response object, and nothing else. 123456789axios.interceptors.response.use(function(response)&#123; return response.data; //Preprocess the returned result in advance&#125;);axios(&#123; method:&#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27;&#125;).then(response =&gt; &#123; console.log(response); //The response here only returns the response.data part of the response result object.&#125;) ​ Axios cancel request cancelToken: new CancelToken(function (cancel) &#123;&#125;), is an Axios parameter. It takes a function as an argument, and the function has a formal parameter (c) . Setting up a cancellation request requires three steps: Add configuration object properties. cancelToken: new CancelToken(function (cancel) &#123;&#125;) usually takes c as a parameter. Declare a global variable let cancel = null; to save the function returned by c later. Assign c to the global variable cancel. cancel = c; Bind the cancel( ) function in another event to trigger the axios cancellation request of the first event. 123456789101112131415let cancel = null; //Part 2: Declare global variablesbtns[0].onclick = function()&#123; axios(&#123; method:&#x27;GET&#x27;, url:&#x27;http://localhost:3000/posts&#x27;, cancelToken: new axios.CancelToken(function(c)&#123; //Step 1: Add properties of the configuration object cancel = c; //Step 3: Assign c to the global variable cancel. &#125;); &#125;);&#125;btns[1].onclick = function()&#123; cancel(); //Bind the cancel() function in the second event.&#125; In order to verify the effect, you can add a delay to the server response. In json-server, the way to add delay is to add -d code when starting the server: json-server --watch db.json -d 2000 The cancel request is often used for anti-shake, that is, when sending a request, first determine whether the previous request is still continuing, and if it continues, cancel it. 123456789101112131415let cancel = null; //Part 2: Declare global variablesbtns[0].onclick = function()&#123; if(cancel !== null)&#123;cancel();&#125;; //Judge the value of cancel, if it is not null, it means that the last request is not over and needs to be canceled axios(&#123; method:&#x27;GET&#x27;, url:&#x27;http://localhost:3000/posts&#x27;, cancelToken: new axios.CancelToken(function(c)&#123; cancel = c; &#125;); &#125;).then(response =&gt; &#123; console. log(response); cancel = null; //Initialize the cancel value &#125;)&#125;","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"Axios","slug":"Front-end/Axios","permalink":"https://redre4per.github.io/categories/Front-end/Axios/"}],"tags":[{"name":"Axios","slug":"Axios","permalink":"https://redre4per.github.io/tags/Axios/"}]},{"title":"Axios parameters","slug":"Axios/3 Axios parameters","date":"2022-01-27T02:29:06.000Z","updated":"2022-11-12T00:22:31.547Z","comments":true,"path":"2022/01/27/Axios/3 Axios parameters/","link":"","permalink":"https://redre4per.github.io/2022/01/27/Axios/3%20Axios%20parameters/","excerpt":"","text":"Request Configuration These configuration objects can be used not only in axios( ), but also in .request( ), .post( ) and other request methods. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&#123; // server url address url: &#x27;/user&#x27;, // request method method: &#x27;get&#x27;, // default is get // Set the basic structure of url, such as http, localhost, 3000, etc. After setting the baseURL, you only need to write the follow-up path. baseURL: &#x27;https://some-domain.com/api/&#x27;, // Process the request data and send it to the server after processing. That is, preprocessing request parameters. transformRequest: [function (data, headers) &#123; // Do whatever you want to transform the data return data; &#125;], // That is to preprocess the response result. transformResponse: [function (data) &#123; // Do whatever you want to transform the data return data; &#125;], // Configure request header information. When performing identity verification on some projects, a special identifier is required to be added to the request header information to determine whether the request meets the conditions. headers: &#123;&#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;&#125;, // Set the url parameter. What is configured is an object, and various parameters are written. More readable than writing in url. params: &#123; ID: 12345 &#125;, // Parameter serialization configuration item, not commonly used. Serialize request parameters and convert them to strings. (The server side requires this configuration when the data format is different) paramsSerializer: function (params) &#123; return Qs. stringify(params, &#123;arrayFormat: &#x27;brackets&#x27;&#125;) &#125;, // Request body settings (object form). Axios will convert it into a json format string and pass it on. Select the format according to the project requirements. data: &#123; firstName: &#x27;Fred&#x27; &#125;, // Request body settings (string format). axios will pass it straight through. Select the format according to the project requirements. data: &#x27;Country=Brasil&amp;City=Belo Horizonte&#x27;, // overtime time. If this time elapses after sending the request, the request will be cancelled. timeout: 1000, // default is `0` (no timeout) // Settings for carrying cookies when cross-domain requests are made. withCredentials: false, // default // Request adapter settings. One is Ajax in the browser, and the other is sending http in Node.js. adapter: function (config) &#123; /* ... */ &#125;, // Basic validation of the request, not commonly used auth: &#123; username: &#x27;janedoe&#x27;, password: &#x27;s00pers3cret&#x27; &#125;, // Response result format setting responseType: &#x27;json&#x27;, // default // Response result encoding, charset setting. responseEncoding: &#x27;utf8&#x27;, // default // Cross-origin request identifier. Set the name of the cookie. xsrfCookieName: &#x27;XSRF-TOKEN&#x27;, // default // Cross-origin request identifier. Set the request header information. xsrfHeaderName: &#x27;X-XSRF-TOKEN&#x27;, // default /* The above two are a security setting. It is a protective effect to ensure that the request comes from your own client instead of an unknown page. because the server is returning the result A unique identifier will be returned, and the identifier must be sent the next time the request is sent, and the server will respond after verification. But some web pages will add some links Then, send a request to the server. If these two unique identifiers are not added, the request for the web page link may affect the results returned by the server. joined these two After the logo, only the client sends the logo, and other web pages have no logo, so cross-site attacks can be avoided. */ // callback when uploading onUploadProgress: function (progressEvent) &#123; &#125;, // Callback when downloading onDownloadProgress: function (progressEvent) &#123; &#125;, // http response body maximum size maxContentLength: 2000, // The maximum content of the request body maxBodyLength: 2000, // Set the success condition of the response result. No need to change, unless you set the success/failure rules yourself. validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // default &#125;, // Maximum number of jumps. The server request sent may have a jump. Generally, it is only used in Node.js, and Ajax is not used. maxRedirects: 5, // default // Set the socket file location, the function is to send a request to the docker.sock process, that is, data forwarding. There is a priority relationship with the proxy. if set // socket, proxy is also set, socket is used first. socketPath: null, // default // Client information setting, setting whether to keep the connection, not commonly used. httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // Set the proxy. It is often used in node.js, such as switching the client address in a crawler request. proxy: &#123; protocol: &#x27;https&#x27;, host: &#x27;127.0.0.1&#x27;, port: 9000, auth: &#123; username: &#x27;mikeymike&#x27;, password: &#x27;rapunz3l&#x27; &#125; &#125;, // ajax request unset cancelToken: new CancelToken(function (cancel) &#123; &#125;), // an alternative way to cancel Axios requests using AbortController signal: new AbortController(). signal, // Decompress the response result, only for node.js. decompress: true // default // `insecureHTTPParser` boolean. // Indicates where to use an insecure HTTP parser that accepts invalid HTTP headers. // This may allow interoperability with non-conformant HTTP implementations. // Using the insecure parser should be avoided. // see options https://nodejs.org/dist/latest-v12.x/docs/api/http.html#http_http_request_url_options_callback // see also https://nodejs.org/en/blog/vulnerability/february-2020-security-releases/#strict-http-header-parsing-none insecureHTTPParser: undefined // default // transitional options for backward compatibility that may be removed in the newer versions transitional: &#123; // silent JSON parsing mode // `true` - ignore JSON parsing errors and set response.data to null if parsing failed (old behavior) // `false` - throw SyntaxError if JSON parsing failed (Note: responseType must be set to &#x27;json&#x27;) silentJSONParsing: true, // default value for the current Axios version // try to parse the response string as JSON even if `responseType` is not &#x27;json&#x27; forcedJSONParsing: true, // throw ETIMEDOUT error instead of generic ECONNABORTED on request timeouts clarifyTimeoutError: false, &#125;&#125; Axios default configuration Practical trick, you can set the repeated configuration in the default configuration to simplify the code. axios.default.[config] Axios parameters (that is, configuration objects) can be configured by default. When the default configuration is not done, the code is as follows, and the method and url must be set every time an axios request is sent. 12345678btns[0].onclick = function()&#123; axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27; &#125;).then(response =&gt; &#123; console. log(response); &#125;);&#125; After doing the default configuration, 12345678910axios.default.method = &#x27;GET&#x27;;axios.default.baseURL = &#x27;http://localhost:3000&#x27;;btns[0].onclick = function()&#123; axios(&#123; url: &#x27;posts&#x27; &#125;).then(response =&gt; &#123; console. log(response); &#125;);&#125;","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"Axios","slug":"Front-end/Axios","permalink":"https://redre4per.github.io/categories/Front-end/Axios/"}],"tags":[{"name":"Axios","slug":"Axios","permalink":"https://redre4per.github.io/tags/Axios/"}]},{"title":"Axios basics","slug":"Axios/2 Axios basics","date":"2022-01-26T08:16:29.000Z","updated":"2022-11-12T00:15:15.705Z","comments":true,"path":"2022/01/26/Axios/2 Axios basics/","link":"","permalink":"https://redre4per.github.io/2022/01/26/Axios/2%20Axios%20basics/","excerpt":"","text":"Axios Introduction Both React and Vue use Axios to send data requests. Axios can run in the browser and send Ajax requests to the server. Axios can also run in node.js, making http requests to the server side. Axios Features For browser&#x2F;node.js, send Ajax&#x2F;http request to the server. Use the Promise API. Request&#x2F;response interceptor. Do preparation work before the request, and do preprocessing when the result is returned. Help us convert the request and response data. Cancel the request. Automatically convert the result into json data. Block XSRF cross-site attacks to protect clients. Install Axios npm install axios or yarn add axios in the project Tag import &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; Basic use The Axios parameter receives an object, and configuration items are written here. Axios returns a Promise object, so use then( ) to specify the success callback to get the result. After each request is sent, you can view the request header information through Network. GET request (query) 12345678btns[0].onclick = function()&#123; axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts/2&#x27; //The json-server document has a corresponding writing method for the request &#125;).then(response =&gt; &#123; console. log(response); &#125;);&#125; POST request (add a new article) 123456789101112btns[1].onclick = function()&#123; axios(&#123; method: &#x27;POST&#x27;, url:&#x27;http://localhost:3000/posts&#x27;, data: &#123; title:&#x27;new article&#x27;, author:&#x27;Tom&#x27; &#125; &#125;).then(response =&gt; &#123; console. log(response); &#125;);&#125; After the request, the sent data can be found in the db.json file. Because no id is specified, it is added sequentially in posts. In addition, the Payload next to Network-Headers can see the data sent. PUT request (modify data) 123456789101112btns[2].onclick = function()&#123; axios(&#123; method: &#x27;PUT&#x27;, url:&#x27;http://localhost:3000/posts/3&#x27;, //The id should be specified here instead of in data. data: &#123; title:&#x27;second new article&#x27;, author:&#x27;Jonny&#x27; &#125; &#125;).then(response =&gt; &#123; console. log(response); &#125;);&#125; DELETE request (delete data) 12345678btns[3].onclick = function()&#123; axios(&#123; method: &#x27;DELETE&#x27;, url:&#x27;http://localhost:3000/posts/5&#x27; //DELETE request only needs id, no request body. &#125;).then(response =&gt; &#123; console. log(response); &#125;);&#125; Axios other methods to send requests Compared with the previous section, the request method in this section is only different in writing. 12345678axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.options(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]]) Config are other configuration items, such as request headers and request bodies. For example .request() 12345678btns[0].onclick = function()&#123; axios.request(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts/2&#x27; &#125;).then(response =&gt; &#123; console.log(response); &#125;);&#125; .post() 12345678910btns[1].onclick = function()&#123; axios.post( //There is no &#123; url=&#x27;http://localhost:3000/posts&#x27;, //here is url= &#123; title:&#x27;new article by .post()&#x27;, author:&#x27;Tomas&#x27; &#125;).then(response =&gt; &#123; console.log(response); &#125;);&#125; Axios response structure The object returned by the Axios request, the result of then(response). config is a configuration object, including request type, request url, request body, etc. data is the response body (the result returned by the server). It is an object, because Axios automatically parses the json returned by the server for easy processing. headers is the response header information. request is a native Ajax request object (XMLHttpRequest() instance object). Because Axios uses Ajax to send requests. status is the response status code, and statusText is the response string.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"Axios","slug":"Front-end/Axios","permalink":"https://redre4per.github.io/categories/Front-end/Axios/"}],"tags":[{"name":"Axios","slug":"Axios","permalink":"https://redre4per.github.io/tags/Axios/"}]},{"title":"Http basics","slug":"Axios/1 Http basics","date":"2022-01-25T03:39:33.000Z","updated":"2022-11-12T00:04:37.416Z","comments":true,"path":"2022/01/25/Axios/1 Http basics/","link":"","permalink":"https://redre4per.github.io/2022/01/25/Axios/1%20Http%20basics/","excerpt":"","text":"Http basics The client sends a request (request message) to the server, and the request content includes request line, request header, and request body. The server responds to the data returned by the client, and the http response (response message) includes status line, response header, and entity content. The specific content of the request can be viewed in inspect-network. The first item under All-Name (the URL item) is sent to the request. There are General, Response Headers and Request Headers in the Headers after clicking, These are the information organized by the browser. Request message: Request line method url GET&#x2F;produc_detail?id&#x3D;2 POST&#x2F;login Multiple request headers Host: www.google.com Cookie[^1]: SEARCH_SAMESITE&#x3D;CgQIl5QB; HSID&#x3D;Acx6gym1ffa3ppTqI; SSID&#x3D;ABqoRPct1dz_XB-1y; … Content-Type: apllication&#x2F;x-www-form-urlencoded or application&#x2F;json Content-type is the request body content type. Request body The request body does not necessarily have. A GET request has no request body, a POST request [^2] has no request body without parameters, and a POST request has a request body with parameters. username&#x3D;tom&amp;pwd&#x3D;123 This is Content-Type: apllication&#x2F;x-www-form-urlencoded format. {“username”: “tom”, “pwd”: “123”} This is Content-Type: application&#x2F;json format. Response message: Response status line status Status code, such as 200, 201, 401, 404, 500. (one-to-one correspondence with the status text example) statusText Status text such as OK, Created, Unauthorized, Not Found, Internal Server Error Multiple response headers Content-Type: text&#x2F;html; (text in html format, text&#x2F;json in JSON format) charest&#x3D;utf-8 (encoding) Set-Cookie: BD_CK_SAM&#x3D;1; path&#x3D;&#x2F; The server returns the cookie data, corresponding to the cookie in the request header. Response body html text&#x2F;json text&#x2F;js&#x2F;css&#x2F;image.. Different types of requests and their functions The same server address sends different types of requests, and the server does different things. GET: read data from the server POST: add new data to the server PATCH: Add new data to the server (partial update) PUT: Update the existing data on the server side (overall update) (in practice, it is often mixed with POST) DELETE: Delete server-side data Ajax request There are two ways to send Ajax requests: XHR objects, and the catch() function. Classification of API The API here refers to the interface for front-end and back-end interaction. REST API: restful (another name) Send a request for CRUD (CRUD: the English abbreviation of CRUD, create&#x2F;read&#x2F;update&#x2F;delete) which operation is determined by the request method is actually a different type of request in section Axios.1.2. If the server supports different request types corresponding to different operations, it is restful; otherwise, it is restless. The same request path can perform multiple operations The request method will use GET&#x2F;POST&#x2F;PUT&#x2F;DELETE Non-REST API: restless (alias) The request method does not determine the requested CRUD operation A request path corresponds to only one operation Generally only GET&#x2F;POST (GET for query, POST for addition, deletion and modification) Appendix [^1]: If it is unsuccessful, it is a problem with the installation of json-server There are 3 ways to solve the installation problem. The first is to add npx before the code, the second is to open a cmd in the current directory and type the code, and the third is to modify permissions through PowerShell in administrator mode [About execution policy](https://docs.microsoft. com&#x2F;en-us&#x2F;powershell&#x2F;module&#x2F;microsoft.powershell.core&#x2F;about&#x2F;about_execution_policies?view&#x3D;powershell-7.2). Admin Mode PowerShell: Press Win + R. Type powershell and press Ctrl+Shift+Enter. Click OK to start PowerShell with administrator privileges. PowerShell By default, *.ps1 script files are not allowed to be executed. Running the ps1 file gives the following error: File C:\\Temp\\Test.ps1 cannot be loaded because the execution of scripts is disabled on this system. Please see “get-help about_signing” for more details. The following command can resolve the above error PS C:\\Windows\\system32&gt; Set-ExecutionPolicy RemoteSigned [^2]: db.json code 123456789&#123; &quot;posts&quot;: [ //posts, not POST requests &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; &#125; ], &quot;comments&quot;: [ &#123; &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 &#125; ], &quot;profile&quot;: &#123; &quot;name&quot;: &quot;typicode&quot; &#125;&#125;","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"Axios","slug":"Front-end/Axios","permalink":"https://redre4per.github.io/categories/Front-end/Axios/"}],"tags":[{"name":"Axios","slug":"Axios","permalink":"https://redre4per.github.io/tags/Axios/"}]},{"title":"props in route@5","slug":"React/E05 props in route","date":"2021-12-31T07:29:52.000Z","updated":"2022-11-12T04:35:42.010Z","comments":true,"path":"2021/12/31/React/E05 props in route/","link":"","permalink":"https://redre4per.github.io/2021/12/31/React/E05%20props%20in%20route/","excerpt":"","text":"Pass the params parameter There are three ways to carry parameters in ajax: query, params, body. The body parameter has two encoding forms: urlencoded and json. There is also a params form in routing components, that is, parameters are placed directly in the path. The parameter is placed directly in the path of the navigation link, and the params parameter is passed to the routing component. Data that cannot be placed can be placed in the state of the sub-route. The path of the routed component is also declared to receive, and is declared using the express syntax in Node.js. When is received, the passed parameters can be found in props.match.params (in React 5.3.1). props is the history object. Parent component (carrying parameters, declared to receive) 12345678state = &#123;msgArr:[&#123;id:&#x27;01&#x27;, title:&#x27;message1&#x27;&#125;, &#123;id:&#x27;02&#x27;, title:&#x27;message2&#x27;&#125;, &#123;id:&#x27;03&#x27;, title:&#x27;message3&#x27;&#125;]&#125;;const &#123;msgArr&#125; = &#123;this.state&#125;;msgArr.map(msgObj =&gt; &#123;return(&lt;Link to=&#123;`/home/message/detail/$&#123;msgObj.id&#125;/$&#123;msgObj.title&#125;`&#125;&gt;&#123;msgObj.title&#125;&lt;/Link&gt; )&#125;); //carry parameters&lt;Route path=&#x27;/home/message/detail/:id/:title&#x27; component=&#123;Detail&#125;/&gt; //node writing, declare to receive Routing component (receiving parameters) 1234567891011121314const DetailData = [&#123;id:&#x27;01&#x27;, content:&#x27;Hello, Australia&#x27;&#125;, &#123;id:&#x27;02&#x27;, content:&#x27;Hello, Tasmania&#x27;&#125;, &#123;id:&#x27;03&#x27;, content:&#x27;Hello, Hobart&#x27;&#125;]const &#123;id,title&#125; = this.props.match.params; //Receive parametersconst findResult = DetailData.find(detailObj =&gt; &#123; return detailObj === id&#125;)return( &lt;ul&gt; &lt;li&gt;ID:&#123;id&#125;&lt;/li&gt; &lt;li&gt;Title:&#123;title&#125;&lt;/li&gt; &lt;li&gt;Content:&#123;findResult.content&#125;&lt;/li&gt; &lt;/ul&gt;) Summarize Route link (with parameters): &lt;Link to=&#39;/demo/test/tom/18&#39;&gt;Details&lt;/Link&gt; Register route (declare parameters): &lt;Route path=&#39;/demo/test/:name/:age&#39; component=&#123;test&#125;/&gt; Receive parameters: const &#123;id,title&#125; = this.props.match.params Pass the search parameter Similar to the routing component passing params parameters, it is the same as the query syntax in ajax, namely ?id=01&amp;title=xx1 (urlencoded encoding form, namely key=value&amp;key=value, but there is an extra ?). The search parameter does not need to be declared in the routing component path to receive. When received, the passed parameters can be found in props.match.location.search (in React 5.3.1). The format of the parameter here is search:&quot;?id=01&amp;title=xx1&quot;, that is, a string format rather than an object format. This string can be processed into an object format by itself, or processed by the querystring library (qs library). The querystring library (qs library) has two utility methods. qs.stringify(obj) converts the object into urlencoded encoding form, and qs.parse(urlencoded) converts the urlencoded encoding into an object. Note here that the search parameter has one more ? than urlencoded. Parent component (carrying parameters, declaring receiving), Note that the search parameter does not need to declare receiving, just register the route normally. 1234msgArr.map(msgObj =&gt; &#123;return(&lt;Link to=&#123;`/home/message/detail/?id=$&#123;msgObj.id&#125;&amp;title=$&#123;msgObj.title&#125;`&#125;&gt;&#123;msgObj.title&#125;&lt;/Link&gt; //carry parameters )&#125;);&lt;Route path=&#x27;/home/message/detail&#x27; component=&#123;Detail&#125;/&gt; //declare receiving Subcomponent (receives parameters) 123const &#123;search&#125; = this. props. location;const &#123;id,title&#125; = qs.parse(search.slice(1)); //urlencoded to object, and remove redundant?//Others are the same as the params method Summarize routing link (carrying parameters): &lt;Link to=&#39;/demo/test?name=tom&amp;age=18&#39;&gt;details&lt;/Link&gt; Register route (declare parameters): &lt;Route path=&#39;/demo/test&#39; component=&#123;test&#125;/&gt; Receiving parameters: this.props.location.search Remarks: The obtained search is a urlencoded encoded string, which needs to be parsed with the help of querystring. One more? Need to remove. Pass the state parameter The state here is a unique property of the routing component, not the state of the component. Both the params and search delivery methods will display the passed data in the address bar, but the state method will not. Passing the state parameter requires writing the to= in the navigation link as an object (&#123;&#123;&#125;&#125;). The state parameter does not need to be declared received in the route component path. When received, the passed parameters can be found in props.match.location.state and are in object format. Parent component (carrying parameters, declaring to receive), Note that the state parameter does not need to be declared to receive, just register the route normally. 12&lt;Link to=&#123;&#123;pathname:&#x27;/home/message/detail&#x27;,state:&#123;id:msgObj.id, title:msgObj.title&#125;&#125;&#125;&gt;&#123;msgObj.title&#125;&lt;/Link&gt; //carrying parameters&lt;Route path=&#x27;/home/message/detail&#x27; component=&#123;Detail&#125;/&gt; //declare receiving Subcomponent (receives parameters) 12345const &#123;id,title&#125; = this.props.location.state;const findResult = DetailData.find(detailObj =&gt; &#123; return detailObj === id&#125;) //No change, just for follow-up comparison.//Others are the same as the params method There is a problem here, that is, the params and search methods both have parameters in the address bar, and the address bar still has parameters after refreshing, so the subcomponent data will not be lost. However, there are no parameters in the address bar of the state method, and there are no parameters in the address bar after refreshing, and the subcomponent data is not lost. The principle implemented here is that when using BrowserRouter, it has been operating the history in the browser and maintaining history.XXX. And location is an attribute in history (React 5.3.1 is shorthand, if not shorthand, there is location in history). At this time, if the browser cache is cleared (clear history), and then refresh, the page cannot be rendered and an error (undefined error) is reported. Therefore, adding a ||&#123;&#125; to the child component will not report an error. 12345const &#123;id,title&#125; = this.props.location.state||&#123;&#125;;const findResult = DetailData.find(detailObj =&gt; &#123; return detailObj === id&#125;)||&#123;&#125;//Others are the same as the params method After the change, the refresh will not report an error, but it will display empty data. Summarize Route link (with parameters): &lt;Link to=&#123;&#123;pathname:'/demo/test',state:&#123;name:'tom, age:18'&#125;&#125;&#125; &gt;Details&lt;/Link&gt; Register route (declare parameters): &lt;Route path=&#39;/demo/test/:name/:age&#39; component=&#123;test&#125;/&gt; Receive parameters: this.props.location.state Note: Refresh can also keep parameters.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Nested route@5","slug":"React/E04 Nested route","date":"2021-12-28T21:59:03.000Z","updated":"2022-11-12T04:31:15.485Z","comments":true,"path":"2021/12/29/React/E04 Nested route/","link":"","permalink":"https://redre4per.github.io/2021/12/29/React/E04%20Nested%20route/","excerpt":"","text":"Secondary route writing method (in the @6 version there is no such problem) File location: The component folder is created under the first-level routing folder. Navigation link location: in the routing component of the first-level routing. The path should be a path with a first-level route, such as &lt;MyNavLink to=&quot;/home/news&quot;&gt; 1&lt;MyNavLink to=&quot;/home/news&quot;&gt;News&lt;/MyNavLink&gt; Registered routing location: same as above. The path should also have a first-level routing path. 1&lt;Route path=&quot;/home/news&quot; component=&#123;News&#125;/&gt; If it is a multi-level routing, the path of each previous level must be written. Nested route matching mechanism The matching order of routes is from the first registration to the last registration, and is matched layer by layer according to the routing registration order. The first-level route must be registered first, because it is registered when the page is opened. Matching process: When the navigation link with the path /home/news starts to match, the first level of path=&quot;/home&quot; is matched, and the match is successful due to fuzzy matching, so the home component is presented; then It matches the path=&quot;/home/news&quot; of the second layer, matches the news component under the home component, and then renders the news component in the home component. If strict matching exact is turned on for the first-level route, then the sub-reasons below it are invalid. Because the addresses of sub-routes are all /home/..., and the first-level matching of this address cannot be successfully matched.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Advanced usage of route@5","slug":"React/E03 Advanced usage of route","date":"2021-12-28T05:22:30.000Z","updated":"2022-11-12T04:30:30.483Z","comments":true,"path":"2021/12/28/React/E03 Advanced usage of route/","link":"","permalink":"https://redre4per.github.io/2021/12/28/React/E03%20Advanced%20usage%20of%20route/","excerpt":"","text":"Routing components and general components General components are placed in the src-components tag, but routing components are not in compliance with the specification. When standardizing development, routing components should be placed in src-pages. The general component writing method is &lt;Header/&gt;, and the routing component writing method is &lt;Route path=&#39;/demo&#39; component=&#123;Demo&#125;/&gt;. The general component props is &#123;&#125; if it is not passed; the routing component also has props &#123;history:&#123;&#125;, location:&#123;&#125;, match:&#123;&#125;&#125; fixed three properties. The encoding needs to be used in the three attributes are: history: go: f go(n) goBack: f goBack() goForward: f goForward() push: f push(path, state) replace: f replace(path, state) location: pathname: “&#x2F;about” search: “ “ state: undefined match: params: &#123;&#125; path: “&#x2F;about” url: “&#x2F;about” NavLink If the route link is highlighted, or a dynamic class name needs to be appended when clicking, you cannot use &lt;Link&gt; , use &lt;NavLink&gt; . The mechanism of NavLink is to append a class name to the element currently being clicked, and the class name is active. (The mechanism of Bootstrap is that whoever is active will be highlighted. This matches NavLink exactly.) But sometimes you don’t use Bootstrap, or you don’t want to use the active category. This requires the use of an attribute of NavLink: activeClassName&#x3D;” “, which can specify the highlighted class name. When using this property, add !important to the style to increase the weight (to exceed the Bootstrap default weight) (there is a bug here). wrapped NavLink component If it is not encapsulated, the code repetition is too high (the repeated content is activeClassName and className). Encapsulated as &lt;MyNavLink&gt; (generic component). 1234567import &#123; NavLink &#125; from &#x27;react-router-dom&#x27;export default class MyNavLink extends Component &#123; render() &#123; return ( &lt;NavLink activeClassName=&quot;test&quot; className=&quot;item&quot; &#123;...this.props&#125;/&gt;)&#125;&#125; 1&lt;MyNavLink to=&quot;/home&quot;&gt;Home&lt;/MyNavLink&gt;&lt;br/&gt; //Use the same as NavLink, repeat the code to write to MyNavLink Note here the delivery method of tag body content (Home in the example). The content of the component tag body is a special tag property: props.children. In a tag, instead of writing the content in the content of the tag body, write the content directly with children&#x3D;” “ in the tag, and the content can also be displayed. 1&lt;p children=&quot;label body content&quot;/&gt; //This will display the label content normally. In the example code block, use &#123;...this.props&#125; to write props.children into the tag together, that is, to display the content normally. Use of Switch If a path corresponds to two components, both components will be rendered, but this is not normal code. The routing mechanism is that after the path matches the component, it will continue to match, which leads to low efficiency. The @5 version uses &lt;Switch&gt;&lt;/Switch&gt; to wrap the routing component to solve this problem. Once the path is matched to the component, it will not continue to match. (Use Switch when more than one route is registered) 1234&lt;Switch&gt; &lt;Route path=&quot;/about&quot; component=&#123;About&#125;&gt; &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;&gt;&lt;/Switch&gt; Solve the problem of missing styles Trigger condition for style loss: The navigation link uses multiple &#x2F; (non-nested routes) such as &#x2F;a&#x2F;b and uses bootstrap. After the page is rendered, the style may be lost. (The new version should have been fixed) You can hold down SHIFT and refresh every time you refresh, and force the refresh without leaving the cache. Reason analysis: In the network, look for the bootstrap.css file, the status is 200 (success), and the style is not lost here. Click here to find the bootstrap.css address http://localhost:3000/css/bootstrap.css . This is the address of bootstrap.css in the scaffolding. (where http://localhost:3000 is the scaffolding built-in server (created by devServer in webpack), and public is the root path of http://localhost:3000.) The validity of the bootstrap.css address can be verified directly in the browser Look at this address, or the response next to the header in the network. But when the &#x2F;a&#x2F;b structure is used, the bootstrap.css file, the status is 304. After clicking it, I found that the address is http://localhost:3000/a/css/bootstrap.css , that is, &#x2F;a in the &#x2F;a&#x2F;b structure is considered to be part of the root path, so the address of the css file is wrong. At this time, the response returned is index.html. This is because there is a mechanism in the scaffolding, that is, if a non-existing resource is requested with an address, the scaffolding will render the index.html in public. The error reported here is Resource interpreted as Stylesheet but transferred with MIME type text&#x2F;html: “http://localhost:3000...&quot; There are three solutions: In the public index.html, change the css import path from href=&#39;./css/bootstrap.css&#39; to href=&#39;/css/bootstrap.css&#39; (remove .). The principle here is to change the relative path of ./ to the absolute path of /. / means to go directly to http://localhost:3000 to request content. This is generally used. In index.html, the css import path is changed to href=&#39;%PUBLIC_URL%/css/bootstrap.css&#39; . %PUBLIC_URL% represents the absolute path to the public file. This scenario is limited to React scaffolding. In index.js under src, BrowerRouter is changed to HashRouter. After the change, the root path becomes http://localhost:3000/#/ . # are considered front-end resources and are not brought to the server, such as http://localhost:3000/#/a/b . routing fuzzy matching and strict matching Fuzzy matching: to=&quot;/home/a/b&quot; in the &lt;Link&gt; class tag provides many paths, but &lt;Route&gt; requires fewer paths for path=&quot;/home&quot;, you can match to. When matching, it matches in the order of /home /a /b, and /home matches path=&quot;/home&quot; in the &lt;Route&gt; tag, and the match is successful. However, if the order is wrong, such as /a /home /b, the match cannot be successful, because if /a does not match, it will be considered a match failure. Exact match: The paths must match exactly. &lt;Route exact=&#123;true&#125; path=&quot;/about&quot; component=&#123;about&#125;/&gt;. That is, exact=&#123;true&#125; is added to the &lt;Route&gt; tag. Shorthand can directly write exact, omitting =&#123;true&#125;. In actual work, try not to use strict matching, which will cause serious problems. The principle of use is that if you can not enable strict matching, you will not enable it. If there is a problem with fuzzy matching, then enable strict matching. Redirect implements preselection In the previous way of writing, no routing components are displayed after opening the page, and the page needs to be clicked on the navigation link. But we want to have a default routing component. Implementing default routing requires Redirect redirection. (Deprecated in @6, changed to Navigate) Note that http://localhost:3000 (same as http://localhost:3000/ ) is for route matching. / is an empty string, matching no components. &lt;Redirect to=&quot;/about&quot;/&gt; should be placed at the bottom of the routing component, as a catch-all item (similar to the else in if) to redirect addresses that do not match the routing component to a routing component. 123456import &#123;Redirect&#125; from &#x27;react-router-dom&#x27;;&lt;Switch&gt; &lt;Route path=&quot;/about&quot; component=&#123;about&#125;/&gt; &lt;Route path=&quot;/about&quot; component=&#123;about&#125;/&gt; &lt;Redirect to=&quot;/about&quot;/&gt;&lt;/Switch&gt;","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Basic usage of route@5","slug":"React/E02 Basic usage of route","date":"2021-12-26T03:58:20.000Z","updated":"2022-11-12T04:20:08.054Z","comments":true,"path":"2021/12/26/React/E02 Basic usage of route/","link":"","permalink":"https://redre4per.github.io/2021/12/26/React/E02%20Basic%20usage%20of%20route/","excerpt":"","text":"React-router understanding A plugin library for react. (react-xxx are basically plug-in libraries) The library we installed here is not react-router. react-router has three libraries for three platforms. Three libraries: web: Web page development (actually learning this). The library name is react-router-dom native: used by react native. anywhere: can be used anywhere It is specially used to implement a SPA application. React-based projects will basically use this library. React Router three different libraries on npm The core library of react-router routing provides many: components, hooks react-router-dom contains all content of react-router, and adds some components dedicated to DOM, such as &lt;BrowserRouter&gt;. react-router-native contains all content of react-router, and adds some APIs dedicated to ReactNative, such as &lt;NativeRouter&gt;. Install react-router-dom npm i react-router-dom@5 or &#96;yarn add react-router-dom@5 Basic use of routing The front-end routing implementation is divided into two steps: 1. Clicking on the navigation link causes the path to change; 2. The path change is detected by the router, and the components are matched and displayed. The content of the routing component display area is variable, but other areas are fixed. Therefore, compared to pages that do not use routing, routing-related codes will only be written in the navigation area and routing component display area. The code for fixed display in other areas is written as usual. Import library 1import &#123;&#125; from &#x27;react-router-dom&#x27; //Using `&#123;&#125;` is because many built-in components and built-in APIs need to be exposed, which one to use. Navigation links In native html, &lt;a&gt; is used to jump to different pages, and in React, routing links &lt;Link&gt; are used to switch components. 123import &#123;Link&#125; from &#x27;react-router-dom&#x27;; //Introduce Link&lt;Link className=&quot;list-group-item&quot; to=&quot;/about&quot;&gt;About&lt;/Link&gt;&lt;Link className=&quot;list-group-item&quot; to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link&gt; is used instead of &lt;a&gt;. Here there is no href, and to=&quot; &quot; is used instead. Note that about in to=&quot;/about&quot; is best lowercase, because it does not recognize case. Also don’t write to=&quot;./about&quot;, because there is never . in the web path. But directly writing the code in the above code block will report an error: Error: Invariant failed: You should not use &lt;Link&gt; outside a &lt;Router&gt;. Because routing links and routes are managed by the router, that is, a &lt;Router&gt; should be wrapped outside &lt;Link&gt;. And, When using &lt;Router&gt; to wrap &lt;Link&gt;, specify the Router type: &lt;BrowserRouter&gt; &#x2F; &lt;HashRouter&gt; . Otherwise, an error will be reported: TypeError: Cannot read property ‘location’ of undefined. routing component 123456import &#123;Link,Route&#125; from &#x27;react-router-dom&#x27;; //First import the registered routeimport Home from &#x27;./components/Home&#x27;; // does not conform to the specification, see React.5.3.1 for detailsimport About from &#x27;./components/About&#x27;;&lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;&lt;Route path=&quot;/about&quot; component=&#123;about&#125;/&gt; First, import the registered routing tag &lt;Route/&gt;. &lt;Route/&gt; is self-closing and has attributes path and component&#x2F;element. Note that component is lowercase (some compilers will suggest uppercase). The routing component should also be wrapped with &lt;BrowserRouter&gt; &#x2F; &lt;HashRouter&gt; , otherwise an error will be reported, which is the same as the navigation link. Router management (package &lt;BrowserRouter&gt; &#x2F; &lt;HashRouter&gt;) The entire application must be managed by a router, that is, packaged in the same &lt;BrowserRouter&gt; &#x2F; &lt;HashRouter&gt;, otherwise the routing components cannot be switched. For simplicity, directly wrap the router management package outside the &lt;App/&gt; root component under the index.js file. 1234567import &#123;BrowserRouter&#125; from &#x27;react-router-dom&#x27;;ReactDOM. render( &lt;BrowserRouter&gt; &lt;App/&gt; &lt;/BrowserRouter&gt;, document. getElementById(&#x27;root&#x27;)) ​ Summary Define the navigation area and display area in the interface. Change the a label of the navigation area to the Link label 1&lt;Link to=&quot;/xxxx&quot;&gt;Demo&lt;/Link&gt; Write the Route label in the display area for route matching 1&lt;Route path=&quot;/xxxx&quot; component=&#123;Demo&#125;/&gt; The outermost part of &lt;App/&gt; wraps a &lt;BrowserRouter&gt; &#x2F; &lt;HashRouter&gt; ​","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"SPA, route","slug":"React/E01 SPA, route","date":"2021-12-24T11:13:38.000Z","updated":"2022-11-12T04:15:01.491Z","comments":true,"path":"2021/12/24/React/E01 SPA, route/","link":"","permalink":"https://redre4per.github.io/2021/12/24/React/E01%20SPA,%20route/","excerpt":"","text":"SPA Definition Single page web application (single page web application, SPA). The entire application has only one complete page. (Single page with multiple components) That is, there is only the page localhost:3000&#x2F;index.html (scaffolding root directory). index.html is automatically omitted, which is localhost:3000. There will be no such pages as localhost:3000&#x2F;about.html, localhost:3000&#x2F;home.html. Clicking the link on the page will not refresh the page, but only partial update of the page. Data must be obtained through ajax requests and displayed asynchronously on the front end. Routing understanding When opening the page, the page is an address localhost:3000. When you click the link in the navigation area (routing link), it will not cause the page to jump, but change the address to localhost:3000&#x2F;home, localhost:3000&#x2F;about, etc. Front-end router will specifically monitor changes in browser paths, and display home, about and other components on the page after detection. &#x2F;home, &#x2F;about, etc. are paths, not urls. A route is a mapping relationship (key: value), the key is the path, and the value is component or function (backend). Routing classification Backend routing (Node.js): Understand: value is a function, which is used to process the request submitted by the client. Register the route: router.get(path, function(req, res)) Working process: When the node receives a request, it finds a matching route according to the request path, calls the function in the route to process the request, and returns the response data. Front-end routing: Browser-side routing, the value is component, which is used to display page content. Register the route: &lt;Route path=&quot;/test&quot; component=&#123;test&#125;&gt; Working process: When the browser’s path changes to &#x2F;test, the current routing component will become the Test component. Front-end routing principle (how to implement routing detection) Front-end routing works by the history on the BOM (browser object). window is the BOM object, and document is the DOM object. Output window.history to get History {Length:1, scrollRestoration: “auto”, state:null} object. Programmers often do not directly manipulate history because the native API is not easy to use. Therefore, it is necessary to use the history.js library to operate. Change browser path 123456789101112131415161718192021222324&lt;a onclick=&quot;return push(&#x27;/test1&#x27;)&quot;&gt;push button&lt;/a&gt; &lt;!--Adding return will prohibit a tag herf jumping--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https:.../history.js&quot;&gt;&lt;/script&gt; &lt;!--Import library--&gt;&lt;script type=&quot;text/javascript&quot;&gt; let history = History.createBrowserHistory() //Create a history object function push(path)&#123; //Push a piece of data into the history, the data is the path/test1 history.push(path) return false &#125; function replace(path)&#123; //The current history is replaced with the path path. history.replace(path) &#125; function forward()&#123; // Equivalent to the browser&#x27;s forward button, just written by yourself. history.goForward() &#125; function back()&#123; // Equivalent to the browser&#x27;s back button, just written by yourself. history.goForward() &#125; &lt;/script&gt; After this code runs, the web page will not jump or refresh, but the current page path will become &#x2F;test1. At the same time, a historical record is formed, which can be regressed. (React is required for path matching components, because only React has components.) Detect browser path changes 123history.listen((location) =&gt; &#123; //The listen method listens to the path location. Called when the path changes. console.log(&#x27;The request routing path has changed&#x27;, location)&#125;) The browser’s history structure The browser’s history is a stack structure. The record at the top of the stack is the webpage currently being viewed. When the website is opened, at the bottom of the stack there is the path xxxx.history.html of the website’s home page. When pushing, a xxxxp&#x2F;test1 is added above the history record just now. If you continue to push, add an xxxxp&#x2F;test2 to the top of the stack. When the point goes back, the top of the stack xxxxp&#x2F;test2 is popped, and the web page returns to xxxxp&#x2F;test1. Click back again, the top of the stack xxxxp&#x2F;test1 is popped, and return to xxxx.history.html. When going forward, xxxxp&#x2F;test1 goes back to the top of the stack, and then clicks xxxxp&#x2F;test2 to go back to the top of the stack. During the replace operation, the current location (that is, the record on the top of the stack) is replaced by xxxxr&#x2F;test3. That is, the data in the stack from the bottom of the stack to the top of the stack is xxxx.history.html, xxxxp&#x2F;test1, xxxxr&#x2F;test3, that is, the xxxxp&#x2F;test2 records disappear. Back at this point, it will return to xxxxp&#x2F;test1. Two working modes of History Method 1 (that is, the one used above), directly uses the API on the history launched by H5. Some older browsers do not support it. 1let history = History. createBrowserHistory() Method 2, instead of using the H5 API, the hash value (anchor) is used. 1let history = History. createHashHistory() When using method 2, the browser address will have one more #, such as localhost:3000.html**#&#x2F;. After the push and replace operations, the address will become localhost:3000.html#**&#x2F;test1, still with #. Much like an anchor jump, i.e. does not cause a page refresh and leaves a history. There is no need to write the anchor point by yourself with the hash method, and the other codes are exactly the same as the first method. The disadvantage of the hash method is that there is a # (ugly) in the address, and the advantage is that it has excellent compatibility. #The following things belong to the foreground resources and will not be sent to the server.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Fetch","slug":"React/D04 Fetch","date":"2021-12-23T12:46:54.000Z","updated":"2022-11-12T04:14:18.930Z","comments":true,"path":"2021/12/23/React/D04 Fetch/","link":"","permalink":"https://redre4per.github.io/2021/12/23/React/D04%20Fetch/","excerpt":"","text":"Send request method classification xhr class: ajax (native xhr, troublesome), jQuery (third party, may generate callback hell), axios (third party) fetch: (built-in non-third-party, promise style) Features of fetch XMLHttpRequest does not conform to the separation of concerns (separation of concerns, that is, to split a complex thing). Official document fetch() splits the request sent by xhr into two steps. The first step is to contact the server, and the second step is to return data from the server. Fetch usage Full writing Simple usage (not optimized) 123456789101112//The first step: verify whether the server is in an active state and can establish a connection.fetch(url, options).then(function(response) &#123; // Contacting the server was successful. response returns a server status object, which contains the header. (but no data is returned) return response.json //Return data, go to the next then() processing&#125;, function(error) &#123; // Failed to contact the server. The failure condition is very special: if the requested data server does not have it, the server will not be contacted to fail (but there will be 404 in the header); //If the entire browser is offline, the contact server failure will only be displayed return new Promise(()=&gt;&#123;&#125;); //Interrupt the Promise chain&#125;).then( response =&gt; &#123;console.log(&#x27;Get data successfully&#x27;, response)&#125;, error =&gt; &#123;console.log(&#x27;Failed to get data&#x27;, error)&#125;) There is a json method (response.json) on the prototype object of the response response object, the return value is a promise instance, and the data is in this instance object. If the contact with the server is successful, the data acquisition is successful, the status of the instance is successful, and the successful data is saved in it; If the contact with the server is successful, Failed to obtain data, the status of the instance is failure, and the reason for the failure is stored in it. To get this data, it is best to use chained calls and process it in the next then(). return new Promise(); is used to break the Promise chain. If you don’t write this code, there will be no return value when contacting the server fails, that is, it will return undefined by default, and then process it according to success; if this code is written to return an error, it will go to the next error branch in the promise chain, affecting the efficiency, it is better to interrupt. Code can be optimized with catch to handle errors uniformly. (preliminary optimization) 1234567fetch(url, options).then(function(response) &#123; return response.json&#125;).then( response =&gt; &#123;console.log(&#x27;Get data successfully&#x27;, response)&#125;,).catch( error =&gt; &#123;console.log(error);&#125;) Use await async to optimize fetch code .then() can specify a success callback and a failure callback. But when .then() does not specify a failure callback (like the previous code), there is no need to write .then(), and it is more appropriate to use await async. await cannot be used directly, you need to add async to the function closest to await: 12345search = async() =&gt; &#123; const response = await fetch(url, options) //wait for the successful result of fetch&#x27;s promise instance: responseconst data = await response.json() //The second step is to get the dataconsole. log(data);&#125; await can only wait for a successful result, If you want to catch an exception, use try&#123;&#125; catch()&#123;&#125;. Code that might produce errors is written inside try&#123;&#125;: 123456789search = async() =&gt; &#123; try &#123; const response = await fetch(url, options)const data = await response.json()console. log(data); &#125; catch(error)&#123; console.log(&#x27;request error&#x27;, error) &#125;&#125; fetch use case A case retrofit for React.4.2 with fetch. (when not using await async) 12345678910fetch(`/api1/search/users2?q=$&#123;keyWord&#125;`).then( response =&gt; &#123; console.log(&#x27;Contact the server successfully&#x27;); return response.json();&#125;).then(response =&gt; &#123; console.log(&#x27;Get data successfully&#x27;, response);PubSub. publish(&#x27;My message&#x27;, &#123;isLoading: false, user: data. items&#125;)&#125;,).catch(error =&gt; &#123; PubSub. publish(&#x27;My message&#x27;, &#123;isLoading: false, err: error. message&#125;)&#125;) When using await async 12345678910search = async() =&gt; &#123; try &#123; const response = await fetch(`/api1/search/users2?q=$&#123;keyWord&#125;`)const data = await response.json()PubSub. publish(&#x27;My message&#x27;, &#123;isLoading: false, user: data. items&#125;) &#125; catch(error)&#123; console.log(&#x27;request error&#x27;, error); PubSub. publish(&#x27;My message&#x27;, &#123;isLoading: false, err: error. message&#125;) &#125;&#125;","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"PubSub","slug":"React/D03 PubSub","date":"2021-12-21T11:02:37.000Z","updated":"2022-11-12T03:35:19.720Z","comments":true,"path":"2021/12/21/React/D03 PubSub/","link":"","permalink":"https://redre4per.github.io/2021/12/21/React/D03%20PubSub/","excerpt":"","text":"Passing values (communication) between sibling components Passing values between parent and child components: With the help of props, the child passes a function to the parent with props, and the child component calls the function and passes parameters. Passing values between sibling components: message subscription and publishing mechanism. PubSub is not only suitable for passing values between sibling components, but also for passing values between any components, especially for passing messages in multi-level hierarchical components, because it doesn’t matter where the components are. Message Subscription and Publishing Tool library: PubSubJS (PubSub is the abbreviation of Publish and Subscribe) Download: npm install pubsub-js --save Steps for usage: Introduce import PubSub from &#39;pubsub-js&#39; (the repository name of a technology is different from the npm name, because of the npm specification) Subscribe PubSub.subscribe&#123;&#39;delete&#39;, function(data)&#123;&#125;&#125;; Publish a message PubSub.publish(&#39;delete&#39;, data) PubSub use Subscribe messages in components that need to receive data 1234var mySubscriber = function(msg, data)&#123; //Parameter 1 is the message name (useless, available _, placeholder), and parameter 2 is the data. console.log(msg, data)&#125;var token = PubSub.subscribe(&quot;My Topic&quot;, mySubscriber); //Parameter 1 is the message name, and parameter 2 is the callback function that will be called when someone publishes a message. Assigned to token is used when unsubscribing later. mySubscriber is usually written directly in the PubSub.subscribe method, and is usually subscribed after the component is mounted. After the code is simplified: 12345componentDidMount()&#123; let token = PubSub.subscribe(&quot;My Topic 1&quot;, (_, data) =&gt; &#123; console.log(data); &#125;)&#125; Cancel subscription: usually before the component is unloaded. 123componentWillUnmount()&#123; PubSub.unsubscribe(token)&#125; Post a message in the component that generates the data 1PubSub.publish(&quot;My Topic&quot;, &#x27;hello world!&#x27;); //Parameter 1 is the message name, parameter 2 is the sent data, usually &#123;&#125;","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Github searching case study","slug":"React/D02 Github searching case","date":"2021-12-20T22:12:15.000Z","updated":"2022-11-12T03:30:32.851Z","comments":true,"path":"2021/12/21/React/D02 Github searching case/","link":"","permalink":"https://redre4per.github.io/2021/12/21/React/D02%20Github%20searching%20case/","excerpt":"","text":"Case introduction In this case, there is a search bar above and a display bar below. After searching, the user’s avatar and username will be displayed. Click on the avatar to enter the user’s homepage. Before searching, the display area should display Waiting for Search; Loading should be displayed during the search, the user avatar should be displayed when the search is successful, and the error reason should be displayed when the search fails. ideas In terms of subcomponents, this case should be divided into two components: the upper search component and the lower display component. The display of the picture and the realization of clicking the picture to enter the link: these two functions have nothing to do with JS, and should use the syntax of html, as follows 123&lt;a ref=&quot;userlink&quot; href=&#123;user.html_url&#125; target=&quot;_blank&quot;&gt;&lt;img src=&#123;user.avatar_url&#125; alt=&quot;user_Avatar_picture&quot; style=&#123;&#123; width: &#x27;100px&#x27; &#125;&#125; /&gt;&lt;/a&gt; Implementation (using props to pass value) App.js components 1234567891011121314151617export default class App extends Component &#123; state = &#123; users: [], //Pay attention to an empty array here, otherwise the value will be empty when there is no search, and the rendering will go wrong. isInitial: true, isLoading: false, err: &#x27;&#x27; //Pay attention here to initialize a null character &#x27;&#x27;, in the Boolean judgment, the null character is false. &#125; getData = (stateObj) =&gt; &#123; this.setState(stateObj) //Here is to receive multiple properties of state. The parameters of the callback are all &#123;key:value&#125; &#125; //form, so it can directly satisfy the setState syntax setState(&#123;&#125;). render() &#123; return (&lt;div&gt; &lt;Search getData=&#123;this. getData&#125; /&gt; &lt;List &#123;...this.state&#125; /&gt; &#123;/*Here is to use object destructuring assignment to pass all the properties in the state, */&#125; &lt;/div&gt; ) &#123;/*But notice that there is no XXX=&#123;&#125;. */&#125; &#125;&#125; Search.jsx component 1234567891011121314151617181920export default class List extends Component &#123; sendRequest = () =&gt; &#123; this.props.getData(&#123; isInitial: false, isLoading: true, users: [] &#125;) axios.get(`https://api.github.com/search/usersq=$&#123;this.input1Node.value&#125;` ).then(response =&gt; &#123; this.props.getData(&#123; isLoading: false, users: response.data.items &#125;) &#125;, reason =&gt; &#123; this. props. getData(&#123; isLoading: false, err: reason. message &#125;) &#125;) //Note here that err can only be reason.message, not reason. Because reason is an object, an error will be reported. &#125; //In addition, call getData() and add &#123;key:value&#125; to say that because the result is directly used for setState(), this can be written directly//Merge into the state, which meets the syntax requirements. render() &#123; return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&#123;c =&gt; this.input1Node = c&#125; /&gt; &lt;button onClick=&#123;this.sendRequest&#125;&gt;click to search&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; List.jsx component 1234567891011121314151617export default class List extends Component &#123; render() &#123; return (&lt;div&gt;&#123;this.props.isInitial? &lt;div&gt;Please input text&lt;/div&gt; : //ternary operator instead of if this.props.isLoading? &lt;div&gt;...Loading&lt;/div&gt; : this.props.err? &lt;div&gt;&#123;this.props.err&#125;&lt;/div&gt; : this.props.users.map((user) =&gt; &#123; return &lt;div key=&#123;user.id&#125;&gt; &lt;div&gt;&#123;user.login&#125;&lt;/div&gt; &lt;a ref=&quot;userlink&quot; href=&#123;user.html_url&#125; target=&quot;_blank&quot;&gt; &lt;img src=&#123;user.avatar_url&#125; alt=&quot;avatar&quot; style=&#123;&#123; width: &#x27;100px&#x27; &#125;&#125; /&gt; &lt;/a&gt; &lt;/div&gt;&#125;) &#125; &lt;/div&gt;) &#125;&#125; pay attention Use a callback function to get all the data of setState from the value passed from the child to the parent 1getData = (stateObj) =&gt; &#123;this.setState(stateObj)&#125; 1this.props.getData(&#123; isLoading: false, users: response.data.items &#125;) The principle is to use the syntax of setState(&#123;key: value&#125;) to directly wrap the value passed by the function into &#123;key: value&#125; format and pass it to setState(). I used setState(&#123;...stateObj&#125;) successfully when I coded it myself before, but this is redundant code. Just like […arr], the object is unpacked and repackaged into an object. Pass props in batches, and pass the properties in the state as props, apply 1&lt;List&#123;...this.state&#125;/&gt; Note that the normal way to pass in a single props is users=&#123;this.state.users&#125; , and there is no user= for batch pass in. Ternary operator instead of if In JSX, &#123;&#125; can only be a statement and not if, so use the ternary operator instead. condition? a: replaces the if statement. : is equivalent to else() in the original if statement. Axios returns error.message instead of error If you use error, it will always report an error: Objects are not valid as a React child. This error means that in JSX &#123;&#125; must be string or array, but not object . The error returned by Axios is an object that cannot be rendered to the page through JSX (but can be displayed in the Console), so only error.message can be used. message Do not misspell massage.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Ajax & CORS in React","slug":"React/D01 Ajax and CORS in React","date":"2021-12-19T09:13:37.000Z","updated":"2022-11-12T03:24:16.336Z","comments":true,"path":"2021/12/19/React/D01 Ajax and CORS in React/","link":"","permalink":"https://redre4per.github.io/2021/12/19/React/D01%20Ajax%20and%20CORS%20in%20React/","excerpt":"","text":"Ajax requests in React React needs to integrate a third-party ajax library or package it yourself. Generally use axios. Reason for Proxy cross domain If the proxy is not configured, cross-domain issues will occur (No ‘Access-Control-Allow-Origin’ header…). The reason for the cross-domain is that the address of the Client is http://localhost:3000 and the address of the server is http://localhost:5000 , so the ajax request is not allowed. In addition, the request can be sent out when cross-domain (the server can receive the request), but the ajax engine prevents the data from being returned when it comes back. Solve cross-domain in React scaffolding Scaffolding proxy is a middleman (tiny server), it is opened on port 3000, when Client (3000) sends a request to Server (5000), it first sends the request to The proxy intermediary (3000) is established, and then the proxy intermediary (3000) forwards the request to the Server (5000). When the Server (5000) returns the data, the agent intermediary (3000) receives the data first, and then forwards it to the Client (3000). Although the proxy middleman (3000) is opened on port 3000, it does not use the ajax engine. Because the essential problem of cross-domain is that the ajax engine blocks the response, and the intermediary without the ajax engine has no cross-domain problem, and the same-origin policy does not limit it. Scaffolding proxy configuration There are two ways to configure proxies in React. Global proxy (single server) In the package.json file, add the proxy attribute at the end of the file. The key value is the address to which the request is to be forwarded, just write the port number. Do not write specific &#x2F; items, such as &#x2F;students, it will cause the address to be dead. After configuration, all requests sent to 3000 in the client will be forwarded to 5000. Note here that the scaffolding needs to be restarted after setting. 12&#125;,&quot;proxy&quot;:&quot;http://localhost:5000&quot; After configuration, the Client code must only send requests to port 3000. 12345678910111213141516171819202122232425262728293031323334353637383940414243 getStudentData = () =&gt; &#123; axios.get(&#x27;http://localhost:3000/students&#x27;).then( //Note that this is for 3000 response =&gt; &#123;console.log(response.data);&#125;, error =&gt; &#123;console.log(error);&#125; ) &#125; `` &lt;br/&gt; Note that not all requests sent via http://localhost:3000 are forwarded to the Server (5000). If the item followed by 3000/request is the file under the &lt;font color=&#x27;red&#x27;&gt;public folder&lt;/font&gt; of this project, such as http://localhost:3000/index.html, it will get the public file . &lt;font color=&#x27;red&#x27;&gt;This is because the public folder is the root path of 3000 in http://localhost:3000. &lt;/font&gt;Some resources in 3000 will not be forwarded to 5000 by the agent. &lt;br/&gt;2. &lt;font color=&#x27;green&#x27;&gt;Multi-Server Agent&lt;/font&gt; There is a problem with a single-server proxy, because only one proxy server address can be configured. If the project is to get data from different servers, configuring a proxy cannot meet the needs. Before configuring, make sure there is no proxy configuration in package.json. &lt;br/&gt; &lt;font color=&#x27;red&#x27;&gt;Configuration method: Create the setupProxy.js file in the src folder (the file name cannot be changed). &lt;/font&gt; The code in the file cannot use ES6, but use CJS. Because this file is scaffolded into webpack, which is node.js syntax. (The code does not need to be mastered) &lt;br/&gt; ```javascript const proxy = require(&#x27;http-proxy-middleware&#x27;) //This package has been downloaded when the react scaffold is initialized. // The global proxy is just a shorthand version of it module.exports = function(app)&#123; app.use( proxy(&#x27;/api1&#x27;,&#123; //parameter 1, when a request with this prefix is encountered, the configuration of the proxy will be triggered target:&#x27;http://localhost:5000&#x27;, //To whom the request is forwarded changeOrigin:true, //Let the server know exactly where the request came from. The default is false, and it is changed to true pathRewrite:&#123;&#x27;^/api&#x27;:&#x27;&#x27;&#125; //Key-value pair, the key name is the prefix to be replaced, and the key value is empty after the replacement (required) &#125;), proxy(&#x27;/api2&#x27;,&#123; target:&#x27;http://localhost:5001&#x27;, //Second server changeOrigin:true, pathRewrite:&#123;&#x27;^/api&#x27;:&#x27;&#x27;&#125; &#125;), ) &#125; proxy() accepts two parameters. The first parameter is the path, that is, if the request in the project contains this path, it will be forwarded to the specified server. The second parameter is an object, the forwarding target server and configuration. The pathRewrite:&#123;&#39;^/api&#39;:&#39;&#39;&#125; in the second parameter is to fix the path where the client sends the request. In parameter 1, the proxy sets the identification path, so the address requests sent by the Client to the target server all have &#x2F;api1 (to allow the proxy to identify the server to be forwarded). However, after adding the identification path &#x2F;api, the request address is wrong. pathRewrite:&#123;&#39;^/api&#39;:&#39;&#39;&#125; can replace the identification path &#x2F;api in the request address (after locating the forwarding server) with empty, so the address can be repaired to the server address. The changeOrigin:true, in the second parameter is used to control the value of the Host field in the request header received by the server. The Host field identifies where the request is sent from. Without adding changeOrigin:true,, the Host obtained by the server is 3000, and the data cannot be obtained if the server is strictly restricted. After adding changeOrigin:true,, the Host obtained by the server is 5000. Therefore, this configuration is generally added. Also note that every time you modify the configuration proxy file or modify the server file, you must restart the scaffolding&#x2F;server. Axios request code should be written as: 123456789101112getStudentData = () =&gt; &#123; axios.get(&#x27;http://localhost:3000/api1/students&#x27;).then( //Identify the path api1 response =&gt; &#123;console.log(response.data);&#125;, error =&gt; &#123;console.log(error);&#125; )&#125;getCarData = () =&gt; &#123; axios.get(&#x27;http://localhost:3000/api2/cars&#x27;).then( //Identify the path api2 response =&gt; &#123;console.log(response.data);&#125;, error =&gt; &#123;console.log(error);&#125; )&#125; It means that if there is no students data in the request sent to localhost:3000 (local), go to the proxy configured by api1. Simplified request address If the client location (3000) is the same location as the destination location of the request, you can omit http://localhost:3000. Note here that the reason why the 3000 address sends a request to the 3000 address is that the proxy is set, and the address sent to 3000 is transferred to 5000. 12axios.get(&#x27;http://localhost:3000/api1/search/user?q=$&#123;keyWord&#125;&#x27;).then() //Before simplificationaxios.get(&#x27;/api1/search/user?q=$&#123;keyWord&#125;&#x27;).then() //simplified","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Spread operator","slug":"JavaScript/ES6/3 Spread operator","date":"2021-12-08T19:50:51.000Z","updated":"2023-09-11T01:15:52.318Z","comments":true,"path":"2021/12/09/JavaScript/ES6/3 Spread operator/","link":"","permalink":"https://redre4per.github.io/2021/12/09/JavaScript/ES6/3%20Spread%20operator/","excerpt":"","text":"Spread operator … (array) The spread operator can split an array or array-like structure into a comma-separated sequence of arguments. 12const arr = [1, 2, 3];console.log(...arr) //result is 1 2 3 Note that the spread operator unpacks [ ] not a value, but a sequence. That is, something like var a =...obj; is wrong, because there is no such thing as var a = 1, 2, 3;. But the spread operator can be used for destructuring assignments. Use of spread operator: Pass a sequence of arguments to a function 123456let arr = [1, 2, 3];function getMax(a, b, c)&#123; console.log(b);&#125;getMax(...arr);Math.max(...arr); Merging of arrays 12345const arr1 = [1, 2];const arr2 = [3, 4];const arr3 = arr1.concat(arr2) //The merge method in ES5. The result is [1, 2, 3, 4]const arr4 = [...arr, ...arr2] //The merge method in ES6. The result is [1, 2, 3, 4] Copy of array 123const arr1 = [1, 2, 3, 4];const arr2 = [...arr1];console.log(arr2); //result is [1, 2, 3, 4] Note that if the elements in the array are reference type elements, then this copy is also a shallow copy. If not, it is a deep copy. Convert pseudo array to real array 12const divs = document.querySelectorAll(&#x27;div&#x27;);console.log(divs); //The result is an object because it is a pseudo-array. 123const divs = document.querySelectorAll(&#x27;div&#x27;);const divArr = [...divs];console.log(divArr); //The result is a real array: [div, div, div] The arguments parameter can also be converted to a true array using this method. But since there are rest parameters, this method is unnecessary. Spread operator … (object) Merge two objects 12345678910let obj1 = &#123; name:&#x27;Tom&#x27;, age:18&#125;let obj2 = &#123; gender:&#x27;male&#x27;, hobby:&#x27;football&#x27;&#125;let obj3 = &#123;...obj1, ...obj2&#125;;console.log(obj3) //result &#123;name: &#x27;Tom&#x27;, age: 18, gender: &#x27;male&#x27;, hobby: &#x27;football&#x27;&#125; Add attributes to element objects Native JS approach 1234567891011var obj = &#123; &#x27;id&#x27;:&#x27;Hello&#x27;, &#x27;className&#x27;:&#x27;box&#x27;, &#x27;style&#x27;:&#x27;width:200px; height:200px; background:red&#x27;&#125;let app = document.getElementsByTagName(&#x27;div&#x27;)[0]for(let key in obj)&#123; app[key]=obj[key] //app[key] is to be distinguished from app.key, [key] is a variable and .key is a property name. That is, app[key] is the key in the key-value pair. //[key] of obj[key] is the value in the key-value pair. It&#x27;s not the key because the obj object is in the for in loop.&#125; Spread operator method 1234567var obj = &#123; &#x27;id&#x27;:&#x27;Hello&#x27;, &#x27;className&#x27;:&#x27;box&#x27;, &#x27;style&#x27;:&#x27;width:200px; height:200px; background:red&#x27;&#125;let app = document.getElementsByTagName(&#x27;div&#x27;)[0]app.innerHTML=&quot;&lt;div &quot;+...obj+&quot;&gt;&lt;/div&gt;&quot; //Note here...obj can only be used in React.","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"ES6","slug":"JS-TS/ES6","permalink":"https://redre4per.github.io/categories/JS-TS/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://redre4per.github.io/tags/ES6/"}]},{"title":"Arrow Functions, Rest params","slug":"JavaScript/ES6/2 Arrow function, rest params","date":"2021-12-06T07:40:12.000Z","updated":"2023-09-11T01:16:00.378Z","comments":true,"path":"2021/12/06/JavaScript/ES6/2 Arrow function, rest params/","link":"","permalink":"https://redre4per.github.io/2021/12/06/JavaScript/ES6/2%20Arrow%20function,%20rest%20params/","excerpt":"","text":"Extensions to Functions: Arrow Functions &#x3D;&gt; 123let fn = function(m)&#123;return m&#125;; //ordinary functionlet fn = (m) =&gt; &#123;return m&#125; //complete writing of arrow functionlet fn = m =&gt; m // shorthand arrow function Arrow function writing The complete writing of arrow function: just change the function before the parameter (m) in the ordinary function to the &#x3D;&gt; after the parameter. (the first and second lines of the code) Arrow functions only have the declaration method of function literals, not the declaration method of function fn()&#123;&#125;; . Arrow function shorthand: If the arrow function has only one parameter, you can omit (). () cannot be omitted without arguments. If you want to return an expression (data) directly in an arrow function, you can omit &#123;return&#125; directly. Note that return AND &#123;&#125; must be omitted together. Omitting &#123;return &#125; is generally used when a function does not perform an operation and only wants to return a value. If there are other operations (such as conditional judgment) in &#123;&#125;, don’t save it. 123456//correct waylet fn = m =&gt; m;let fn = m =&gt; 100;let fn = m =&gt; m + 5;//wrong waylet fn = m =&gt; &#123;m + 5&#125;; If you want to return an object &#123;&#125;, there will be ambiguity, because the program parsing does not know whether it is the object &#123;&#125; or the function body &#123;&#125;. Therefore, when returning an object directly, you need to add a () outside, such as: 1let fn = () =&gt; (&#123;name:&#x27;Tom&#x27;&#125;) Arrow Function Features This pointer is static, this always points to the value of this in the scope where the function is declared. The this of a normal function points to the object on which the function was called. example: 12345678910var x = 100;var obj = &#123; x:10 getX: function()&#123; console.log(this.x) &#125;&#125;obj.getX() //10 The function called by obj, this points to obja = obj.get;a(); //100 function called by window, this points to window In an arrow function, this points to the object where the function is defined, and will not change due to changes in the caller. 12345678910var x = 100;var obj = &#123; x:10 getX = () =&gt; &#123; console.log(this.x) &#125;&#125;obj.getX() //10 this points to obja = obj.get;a(); //10 this points to obj Arrow functions cannot instantiate objects as constructors 123456let Person = (name, age) =&gt; &#123; this.name = name; this.age = age;&#125;let me = new Person (&#x27;Tom&#x27;, 30);console.log(me) //error Arguments variable cannot be used 1234let fn = () =&gt; &#123; console.log(arguments);&#125;fn(1, 2, 3); //error. ReferenceError: arguments is not defined Arrow function concept example 12345678910111213function Timer()&#123; this.s1 = 0; this.s2 = 0; //arrow function setInterval(() =&gt; this.s1++, 1000); //normal function setInterval(function()&#123; this.s2++; &#125;, 1000)&#125;var timer = new Timer()setTimeout(() =&gt; console.log(&#x27;s1: &#x27;, timer.s1), 3100); //3setTimeout(() =&gt; console.log(&#x27;s2: &#x27;, timer.s2), 3100); //0 When timer = new Timer(), all the code in Timer is executed, including the timer part. Note that the timer is executed directly instead of being bound to the Timer. The error-prone thing is that timers are methods of the window object, not the timer object. Therefore, the timer is created by the timer object when timer = new Timer() (because the code in the constructor Timer is not executed until the Timer is called). This leads to the fact that when an arrow function is used, the this in the arrow function points to the creator timer of the function; and the caller of the timer is window. Therefore, in the case of non-arrow functions, this in the timer will point to the caller window of the timer. 12var fn = () =&gt; &#123;console.log(this)&#125;;fn() The creator and caller of the arrow function in this example are both window. Rest parameter Used in place of arguments parameter in native JS. The rest parameter can get all the actual parameters of rest. arguments: The result is an object. 1234function data()&#123; console.log(arguments);&#125;data(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;); rest: result is an array rest is declared as …args. 1234function data(...args)&#123; console.log(args);&#125;data(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;); Therefore, the rest parameters can use array methods, such as filter, some, every, map, which improves flexibility. The rest parameter must be placed at the end of the parameter. 1234567891011121314function fn(a, b, ...args)&#123; console.log(a); //result is 1 console.log(b); //The result is 2 console.log(args); //results are 3, 4, 5, 6&#125;fn(1, 2, 3, 4, 5, 6);//if...args put forwardfunction fn(a, ...args, b)&#123; console.log(a); console.log(b); console.log(args);&#125;fn(1, 2, 3, 4, 5, 6); // result error Function default parameters 1234function sum(a = 1, b = 1) &#123; return a + b&#125;sum() When the number of parameters passed in is not enough, or when undefined is passed in, the default parameter value is used instead.","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"ES6","slug":"JS-TS/ES6","permalink":"https://redre4per.github.io/categories/JS-TS/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://redre4per.github.io/tags/ES6/"}]},{"title":"Let, Const, Destructuring assignment","slug":"JavaScript/ES6/1 let const destructuring assignment","date":"2021-12-04T04:20:19.000Z","updated":"2023-09-11T01:15:58.096Z","comments":true,"path":"2021/12/04/JavaScript/ES6/1 let const destructuring assignment/","link":"","permalink":"https://redre4per.github.io/2021/12/04/JavaScript/ES6/1%20let%20const%20destructuring%20assignment/","excerpt":"","text":"Declares variable a by ‘let’ let is the new way to declare variables in ES6, replacing var. 1234let a;let b, c, d;let e = 100;let f = 521, g = &#x27;iloveyou&#x27;, h = []; var: allows repeated declarations, declaration promotion, and automatic declaration. let: No duplicate declarations allowed, no declaration hoisting. Only valid in block scope. Temporary dead zone. Block scope: A &#123;&#125; is a block scope. Common: if, for, and functions. ​ Notice: &#123;&#123;&#125;&#125; This kind of nested block-level scope, variables declared by let in the outer &#123;&#125; are also valid in the inner &#123;&#123;&#125;&#125;. This is because the inner &#123;&#123;&#125;&#125; is also part of the outer &#123;&#125; block scope. (Global variables are also valid in the local scope) In the for loop, let is written outside &#123;&#125;, such as for(let a=0; a&lt;n; a++)&#123;&#125;, but due to the internal processing of the for loop, the element declared by let is actually in the The following &#123;&#125; block scope is defined. And, every time the loop is looped, a new let a (new value) is generated, and a new &#123;&#125; block-level scope is also generated. Therefore, for loops have several &#123;&#125; block scopes a few times. Example 1: var 1234567var a=[];for(var i=0; i&lt;10; i++)&#123; a[i] = function()&#123; console.log(i) &#125;;&#125;a[6]()//The output is 10. This is because var a is a global variable, i will increase every time you run, and finally add to 10, that is, output 10. Example 2: let 1234567var a=[];for(let i=0; i&lt;10; i++)&#123; a[i] = function()&#123; console.log(i) &#125;;&#125;a[6]()//The output is 10. Because let generates 10 &#123;&#125; block scopes, the i declared by each let is only valid within its block scope (not globally) Temporary dead zone: let-declared variables are automatically bound to the current block-level scope. That is, if there is a let declaration variable in a block-level scope, it can only be used in this block-level scope, and external variables with the same name cannot be used. Example: 12345var tmp = 123;if(true)&#123;tmp = &#x27;abc&#x27;; let tmp;&#125;//The output is an error. Because tmp is not declared. ​ const declare constants A constant declared by const cannot be modified, and is used to prevent the constant from being accidentally changed. The initial value must be assigned when const is declared. Const constants generally use uppercase (unspoken rule). const can be used for: regular expressions, username&#x2F;password, elements of document.getElementBy… during DOM manipulation, etc. Another code style is to use const whenever indeterminate. For element modification of arrays and objects, it does not count as constant modification, and no error will be reported. Because the address of the constant has not changed. 123const TEAM = [&#x27;Ali&#x27;,&#x27;Neil&#x27;,&#x27;Tom&#x27;,&#x27;Tony&#x27;];TEAM.push(&#x27;Ben&#x27;); //correct syntaxTEAM = 100; //Error Array destructuring assignment Destructuring assignment can be used to declare multiple variables. The syntax is: 1let [a, b, c] = [1, 2, 3] // same as let a=1; let b=2; let c=3; That is, the left side of let is an array of variables, the right side is an array of data, and the structures on both sides should be the same. Notice: If the number of variables and data on both sides of let do not match, match them one by one from left to right. A variable whose destructuring failed is undefined. Commas can take place. 1let [ , , a] = [1, 2, 3] //a=3 In the case of nesting in destructuring assignment, as long as the nested structure on both sides is the same, it can be successfully matched. Destructuring assignment can be used to exchange data between two variables, such as: 1[x, y] = [y, x] Object destructuring assignment 12345678const stu1 = &#123; name:&#x27;tom&#x27;; age:18; ability: function()&#123; console.log(&quot;I can eat&quot;); &#125;&#125;let &#123;name, age, ability&#125; = stu1; continuous destructuring assignment 1const &#123;keyWordElement:&#123;value&#125;&#125; = this //You can get the value of this.keyWordElement.value, that is, multiple properties Multiple properties can be assigned with continuous destructuring, but note that the intermediate property keyWordElement is not defined here. Destructuring assignment and renaming 12345//method 1let obj = &#123;a:&#123;b:1&#125;&#125;;const &#123;a:&#123;b:data&#125;&#125; = obj; // old name: new name//method 2const &#123;keyWordElement:&#123;value:keyWord&#125;&#125; = this //some experienced programmers will write this Extensions to Strings: Template Strings &#96;&#96; to write strings, allowing newlines. Write variables in ${} without splicing. Shorthand for object ES6 allows variables and functions to be written directly inside curly brackets as object properties and methods 123456789101112let name = &#x27;Web age&#x27;;let change = function()&#123; console.log(&#x27;I can change you&#x27;);&#125;const school = &#123; name, // same as name: name change, //equivalent to change: change improve()&#123; //same as improve: function()&#123;&#125; console.log(&#x27;I can improve your skills&#x27;); &#125;&#125;","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"ES6","slug":"JS-TS/ES6","permalink":"https://redre4per.github.io/categories/JS-TS/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://redre4per.github.io/tags/ES6/"}]},{"title":"setState()","slug":"React/B04 setState()","date":"2021-11-30T02:21:47.000Z","updated":"2022-11-12T03:03:17.404Z","comments":true,"path":"2021/11/30/React/B04 setState()/","link":"","permalink":"https://redre4per.github.io/2021/11/30/React/B04%20setState()/","excerpt":"","text":"Data in React state cannot be changed directly The code in the example is to directly change (wrong) 1234changeWeather()&#123; const isHot=this.state.isHotthis.state.Hot=!isHot //Error!console.log(this.state.isHot)&#125; The immediate consequence of the change is that the console.log output can toggle between true and false, but the page is not re-rendered. Here you can check the status from inspect &#x3D;&gt; Components, and find that isHot in the status is always the initial value. setState() The state state cannot be changed directly, it needs to be changed with the help of a built-in API: setState(). setState() is an asynchronous update. setState() is available in the React.Components prototype through the inheritance chain. An object is to be written in setState(), which is the same as state. 1234changeWeather()&#123;const isHot=this.state.isHotthis.setState(&#123;isHot : ! isHot&#125;)&#125; At this time, the state in inspect&#x3D;&gt;Components will switch. The state update action of setState() is merged rather than replaced When the state is updated, the object in setState() will not replace the object in the state as a whole, but only modify the part with the same name. Times of code executions in class components The constructor constructor(props) is only executed once, the time ReactDOM.render is called when the instance is created. render is called 1+n times. 1 is the time it was initialized, and n is the number of state updates. changeWeather(): It is called several times when the click event is triggered several times. setState is in changeWeather() . Therefore, React will re-call render once whenever the state is modified via setState. Components are also known as state machines. Shorthand for state and function The this in constructor(props) and render() in the class component points to the class component instance. Because the this in the constructor itself is the instance object of the class, and the this of render() is also the instance object because react creates an instance of the class when ReactDOM.render(&lt;component tag/&gt;...) is executed. And it is called by instance.render(). There is a problem with the this pointer in the custom function, because the custom function is not called through instance.custom function, but called through event callbacks (custom functions are almost all called through event callbacks). Code before simplification 123456789101112131415class Weather extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123;isHot:false,wind:&#x27;breeze&#x27;&#125; this.changeWeather = this.changeWeather.bind(this) //*** &#125; render()&#123; const &#123;isHot,wind&#125; = this.state return &lt;h1&gt;onClick=&#123;this.changeWeather&#125;Today&#x27;s weather &#123;isHost?&#x27;hot&#x27;:&#x27;cool&#x27;&#125;,&#123;wind&#125;&lt;/h1&gt; &#125; changeWeather()&#123; const isHot = this.state.isHot this.setState(&#123;isHot:!isHot&#125;) &#125;&#125; Simplified way Assignment statements can be written directly in the class, such as a=1, instead of this.property name=fixed value written in the constructor. This code is to add an attribute to the instance object of the class. If the initial value of this property is passed in from outside, it must be written in the constructor. Therefore, state initialization can be written outside the constructor. 1state = &#123;isHot: false, wind: &quot;breeze&quot;&#125; this.changeWeather = this.changeWeather.bind (this) This statement can be omitted. The purpose of this statement is to change the point of this and copy the changeWeather method on the class prototype object to the instance attribute changeWeather. After being omitted, the changeWeather method does not exist on the function prototype object, but only the instance attribute has changeWeather. And the value of this property is an anonymous function. Note that it is an error to omit the method changeWeather=function()&#123;&#125;. This is because it just changed the changeWeather to another place, and it still reports an error after clicking (because there is no .bind(this) to change the direction). So the correct way is arrow functions. The arrow function does not have its own this. When using this in the arrow function, it will find the this of the outer function of the arrow function to use. Therefore, this in the arrow function is the instance object of the component. 1234changeWeather = () =&gt; &#123; const isHot = this.state.isHot this.setState(&#123;isHot:!isHot&#125;)&#125; When writing a custom method in a class component in the future, it must be written in the form of an assignment statement + an arrow function. It is impossible not to write an assignment statement, and a syntax error will be reported. Because if you don’t write assignment, you are putting the function on the class prototype. There is no syntax that can put the arrow function on the class prototype. 1changeWeather() =&gt; &#123;&#125; //Wrong way of writing abbreviated code 12345678910111213class Weather extends React.Component&#123; state = &#123;isHot:false,wind:&#x27;breeze&#x27;&#125; changeWeather = () =&gt; &#123; const isHot = this.state.isHot this.setState(&#123;isHot:!isHot&#125;) &#125; render()&#123; const &#123;isHot,wind&#125; = this.state return &lt;h1&gt;onClick=&#123;this.changeWeather&#125;Today&#x27;s weather &#123;isHost?&#x27;hot&#x27;:&#x27;cool&#x27;&#125;,&#123;wind&#125;&lt;/h1&gt; &#125;&#125;","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Class components","slug":"React/B03 Class components","date":"2021-11-28T12:04:18.000Z","updated":"2022-11-12T02:49:43.476Z","comments":true,"path":"2021/11/28/React/B03 Class components/","link":"","permalink":"https://redre4per.github.io/2021/11/28/React/B03%20Class%20components/","excerpt":"","text":"Create class components If the class defines the component, the class must inherit React’s built-in class: React.Component 1class MyComponent extends React. Component&#123;&#125; Among them, the constructor can be omitted. render() must be written, and the return value of render()&#123;return&#125; must also be written. If returning a multi-level structure, it is best to wrap it with (). 12345class MyComponent extends React. Component&#123; render()&#123; return &#125;&#125; Location of render()&#123;&#125; render is placed on the prototype object of the class for use by the instance. Instances of class components are created by React.render(&lt;MyComponent/&gt;......). What happens after executing ReactDOM.render( &lt;MyComponent/&gt; ......)? When executing this code, React parses the component tags and finds the MyComponent component. Later, it is found that the component is defined using a class, and then an instance of the class is newly created, and the render() method on the prototype is called through the instance. Then, convert the virtual DOM returned by render into real DOM, and then render it on the page. The this in render() points to the instance object of the class. It can also be called an instance object of a class component. The props, refs, and state in the class component instance object are called the three major attributes of the component (instance). The context will also look at it. No other attributes are concerned. These attributes are obtained by inheritance. Simple components and complex components Simple components: components without state (functional components) Complex components: stateful components (class components) state state The state of the component drives the page. (Compared to Vue, Vue is a data-driven page) React puts the data in the state, and the change of the data will drive the display of the page. The state property is on the component instance object, not the class itself. State initialization The initialization of state should be written in the constructor (not shorthand). Because state is a property in the class, and modifying the property value must be written in the constructor (ES5). Shorthand in ES6. state can also be abbreviated outside the constructor. constructor(){} What arguments should it accept when it is not omitted (what to pass when new)? Class components are not new by themselves, but React.render helps us new. The official documentation in React states that props should be passed in, that is, constructor(props){}. It should be noted that props are written here because of syntax requirements. If not, the constructor will report an error. I will talk about it in detail later. Before simplified 12345678910class Weather extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123;isHot:true&#125; &#125; render()&#123; console.log(this); //this is the instance object of the class return &lt;h1&gt;Today&#x27;s weather is very &#123;this.state.isHost?&#x27;hot&#x27;:&#x27;cool&#x27;&#125;&lt;/h1&gt; //The ternary expression processes the state data &#125;&#125; After simplified 1234567class Weather extends React.Component&#123; state = &#123;isHot:true&#125; // Shorthand without writing a constructor (detailed in React.6.5) render()&#123; const &#123;isHot&#125; = this.state //Use destructuring and copying to take out the keys in the state, and then you can write it shorter. return &lt;h1&gt;Today&#x27;s weather is &#123;isHost?&#x27;hot&#x27;:&#x27;cool&#x27;&#125;&lt;/h1&gt; &#125;&#125; After initializing the state value, the state of the class component can be seen in the Components in the inspect. click event Event binding in native JS (three ways): .addEvent Listener(&quot;click&quot;, ()=&gt;&#123;&#125;) .onclick=()=&gt;&#123;&#125; &lt;button onclick=&quot;fn()&quot;&gt; The third one is recommended in React, which is to bind events directly in tags. (The first two can actually be used, but there are too many document operations, so it is not recommended). React rewrites all events in native JS, and uses the small camel form, that is, onclick is onClick in React. In the event of React, the listener cannot be a string &quot;&quot;, is different from native JS. Here it should be written as a variable form of &#123;&#125; . React events cannot be written directly onClick=&#123;fn()&#125;. This is because fn() means that the function is executed when the event is assigned a value, which is to return the of the function execution The value is directly assigned to onClick instead of executing the function after clicking. This is equivalent to the logic of the second event binding method in native JS. So write onClick=&#123;fn&#125;. this pointor problem (the click event writes the function body outside the class component) In the above click event, the function body of fn cannot be written outside the class component (such as below ReactDOM.render). This is because this in the function body points to undefined (Babel prohibits custom functions from pointing to window), but cannot point to the instance object of the class. Error analysis After writing this.state, an error may be reported: Cannot read property ‘state’ of undefined. means that state cannot be read on undefined. That is, in this.state, this points to undefined. In the same way, in a similar error report, you can directly find the a error in the a.b structure. What if you must write the function body outside the class and get the this pointing to the class instance? The idea here is to start with global variables. That is, the global variable let that, and then write that = this in the constructor of the class component. At this time, the outer-class function body can use that to point to the instance object. But this way of writing is unreasonable, because it is too cumbersome, and it will cause the code block of the class component to be scattered everywhere. This points to the problem (the function body is inside the class) Question 1: Where is the function changeWeather() placed in the class? is placed on the Weather prototype object. When changeWeather() is called from a Weather instance, the this in changeWeather() is the Weather instance. 123456class Weather extends React.Component&#123; constructor(props)&#123;... render()&#123;... changeWeather()&#123; console.log(this.state.isHot); &#125;&#125; Several wrong spellings in render() &lt;h1 onClick=&#123;changeWeather&#125;&gt; This will report an error changeWeather is not defined. This is because only the instance can call the function in the class, which can be found by writing this.changeWeather according to the logic. &lt;h1 onClick=&#123;this.changeWeather&#125;&gt; This will report an error cannot read property ‘state’ of undefined . This means that the left side of state is wrong again, that is, this points to undefined. What is the reason for this? (This error only occurs when the above code block is used. This problem does not occur when using non-constructor arrow functions) When calling changeWeather through the Weather instance, this in changeWeather is the Weather instance. But here changeWeather( ) is not called from the Weather instance. After binding the click event here, the heap address of this.changeWeather is directly bound to the click event of h1, similar to const x=p1.changeWeather in native JS. In this case, when h1 is clicked, the caller of changeWeather is not the Weather instance object, but the window. Therefore, since changeWeather is used as a callback of onClick, it is not called through an instance, but directly. All custom methods in the class have turned on strict mode locally, so they cannot point to window, but can only be undefined. Resolve this pointer The method in the example is used with &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;, that is to change the this point. Code is executed from right to left. this.changeWeather finds the changeWeather on the prototype object, and then bind turns this in the new function into the Weather instance object. This new function is then placed in the instance itself and named changeWeather. 12345constructor(props)&#123; super(props) //initialize state this.state = &#123;isHot:false&#125;; this.changeWeather = this.changeWeather.bind(this);&#125; That is, after writing this line of code, there is one more method on the instance object of Weather, which is called changeWeather. If it is not written, there is no such method on the instance object, only changeWeather on the prototype. When &lt;h1 onClick= &#123;this.changeWeather&#125;&gt; is clicked, the changeWeather here is not the one on the prototype, but the changeWeather on the instance itself. At this time, according to the search order, the method with the same name is used first on itself. Array data in state state = &#123;todoList:[]&#125; state = &#123;todoList:[&#123;&#125;,&#123;&#125;,&#123;&#125;]&#125; It should be noted here that the state in state can only be written as {} object, and the data in the object are all key-value pairs, written as key: value. If key: value is written as key&#x3D;value, an error will be reported, that is, Parsing error: Invalid shorthand property initialiser.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Operators","slug":"JavaScript/Vanilla JavaScript/3 Operators","date":"2021-11-26T15:31:58.000Z","updated":"2023-09-11T03:55:22.808Z","comments":true,"path":"2021/11/27/JavaScript/Vanilla JavaScript/3 Operators/","link":"","permalink":"https://redre4per.github.io/2021/11/27/JavaScript/Vanilla%20JavaScript/3%20Operators/","excerpt":"","text":"Relational Operators basic: &gt; &lt; &gt;= &lt;= == === (same as ==, but does not allow any type conversions) != (opposite of ==) !== (opposite of ===) == is to determine whether the values are equal. log(a&lt;b&lt;c) is incorrect. Because JS will count from left to right. a&lt;b is true, but true&lt;c is an incorrect expression and cannot be evaluated. Logical operators: &amp;&amp; and, || or, !not b&gt;a&amp;&amp;b&lt;c The operation priority of &amp;&amp; is higher than ||, even if it comes after the expression. ! has higher precedence than relational operators such as &gt; and &lt;. The way of writing !a&gt;b is wrong, the correct way is !(a&gt;b) Implicit type conversion JS automatically converts data types according to the differences between the two operations. 123var a = 5;var b = &quot;5&quot;;console.log(a==b) //true When boolean values and numbers are operated together, true is converted to 1 and false is converted to 0. (Boolean and string cannot be converted, because the automatic conversion itself is for numbers. If both parties involved in the operation are not numbers, there will be no automatic conversion.) Conversion of Boolean values In the case where Boolean values are required, only 6 data will be converted to false, and the others will be true. Convert to False: false, 0, &quot; &quot; (null character, not space), undefined, NaN (not a number), null &amp;&amp; and || If the element before &amp;&amp; is false, the element before &amp;&amp; will be returned directly; if the element before &amp;&amp; is true, the result will be determined by the element after &amp;&amp;. 12console.log(&quot;hello&quot;&amp;&amp;&quot;world&quot;) //The result is worldconsole.log(0&amp;&amp;&quot;world&quot;) //The result is 0 If the preceding || is false, the result is determined by the elements after ||; if the preceding || is true, the result directly returns the elements preceding ||. Assignment Operator = += -= *= /= %= var a&#x3D;5; a+&#x3D;5; Same as a++. Ternary operator ?: Syntax: Condition? Value when the condition is true: Value when the condition is not true 1234var a=5;var b=6;var c=a&gt;b?&quot;haha&quot;:&quot;hehe&quot;console.log(c) //hehe Triple conditional judgment: 123var a=5;var b=6;var c=a&gt;b?&quot;r1&quot;:(a&lt;b?&quot;r2&quot;:&quot;r3&quot;) Summary When performing addition + (splicing) between strings and any type, the numbers are converted into strings; If you perform mathematical judgments and mathematical operations on numbers and any type, convert them to numbers. A simple way is to first consider what variable types should be on both sides of the operator (such as +, &gt;, &lt;, &amp;&amp;, etc.)? If both sides are not satisfied with the conditions, can they be converted into satisfied conditions? That is, + is addition or connection, &lt; &gt; is the size of a number, &amp;&amp; is true&#x2F;false.","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"Vanilla JavaScript","slug":"JS-TS/Vanilla-JavaScript","permalink":"https://redre4per.github.io/categories/JS-TS/Vanilla-JavaScript/"}],"tags":[{"name":"Vanilla JavaScript","slug":"Vanilla-JavaScript","permalink":"https://redre4per.github.io/tags/Vanilla-JavaScript/"}]},{"title":"Class knowledge review","slug":"React/B02 Class knowledge review","date":"2021-11-26T11:48:29.000Z","updated":"2022-11-12T02:35:33.253Z","comments":true,"path":"2021/11/26/React/B02 Class knowledge review/","link":"","permalink":"https://redre4per.github.io/2021/11/26/React/B02%20Class%20knowledge%20review/","excerpt":"","text":"Console output class Red represents that the output is an instance object, and blue represents who created the instance object. Person {} If the constructor of the class does not receive parameters, the created instance objects will look the same. Constructor constructor 12345class Person &#123;constructor (name, age) &#123; this.name=name this.age=age &#125;&#125; Who is this in the constructor? this points to the instance object of the class. The constructor can not be written. But if you don’t write it, the instance objects are the same. General methods: custom methods other than constructors. Do not write functions. Directly methodname() in the class. Common methods are placed on the prototype object of the class. The methods placed on the prototype object are for the instance. In general methods this refers to the instance object. That is, when a generic method is invoked through an instance, this in the generic method refers to the instance. But here you can use the call&#x2F;apply&#x2F;bind method to change the this pointer. Inherit extends 1class Student extends Person &#123;&#125; The Student class does not have to write a constructor, because the parent class Person has a constructor. When a subclass does not write a constructor, it directly inherits the constructor of the parent class. When a subclass needs to customize a new constructor, because the parameters are passed in order, they must be received in order. And must call super to call the constructor of the parent class. 12345class Student extend Person &#123; constructor (name, age, grade) &#123; super (name, age) //Note here that super must be placed at the top of the constructor. this.grade=grade &#125;&#125; ​ Summary The constructor in the class does not have to be written. It is only written when some initialization operations are to be performed on the instance, such as adding specified attributes. If class a inherits class b, and a constructor is written in class a, super must be called in the constructor of class a. The method defined in the class is placed on the prototype object of the class for use by the instance. Object related knowledge All property names in the object are strings (that is, hard-coded), namely this.setState(&#123;dataType: event.target.value&#125;) and this.setState(&#123;&#39;dataType&#39;: event.target.value&#125; ) is the same effect, just shorthand. If you want dataType to become a variable, you must write it as [dataType]. If you want to get the object key name in the object, if the key name is still a variable, you need to use obj[key] to get it instead of obj.[key]. Such as let a=&#39;name&#39;; let obj=&#123;&#125;; To get the result of name: &#39;tom&#39;, you must write obj[a] = &#39;tom&#39;.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Component","slug":"React/B01 Component","date":"2021-11-26T06:37:03.000Z","updated":"2022-11-12T02:34:18.106Z","comments":true,"path":"2021/11/26/React/B01 Component/","link":"","permalink":"https://redre4per.github.io/2021/11/26/React/B01%20Component/","excerpt":"","text":"Module and component definitions Module: Generally, a .JS file is a module (developed by function) Component: A collection of JS+HTML+CSS code and resources (developed by region) Developer Tools React-Developer Tools Based on Chrome browser. Chrome - Extensions - Open the Chrome Web Store - Type React in the search box. The provider is Facebook. When opening a webpage written by React, the icon in the upper right corner will light up. If the webpage has not been packaged and launched, it is a red + bug mark; If the webpage is packaged and launched, it is the React dark blue logo. When right-clicking an element, there are more Components and Profiler tabs. Components are used to observe how many components a web page is composed of, and to see how many properties each component has. Profiler is used to record website performance, loading time&#x2F;which component is the slowest, etc. Functional components Because components include HTML&#x2F;CSS&#x2F;JS, at least there must be structural HTML, , so functional components must have a return value. The component name must be capitalized. If the component name is lowercase, an error will be reported after rendering with the lowercase name: Warning: Function are not valid as a React Child. This may happen if you return a Component instead of from render. Or maybe you meant to call this function rather than return it. When rendering the component to the page, must write &lt;MyComponent/&gt; closing tag. Attention question The functional component is not called by itself, but is called by React for me. After the call, the return value is obtained and rendered on the page. This in functional components points to the problem 123function MyComponent()&#123;console.log(this) //undefined&#125; The reason is that the JSX code is to be translated by babel, and strict mode will be turned on after translation. Strict mode prohibits this in custom functions from pointing to window, so it is undefined. What happens after executing ReactDOM.render( &lt;MyComponent/&gt; ...) ? React parses the component tag and finds the MyComponent component. It is found that the component is defined with a function, and then the function is called to convert the returned virtual DOM into a real DOM, and then render it on the page. The application of the three properties of class components in functional components The three properties of class components are state, props, and refs. This is used when calling these properties, such as this.state.isHot this.props.name. This is because this represents an instance of a functional component. That is, the three attributes of class components are used on class instances. Functional components, on the other hand, do not have instances. So state and refs cannot be used (the new version of state can be used through hooks). But functional components can use props, because functions can take parameters. Functional components use props The props in class components are returned from this.props like: 1render()&#123;const &#123;name, age, gender&#125; = this.props &#125; Functional components don’t have this. However, all key-value pairs passed into component tags are also collected by React into the props object. In this case, the parameter of the functional component is the props object. Therefore, instead of using this.props, functional components can directly use props objects instead of class components. Functional components limit the data in props Class component restrictions on props can be written outside the class component or inside the class component. But functional components don’t have the static syntax. Therefore, it is restricted that props can only be written outside the component. 123functional component()&#123;&#125;componentname.propType = &#123;&#125;componentname.default = &#123;&#125; The purpose of functional components The general case is to deal with static pages, because functional components do not handle logic (before hooks).","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Virtual DOM, JSX","slug":"React/A02 Virtual DOM, JSX","date":"2021-11-25T03:06:26.000Z","updated":"2022-11-12T02:11:25.659Z","comments":true,"path":"2021/11/25/React/A02 Virtual DOM, JSX/","link":"","permalink":"https://redre4per.github.io/2021/11/25/React/A02%20Virtual%20DOM,%20JSX/","excerpt":"","text":"**Why React uses JSX instead of native JS? ** Case 1: Create the following example with JS and JSX 123&lt;div id=&quot;test&quot;&gt; &lt;h1 id=&quot;title&quot;&gt;Hello,React&lt;/h1&gt;&lt;/divdiv&gt; JSX 1const VDOM = &lt;h1 id=&quot;title&quot;&gt; Hello, React &lt;/h1&gt; JS: Syntax const VDOM = React.createElement(tag name, tag attribute-object writing, tag content) That is, without introducing babel, create a virtual DOM directly with React. Note here that document.createElement() creates a real DOM, while React.createElement() creates a virtual DOM. 1const VDOM = React.createElement(&#x27;h1&#x27;, &#123;id: &#x27;title&#x27;&#125;,&#x27;Hello, React&#x27;) Case 2: One more level of nesting in case 1 12345&lt;div id=&quot;test&quot;&gt; &lt;h1 id=&quot;title&quot;&gt; &lt;span&gt;Hello,React&lt;/span&gt; &lt;/h1&gt;&lt;/divdiv&gt; JSX 1const VDOM = &lt;h1 id=&quot;title&quot;&gt;&lt;span&gt;Hello, React&lt;/span&gt;&lt;/h1&gt; JS: Wrong writing (The span tag in this writing method does not take effect.) 1const VDOM = React.createElement(&#x27;h1&#x27;, &#123;id: &#x27;title&#x27;&#125;,&#x27;&lt;span&gt;Hello, React&lt;/span&gt;&#x27;) Correct spelling 1const VDOM = React.createElement(&#x27;h1&#x27;, &#123;id: &#x27;title&#x27;&#125;,React.createElement(&#x27;span&#x27;, &#123;&#125;, &#x27;Hello, React&#x27;)) //Write an empty object without a tag attribute. When multiple layers of tags need to be nested, it is very difficult to write native JS, and JSX only needs to be written in normal HTML mode. The creation of JSX is only to solve: to solve the problem that virtual DOM creation is too cumbersome. JSX also supports newline writing. Use parentheses ( ) to wrap the code in JSX. Note here that the JSX code in the example, after being translated by babel, is the JS code in the example. Therefore, the way of creating virtual DOM in JSX is the syntactic sugar for creating virtual DOM in native JS. Virtual DOM Methods of outputting the DOM Use Console.log to output the VDOM. The result is a generic Object, whose data type is object, and which is also an instance of Object. (left) Use Console.log to output the real DOM. The real DOM is written HTML, like &lt;div id=&quot;demo&quot;&gt;&lt;/div&gt; . If I use the code Console.log(document.getElementById(&quot;demo&quot;)), the output can only get &lt;div id=&quot;test&quot;&gt;&lt;/div&gt; without seeing the attributes. So you need to use breakpoints, debugger; (right) In conclusion Virtual DOM is essentially an object of type Object (general object) The virtual DOM is relatively “light” and has fewer attributes; the real DOM is relatively “heavy”. Because the virtual DOM is used internally by React, there is no need for so many properties on the real DOM. The virtual DOM will eventually be converted into a real DOM by React and presented on the page. JSX syntax The full name is JavaScript XML. It is a JS extension syntax similar to XML defined by React. XML is an early data storage and transmission mode. Later, JSON is used to store data in the form of &#123;&#125; object strings. The parse method converts the string to JSON, and the stringily method converts the object string. 1234&lt;student&gt; &lt;name&gt;Tom&lt;/name&gt; &lt;age&gt;19&lt;/age&gt;&lt;/student&gt; Grammar rules: When defining a virtual DOM, do not write quotes. If you want to mix JS expressions in the tag, use the &#123;&#125; form. And because JS requires lowercase, it can be converted with &#123;myId&#125;.toLowerCase( ). The style class name designation applies className, because class is already occupied by the keyword. For example className=&quot;title&quot;. The inline style cannot be written with style=&quot;color: white&quot;, it will report an error that style cannot be written as a string. Because multiple sets of key-value pairs can be written in style, inline styles are written in object form in JSX. style needs to be written as a double {} pattern, ie: style=&#123;&#123;&#125;&#125; The outer {} represents the JS environment, and the inner {} represents the object in the JS. Such as style=&#123;&#123;color: 'white'&#125;&#125; . Be careful to add &#39;&#39; here, otherwise it will become a variable. In addition, some inline styles are composed of multiple words, namely font-size. It should be written as a small hump, that is, style=&#123;&#123;color: 'white', fontSize: '20px'&#125;&#125; Summary: Inline styles should be written in the form of style=&#123;&#123;key: value&#125;&#125; . JSX requires only one root tag. That is, the outermost layer needs a &lt;div&gt; container. The label must be closed. The first: &lt;input type=&quot;text&quot;&gt;&lt;/input&gt; The second: &lt;input type=&quot;text&quot;/&gt; Lowercase tags in JSX tags will be automatically converted to HTML tags with the same name when babel is compiled, and uppercase tags are component tags. But if you write a tag that is not in HTML and it is still a lowercase tag, it will be ignored by babel when compiling, which is equivalent to writing no tag outside. The first letter of the label: If it starts with a lowercase letter, the label will be converted to an element with the same name in HTML. If there is no element with the same name in HTML, an error will be reported. If the uppercase letter starts with , react will render the corresponding component. If the component is not defined, an error will be reported. JSX error-prone point React can automatically traverse the data in the array. The backend returns pure data, which is modified with map(). React cannot directly write the object as a node in the JSX tag. The corresponding error is: Uncaught Invariant Violation: Objects are not valid as a React child. If you meant to render a collection of children, use an array instead. In JSX, the for loop cannot be written in the tag. Because JS expressions inside JSX tags are written in &#123;&#125;, &#123;&#125; can only be written as expressions, not statements. JS expressions Expression: An expression yields a value and can be placed anywhere a value is required. Example: a variable name, a+b, demo(1) function call expression, arr.map() processing array, function test()&#123;&#125; defining function. Simple distinction method: connect a const x&#x3D; to the left of the expression, if it can receive a value, it is an expression, and if it cannot be received, it is not. Statement: if()&#123;&#125;, for()&#123;&#125;, switch()&#123;case:xxx&#125; The statement controls the direction of the code. No value, not part of an expression, no value. The map needs a key after modifying the array, because the diff algorithm needs it. The key is written in the loop tag as an attribute. If you don’t add data in reverse order, delete in order, etc. to destroy the order, only the list is rendered for display, and index can be used as the key. The way of comments in JSX Using /* */ directly will not work. Use &#123;/* */&#125; because &#123;&#125; provides the JS execution environment. Folding code in JSX 123//#regioncode block//#endregion","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Introduction","slug":"React/A01 Introduction","date":"2021-11-23T22:26:51.000Z","updated":"2022-11-12T02:09:41.030Z","comments":true,"path":"2021/11/24/React/A01 Introduction/","link":"","permalink":"https://redre4per.github.io/2021/11/24/React/A01%20Introduction/","excerpt":"","text":"React Family Bucket React core React- Router routing library PubSub message management library Redux centralized state management library Ant-Design UI component library React definition React: A JavaScript library for building user interfaces. The interface is the view. React is an open-source JavaScript library that renders data into HTML views. For example, the process of obtaining backend data and presenting it includes: Send a request to get data Process the data (filtering, formatting, etc.) Manipulate the DOM to render the page Regardless of the first two steps, React is only responsible for operating the DOM to render the page, and the first two steps still need to be operated by itself. In the first two steps, React does not have its own encapsulation method. Developed by Facebook, and open source It was deployed in Facebook and other newsfeeds in 2011, and was announced as open source in May 2013. Native JS Disadvantages The operation of DOM in native JS is cumbersome and inefficient. Complicated refers to troublesome coding, and low efficiency refers to the browser having to rearrange and draw every DOM operation. Using JS to directly manipulate the DOM, the browser will do a lot of redrawing and rearranging. Native JS has no component coding scheme, and the code reuse rate is low. Modularization: split a JS into several small JS files according to the function points. React Features Component mode, declarative coding, improves development efficiency and component reuse rate. Imperative: order the machine how to do things (how), so that no matter what you want (what), it will be implemented according to your order. Declarative: tell the machine what you want (what), let the machine figure out how to do it (how). In React Native, React syntax can be used for mobile development. React Native is to allow front-end staff to write IOS and Android applications with JS. Use virtual DOM + excellent Diffing algorithm to minimize interaction with real DOM. JS knowledge to master in learning React Judging this point, class, ES6 grammar specification, npm package manager, prototype prototype chain, common methods of arrays, modularization. Using React (learning version 16.8 + new version) 4 packages Babel.min.js Babel has two uses: ES6 to ES5, JSX to JS. Prop-types.js prop library in React class components React.development.jsReact core library React-dom.development.js React extension library for manipulating DOM React Coding First, there must be a container, similar to a mount point. &lt;div id=&quot;test&quot;&gt;&lt;/div&gt; Import the React package. react.development must be imported before react-dom.development. Finally, introduce babel. Before writing JS, you need to write it in the tag &lt;script&gt;. The full name of the tag is &lt;script type=&quot;text/javascript&quot;&gt; where type can be omitted. In React, because JSX needs to be written, the tag is &lt;script type=&quot;text/babel&quot;&gt;. Create virtual DOM const VDOM = &lt;h1&gt;Hello, React&lt;/h1&gt; Do not write &quot; &quot; here, because it is not a JS string, but a JSX virtual DOM. Render the virtual DOM to the page ReactDOM.render(virtual DOM, container) ReactDOM. render(VDOM, document. getElementById(&#39;test&#39;)) This is the only place in React where you need to manipulate the DOM yourself. Warnings and Errors You are using the in-brower Babel transformer. Be sure to precompile your scripts for production - When beginners use the method of manually introducing the React library (such as Section React 1.1.7 &amp; 1.1.8), the browser finds out that it is not JS when the script code is obtained. It depends on babel and the browser translates it on the spot. When there are many codes, the screen will be white, and it will run after waiting. Hence the yellow warning. Failed to load resource: the server responded with a status of 404 (Not Found) There is no icon for the website, after refreshing it is gone. Error-prone point Did not write mount point container &lt;div id=&quot;&quot;&gt;&lt;/div&gt; const VDOM = &#39;&lt;h1&gt;Hello, React&lt;/h1&gt;&#39; mistakenly added single quotes &#39; &#39; &lt;script type=&quot;text/babel&quot;&gt; is written as text/javascript Rendering twice is not an addition, but a replacement. Favicon When there is no icon, the console will report an error, and it will be canceled after refreshing. Failed to load resource: the server responded with a status of 404 (Not Found) Solution: Make an icon with the name&#x2F;format favicon.ico and put it in the root directory. The icon will appear after a forced refresh. Force refresh: press and hold shift+refresh. Annotation shortcuts in scaffolding CTRL+SHIFT+ - , the selected area directly forms a {&#x2F;* *&#x2F;} comment.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Variable","slug":"JavaScript/Vanilla JavaScript/2 Variable","date":"2021-10-13T00:39:20.000Z","updated":"2023-09-11T02:31:15.205Z","comments":true,"path":"2021/10/13/JavaScript/Vanilla JavaScript/2 Variable/","link":"","permalink":"https://redre4per.github.io/2021/10/13/JavaScript/Vanilla%20JavaScript/2%20Variable/","excerpt":"","text":"Variable naming Variable names can be capitalized because JS is case-sensitive. Variable assignment = is an assignment symbol. The usage is to assign the value on the right side of the equal sign to the variable on the left side of the equal sign. var box can be unassigned first when declaring variables, but it must be assigned with =. 1234var box = 1;var a = 5;var b = a = box;console.log(a, b, box) //result: 1, 1, 1. Data Types in JavaScript Primitive data type: Number, String, Boolean, undefined, null. (Symbol in ES6) Reference data types: Object, Array, Function. There is no need to declare a type when a variable is declared. It is okay to store different data types before and after the variable, for example, var b=123; var b=&quot;hello&quot;;. There is no floating point numbers in JS. Both integers and decimals are of type number. String type data must be added with &quot;&quot;. The data added with &quot;&quot; must also be a string. The boolean type has only a=true; b=false; (true and false are keywords). Undefined is used for unassigned variables. The result of var a; console.log(a) is undefined. Undefined is used to automatically initialize variables. Null is a null object pointer. Operator Operator: Symbols that operate on data. Expressions: All expressions are connected by operators, and expressions and data are equivalent. (because the result of an expression must be data) Arithmetic operators: + - * / ++ -- % a++ a++ self increment (+1 on the basis of itself, and then assign to itself). ++ When used alone, a++ and ++a are the same. When ++ is not used alone (eg b=a++), it is different before and after. ++a: +1 before participating in other operations. a++: first use the previous value to participate in the operation, and then increment 1 to itself after the operation is completed. 1234var a = 10;var b = a++;console.log(a) //11console.log(b) //10","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"Vanilla JavaScript","slug":"JS-TS/Vanilla-JavaScript","permalink":"https://redre4per.github.io/categories/JS-TS/Vanilla-JavaScript/"}],"tags":[{"name":"Vanilla JavaScript","slug":"Vanilla-JavaScript","permalink":"https://redre4per.github.io/tags/Vanilla-JavaScript/"}]},{"title":"Basic knowledge","slug":"JavaScript/Vanilla JavaScript/1 JavaScript Basic","date":"2021-10-12T08:28:36.000Z","updated":"2023-09-11T02:31:10.505Z","comments":true,"path":"2021/10/12/JavaScript/Vanilla JavaScript/1 JavaScript Basic/","link":"","permalink":"https://redre4per.github.io/2021/10/12/JavaScript/Vanilla%20JavaScript/1%20JavaScript%20Basic/","excerpt":"","text":"HTML CSS is not a programming language JavaScript is a programming language (browser programming language). Web pages written in HTML CSS do not have any functionality. All functions have to be done through JavaScript. Java brand backend language, the best language for writing backend. It is cooperative web development, big data, enterprise-level applications, big data, and Android development. C embedded, operating system, driver development C++ games and the like, desktop software C# software development How to use JS Add &lt;script&gt;&lt;/script&gt; tags to the body to use JS. Usually coding JS before the closing tag of the body. This is because JS loads slowly and the HTML &amp; CSS loads quickly. From the user’s point of view, the overall web page should be swiped first. JS core ECMAScript Core DOM page manipulation BOM browser related operations Comments in JS // Single line /* Multiple lines */ Variable A variable is a space in memory dedicated to storing data. How to use variable: Variables should be declared by var. The variable should be named var box. The variable should be assigned var box = 1. Semicolon in JS ; can be added or not (preferably) Console Console is for debugging JS, it is useless after the project development is over. The console can prompt errors. Console is in the browser -&gt; right click -&gt; inspect -&gt; Console. Console.log() function is console output (in JS). Project deployment The project can be accessed locally on the computer. Logically, other people can also access it through IP address + path + file name, but it’s practically not feasible because of firewall.To actually deploy project, you need to run the project to the server. The server is a high-performance computer that runs 24 hours a day without shutting down. Generally, small projects only rent a small part of the space in the server. Domain name: like www.google.com, and bind it’s IP address. When the domain name is entered, it is resolved by DNS (domain name system) and resolved into an IP address in the service and accessed. URL address: like https://www.google.com/src/index. protocol://domain name: port number + path (file path or route). Protocol http, https (secure mode), FTD (file upload), file.Port number: Different applications, different functions of the server. Such as 80 web pages, 3306 databases. Can be omitted by default. Path: The file path or the route set by the frontend&#x2F;backend.","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"Vanilla JavaScript","slug":"JS-TS/Vanilla-JavaScript","permalink":"https://redre4per.github.io/categories/JS-TS/Vanilla-JavaScript/"}],"tags":[{"name":"Vanilla JavaScript","slug":"Vanilla-JavaScript","permalink":"https://redre4per.github.io/tags/Vanilla-JavaScript/"}]},{"title":"Appendix - Special characters in TS","slug":"Typescript/Appendix - Special characters in TS","date":"2021-01-19T00:29:31.000Z","updated":"2023-09-11T02:26:42.383Z","comments":true,"path":"2021/01/19/Typescript/Appendix - Special characters in TS/","link":"","permalink":"https://redre4per.github.io/2021/01/19/Typescript/Appendix%20-%20Special%20characters%20in%20TS/","excerpt":"","text":"_ Number separator The delimiter _ does not change the value of a numeric literal, but the logical grouping makes it easier to read the numbers at a glance. 12const inhabitantsOfMunich = 1_464_301;const bytes = 0b1111_10101011_11110000_00001101; Usage restrictions: You can only add the _ separator between two numbers. The following example is illegal: 1234563_.141592 // Error1_e10 // Error_126301 //Error126301_ // Error0_b111111000 // Error123__456 // Error, multiple _ delimiters cannot be used continuously. The function that parses numbers does not support separators. 123Number(&#x27;123_456&#x27;) //NaNparseInt(&#x27;123_456&#x27;) //123parseFloat(&#x27;123_456&#x27;) //123 #XXX Private Field ECMAScript private fields have been supported since TypeScript 3.8. Unlike regular properties (even properties declared with the private modifier), the rules are: Private fields start with the # character, sometimes we call them private names; Each private field name is uniquely limited to the class it contains; TypeScript accessibility modifiers (such as public or private) cannot be used on private fields; Private fields cannot be accessed outside the containing class, or even detected. 123456789101112class Person &#123; #name: string; //Private field constructor(name: string) &#123; this.#name = name; &#125; greet() &#123; console.log(`Hello, my name is $&#123;this.#name&#125;!`); &#125;&#125; let semlinker = new Person(&quot;Semlinker&quot;);semlinker.#name; // Property &#x27;#name&#x27; is not accessible outside class &#x27;Person&#x27;. The difference between private fields and private: Private properties and methods can be accessed in some special ways. like: 1234567class Person &#123; constructor(private name: string)&#123;&#125;&#125; let person = new Person(&quot;Semlinker&quot;);console.log(person.name); //Property &#x27;name&#x27; is private and only accessible within class &#x27;Person&#x27;.console.log((person as any).name); //Can be accessed normally! This is because after private is compiled into ES5 code, it becomes: 123456789var Person = /** @class */ (function () &#123; function Person(name) &#123; this.name = name; &#125; return Person;&#125;()); var person = new Person(&quot;Semlinker&quot;);console.log(person.name); The private fields are different after compilation. ! Non-null assertion (section 11) ?. Optional Chaining (Section 11) ?? Null value coalescing operator (Section 11) ?: optional attribute (section 9) Tool Type (Section 13) &amp; intersection (Section 10) | union (Section 4) &lt;type&gt; Syntax: assertion (section 11) or generics (section 12)","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"TypeScript","slug":"JS-TS/TypeScript","permalink":"https://redre4per.github.io/categories/JS-TS/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://redre4per.github.io/tags/TypeScript/"}]},{"title":"TS in React","slug":"Typescript/14 TS in React","date":"2021-01-18T00:29:31.000Z","updated":"2023-09-11T02:25:27.871Z","comments":true,"path":"2021/01/18/Typescript/14 TS in React/","link":"","permalink":"https://redre4per.github.io/2021/01/18/Typescript/14%20TS%20in%20React/","excerpt":"","text":"React.FC Description is not a regular function, but a functional component. There must be a return value. 123const TodoList: React.FC = () =&gt; &#123; return &lt;div&gt;&lt;/div&gt;&#125;; Props There are two ways to write props types, and they are equivalent. Generic interface React.FC&lt;props type&gt; 123456interface TodoListProps &#123; items: &#123;id: string, text: string&#125;[];&#125;;const TodoList: React.FC&lt;TodoListProps&gt; = props =&gt; &#123; return(...)&#125; Declare the props type in the parameters 123456interface TodoListProps &#123; items: &#123;id: string, text: string&#125;[];&#125;;const TodoList = (props: TodoListProps) =&gt; &#123; return(...)&#125; props may also be functions. This should be written as: 123456type NewTodoProps = &#123;onAddTodo: (todoText: string) =&gt; void;&#125;const NewTodo: React.FC&lt;NewTodoProps&gt; = props =&gt; &#123; return(...)&#125; Type of event Common Event event objects are as follows: Clipboard event object: ClipboardEvent&lt;T &#x3D; Element&gt; Drag event object: DragEvent&lt;T &#x3D; Element&gt; Focus event object: FocusEvent&lt;T &#x3D; Element&gt; Form event object: FormEvent&lt;T &#x3D; Element&gt; Change event object: ChangeEvent&lt;T &#x3D; Element&gt; Keyboard event object: KeyboardEvent&lt;T &#x3D; Element&gt; Mouse event object: MouseEvent&lt;T &#x3D; Element, E &#x3D; NativeMouseEvent&gt; Touch event object: TouchEvent&lt;T &#x3D; Element&gt; Wheel event object: WheelEvent&lt;T &#x3D; Element&gt; Animation event object: AnimationEvent&lt;T &#x3D; Element&gt; Transition event object: TransitionEvent&lt;T &#x3D; Element&gt; The generic types of these Event event objects will receive an Element element type, which is the type of the label element bound to this event. 1234567891011121314151617type State = &#123; text: string;&#125;; const App: React.FC = () =&gt; &#123; const [text, setText] = useState&lt;string&gt;(&quot;&quot;) const onChange = (e: React.FormEvent&lt;HTMLInputElement&gt;): void =&gt; &#123; setText(e.currentTarget.value); &#125;; return ( &lt;div&gt; &lt;input type=&quot;text&quot; value=&#123;text&#125; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; );&#125; useState() declaration type Use useState() to declare the type of state. By default, React will automatically deduce the type of state and update function based on the initial value of the set state. If the initial value is null, the type of state needs to be explicitly declared. 123const [count, setCount] = useState&lt;number&gt;(1); //&lt;number&gt; can be omittedconst [count, setCount] = useState&lt;number | null&gt;(null); //need to display statementconst [todos, setTodos] = useState&lt;&#123;id: string; text: string&#125;[]&gt;([]); //It is best to change it to interface[]. If state is an object and you want to initialize an empty object, you can use assertions to handle it: 1const [user, setUser] = React.useState&lt;IUser&gt;(&#123;&#125; as IUser); Use useRef to get the type of user input 1const textInputRef = useRef&lt;HTMLInputElement&gt;(null); More knowledge about using TS in React https://juejin.cn/post/7021674818621669389","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"TypeScript","slug":"JS-TS/TypeScript","permalink":"https://redre4per.github.io/categories/JS-TS/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://redre4per.github.io/tags/TypeScript/"}]},{"title":"Generic Utility Types","slug":"Typescript/13 Generic Utility Types","date":"2021-01-17T00:29:31.000Z","updated":"2023-09-11T02:24:18.857Z","comments":true,"path":"2021/01/17/Typescript/13 Generic Utility Types/","link":"","permalink":"https://redre4per.github.io/2021/01/17/Typescript/13%20Generic%20Utility%20Types/","excerpt":"","text":"Generic Utility Types Generic Utility Types Generic utility types can be used to process and transform different types of data. These generic utility types are generic because all they do is take the value of any other type and process it. Partial Make all properties of type T optional. Often used to temporarily switch an object type or an interface, making it optional. For example: 12345678910111213interface CourseGoal &#123; title: string; description: string; completeUntil: Date;&#125; function createCourseGoal (title: string, description: string, completeUntil: Date): CourseGoal &#123; let courseGoal = Partial&lt;CourseGoal&gt; = &#123;&#125;; //If there is no Partial, an error will be reported. courseGoal.title = title; courseGoal.description = description; courseGoal.completeUntil = date; return courseGoal as CourseGoal;&#125; Required Makes all optional properties in type T required. For example: 12345678910interface Person &#123; name?: string; age?: number; address?: string;&#125; type RequiredPerson = Required&lt;Person&gt;; const person1: RequiredPerson = &#123; name: &#x27;Alice&#x27;, age: 30, address: &#x27;123 Main St.&#x27; &#125;; // OKconst person2: RequiredPerson = &#123; name: &#x27;Bob&#x27;, age: 40 &#125;; // Error: address is missing Readonly Makes all properties of type T read-only. For example: 12345678910interface Person &#123; name: string; age: number; address: string;&#125; type ReadonlyPerson = Readonly&lt;Person&gt;; const person: ReadonlyPerson = &#123; name: &#x27;Alice&#x27;, age: 30, address: &#x27;123 Main St.&#x27; &#125;;person.name = &#x27;Bob&#x27;; // Error: Cannot assign to &#x27;name&#x27; because it is a read-only property. It can also be used to lock arrays and objects, etc. 12const names: Readonly&lt;string[]&gt; = [&quot;Max&quot;, &quot;Anna&quot;];names.push(&quot;Manu&quot;); //Error report Pick&lt;T, K&gt; Select the attribute named K from type T to form a new type. For example: 123456789interface Person &#123; name: string; age: number; address: string; email: string;&#125; type PersonNameEmail = Pick&lt;Person, &#x27;name&#x27; | &#x27;email&#x27;&gt;;const person: PersonNameEmail = &#123; name: &#x27;Alice&#x27;, email: &#x27;alice@example.com&#x27; &#125;; Omit&lt;T, K&gt; Remove the attribute named K from type T to form a new type. For example: 12345678910interface Person &#123; name: string; age: number; address: string; email: string;&#125; type PersonWithoutAge = Omit&lt;Person, &#x27;age&#x27;&gt;; const person: PersonWithoutAge = &#123; name: &#x27;Alice&#x27;, address: &#x27;123 Main St.&#x27;, email: &#x27;alice@example.com&#x27; &#125;; Record&lt;K, T&gt; Creates a type containing a value type that maps each property name in type K to type T. For example: 12345678910type Weekday = &#x27;Mon&#x27; | &#x27;Tue&#x27; | &#x27;Wed&#x27; | &#x27;Thu&#x27; | &#x27;Fri&#x27;;type WorkHours = Record&lt;Weekday, &#123; start: string, end: string &#125;&gt;; const workHours: WorkHours = &#123; Mon: &#123; start: &#x27;9:00&#x27;, end: &#x27;17:00&#x27; &#125;, Tue: &#123; start: &#x27;9:00&#x27;, end: &#x27;17:00&#x27; &#125;, Wed: &#123; start: &#x27;9:00&#x27;, end: &#x27;17:00&#x27; &#125;, Thu: &#123; start: &#x27;9:00&#x27;, end: &#x27;17:00&#x27; &#125;, Fri: &#123; start: &#x27;9:00&#x27;, end: &#x27;17:00&#x27; &#125;,&#125;","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"TypeScript","slug":"JS-TS/TypeScript","permalink":"https://redre4per.github.io/categories/JS-TS/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://redre4per.github.io/tags/TypeScript/"}]},{"title":"Generic","slug":"Typescript/12 Generic","date":"2021-01-16T00:29:31.000Z","updated":"2023-09-11T02:23:21.668Z","comments":true,"path":"2021/01/16/Typescript/12 Generic/","link":"","permalink":"https://redre4per.github.io/2021/01/16/Typescript/12%20Generic/","excerpt":"","text":"Concept of Generics A Generic type is a type that has some relationship to other types and is very flexible as to what other types are. TS has built-in generic types: Array The main type is Array, but the items in an Array can be of other types. 1const names: Array = []; //The type here is actually Array&lt;any&gt;, or it can be written as any[]; Promise The main type is Promise, but the result of resolve can be other types. 12345const promise: Promise&lt;string&gt; = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&quot;This is done!&quot;); &#125;, 2000);&#125;); In a way, Generic types don’t care whether the data is of a specific type, but rather want to store type information outside of the incoming data to get better TypeScript support when using generic types. Use Generic in functions In the example, TS only knows that the function return type is object. 12345function merge(objA: object, objB: object) &#123; return Object.assign(objA, objB);&#125;const mergedObj = merge(&#123;name: &quot;Max&quot;&#125;, &#123;age: 30&#125;);mergedObj.age; //An error is reported because TS only knows that an object has been returned, but does not know the properties within the object. Generics can be used in functions to express uncertainty about parameter types or return value types, and angle brackets &lt;&gt; can be used to declare generic parameters. In the example, as soon as the object type parameter is passed in when calling the function, T is deduced to be of object type. And &lt;T, U&gt; is a generic parameter list, used to define type parameters in functions. &lt;T, U&gt; in the generic parameter list indicates that there are two generic type parameters T and U, which can be used to represent the parameter types of the function (T and U). 12345function merge&lt;T, U&gt;(objA: T, objB: U) &#123; //Put the mouse on merge and you will get T&amp;U (intersection, intersection type). return Object.assign(objA, objB);&#125;const mergedObj = merge(&#123;name: &quot;Max&quot;&#125;, &#123;age: 30&#125;);mergedObj.age; //Normal operation, get 30. The return value type of a function is inferred based on the code, TS, in the function body. Generic parameters &lt;T, U&gt; are only used to specify the type of parameters and provide support for TS type inference, but have no direct impact on the actual behavior of the function and the inference of the return value type. Note that T and U in the example also include types other than object type. Type constraint In the above example, if the parameter is not of object type, incorrect results will be obtained, and the IDE will not report an error. If you want to restrict them to the object type, you should use type restrictions. Type restrictions use the extends keyword and are only written in parameter lists within &lt;&gt;. 1234function merge&lt;T extends object, U extends object&gt;(objA: T, objB: U) &#123; return Object.assign(objA, objB);&#125;const mergedObj = merge(&#123;name: &quot;Max&quot;&#125;, 30); //An error will be reported here, 30 does not conform to the type. Similarly, after type restriction extends, you can also use custom types, union types, etc. Use generics to ensure that function parameters have certain attributes In TS, you can use Generic to ensure that a parameter has a certain property. A common method is to use generic constraints, that is, add an extends keyword and a constraint type after the generic parameter to limit the type of the generic parameter. 123456interface HasName &#123; name: string;&#125;function printName&lt;T extends HasName&gt;(obj: T) &#123; //Force parameters to have name attribute console.log(obj.name);&#125; The function in the example receives a parameter of type T, which must satisfy the constraint of T extends HasName. If the conditions are not met, the IDE will report an error. Similarly, this method can also be used to limit parameters to a certain method on the prototype object to ensure a certain attribute on its prototype object: 123456interface length &#123; length: number;&#125;function countAndDescribe&lt;T extends Lengthy&gt;(element: T)&#123; if(element.length...)&#123; ... &#125;;&#125; Use keyof to declare that the parameter is a key in the object keyof is used to obtain all attribute names of a type and generate a union type composed of attribute names. keyof has two usage scenarios: Get the object attribute name and perform type checking Use keyof to get all the property names of an object and form them into a union type. Each member of this union type is a property name of the object. We can use this union type to perform type checking to ensure that we are only accessing properties that the object actually owns. For example: 123function extractAndConvert&lt;T extends object, U extends keyof T&gt;(obj: T, key: U) &#123; return &quot;Value&quot; + obj[key]; //If U is not declared to be the key of the attribute in T, an error will be reported.&#125; For example, if the value of parameter obj is &#123;name = &quot;Derek&quot;, age = 18, gender = male&#125;, then the type of U is &#39;name&#39; | &#39;age&#39; | &#39;gender&#39;. Define generic type parameters Using keyof can also limit the value range of the parameter when defining a generic type parameter to ensure that it can only take the attribute name of a certain type. For example: 123456interface Person &#123; name: string; age: number;&#125; type PersonKey = keyof Person; // type is &#x27;name&#x27; | &#x27;age&#x27; Similar to the first scenario. Generic Class Using generics to define a class allows certain properties or methods in the class to support multiple types. The syntax for using generics in a class is similar to that in a function. We only need to add &lt;&gt; after the class name and specify the generic type parameters in it. 123456789101112131415161718192021class DataStorage&lt;T&gt; &#123; private data: T[] = []; addItem(item: T) &#123; this.data.push(item); &#125; removeItem(item: T) &#123; this.data.splice(this.data.indexOf(item), 1); //Note that indexOf cannot take effect on reference type data. &#125; getItems() &#123; return [...this.data]; &#125;&#125; const container1 = new DataStorage&lt;string&gt;();container1.addItem(&quot;derek&quot;);const container2 = new DataStorage&lt;number&gt;();const container2 = new DataStorage&lt;object&gt;();container1.addItem(&#123;name: &quot;derek&quot;&#125;);container1.addItem(&#123;name: &quot;tom&quot;&#125;&#125;);container1.remove(&#123;name: &quot;derek&quot;&#125;);console.log(objStorage.getItems()); //The result here is wrong. Because the removed object is a new object, the address is different from the previous one. When the Generic type can represent both primitive type and reference type parameters, problems will arise in some methods that are not common to the two types. The solution is to first assign the reference type data (the heap address) to a primitive data (that is, in the stack), and then operate. In this way, you can operate according to the method of primitive type data. 123456const container2 = new DataStorage&lt;object&gt;();const derekObj = &#123; name: &quot;derek&quot; &#125;;container1.addItem(derekObj);container1.addItem(&#123;name: &quot;tom&quot;&#125;&#125;);container1.remove(&#123;derekObj);console.log(objStorage.getItems()); //Get the correct result Another solution is to restrict generics &lt;T&gt; so that class can only be applied to primitive types. like: 1class DataStorage&lt;T extends string | number | boolean&gt;&#123;&#125; You can also introduce new generics such as &lt;U&gt; in class methods, if this generic is only needed in a certain method. The difference between Generic and Union type If you want to get a function, you can call it with one of these types every time you call it, the union type is suitable; if you want to lock a certain type, Generic is suitable. Generic is used to use the same type throughout the entire class instance created. 123456789class DataStorage&lt;string | number | boolean&gt; &#123; private data: string[] | number[] | boolean[] = []; addItem(item: string | number | boolean) &#123; this.data.push(item); &#125; removeItem(item: string | number | boolean) &#123; this.data.splice(this.data.indexOf(item), 1); &#125;&#125; The union type is used in the example. In fact, different types of parameters can be added each time addItem(item) is called. If defined with generic, the class can only add one type of parameters. More generic knowledge https://juejin.cn/post/6844904184894980104 There are generic condition types.","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"TypeScript","slug":"JS-TS/TypeScript","permalink":"https://redre4per.github.io/categories/JS-TS/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://redre4per.github.io/tags/TypeScript/"}]},{"title":"Advanced types - Type Casting, index properties, Function overloads, Optional chaining, Nullish Coalescing","slug":"Typescript/11 Type Casting, index properties, Function overloads, Optional chaining, Nullish Coalescing","date":"2021-01-12T00:29:31.000Z","updated":"2023-09-11T02:19:56.279Z","comments":true,"path":"2021/01/12/Typescript/11 Type Casting, index properties, Function overloads, Optional chaining, Nullish Coalescing/","link":"","permalink":"https://redre4per.github.io/2021/01/12/Typescript/11%20Type%20Casting,%20index%20properties,%20Function%20overloads,%20Optional%20chaining,%20Nullish%20Coalescing/","excerpt":"","text":"Type Casting Type conversion tells TS that a value is of a specific type without TS being able to detect it on its own. TS cannot detect the type in some cases. For example, in HTML, id is used to obtain the DOM (what is obtained is broad as HTMLElement, not the specific element), and the same is true for data obtained from the backend. Two syntaxes for Type Casting (equivalent): Non-React Prepend &lt;type&gt; before the value to specify the type. 1const userInputElement = &lt;HTMLInputElement&gt;document.getElementById(&quot;user-input&quot;); React Use the as keyword to specify the type. 1const userInputElement = document.getElementById(&quot;user-input&quot;) as HTMLInputElement; Non-empty assertion! ! means that the preceding expression will never produce null. If the programmer knows that the value will never be null, they can declare it this way. If you are unsure, you can use an if check. ! There is also an alternative. The type of the value before ! should be some type | null, so ! is needed. Therefore, if we specify it as some type with as, we can replace !. 123if (userInputElement) &#123; (userInputElement as HTMLInputElement).value = &quot;Hi there!&quot;;&#125; index properties index type Index properties can be used to define dynamic properties in object types. Usually we need to define all possible properties in the object type, but sometimes we don’t know what properties the object will have, or we need to allow users to define arbitrary properties. Index properties can be used at this time. Notice: index property must be of string or numeric type. The index property can be used alone as the only type of property in an object. The type of the index property must be consistent with the type of other known properties in the object, or be their subtype. If the object already contains a property, the type of this property must be the same as the type of the index property or its subtype. (This is because the index property is a summary of the types in the object) 1234567891011121314151617interface User &#123; [key: string]: string | number; name: string; age: number;&#125; const user: User = &#123; name: &#x27;Alice&#x27;, age: 30, email: &#x27;alice@example.com&#x27;, phone: 1234567890,&#125;; console.log(user.name); // Aliceconsole.log(user.age); // 30console.log(user.email); // alice@example.comconsole.log(user.phone); // 1234567890 Function overloads function overload Function overloads allow multiple function type signatures to be defined for the same function. Each function type signature defines a set of parameter and return value types. Function overloading will automatically select the correct function type signature to execute the function based on the type and number of parameters passed in. Through function overloading, the compiler checks whether the function call conforms to the expected type at compile time, and automatically selects the correct function type signature to execute the code at runtime, thus improving the readability and maintainability of the code. 123456789function add(a: string, b: string): string;function add(a: number, b: number): number;function add(a: any, b: any): any &#123; return a + b;&#125; console.log(add(&#x27;Hello &#x27;, &#x27;World&#x27;)); // Hello Worldconsole.log(add(2, 3)); // 5 Notice: Function overloading must be declared first (written directly above the main function). The parameter types and return value types in the main function must be compatible with all function type signatures. The function type signature of function overloading can have any number and any type of parameters, as long as different function type signatures can be distinguished. Using function overloading, there is no need to write conditional judgment statements in the main function to determine the parameter type. The TypeScript compiler will automatically select the correct function type signature to execute the function based on the parameter type. Optional chaining Optional chaining allows developers to avoid program crashes or exceptions caused by the non-existence of a property or method when accessing a property or method that may not exist (such as obtaining data from the backend, which cannot guarantee data integrity). Using Optional chaining, you can add a question mark ? when accessing a property or method to indicate that the property or method may not exist, thus avoiding exception errors caused by the non-existence of the property or method. Note that Optional chaining is only available in TypeScript 3.7 and above. 1234// Use the ?. operator when accessing properties that may not existconst name = obj?.person?.name;// Use the ?. operator when calling methods that may not existconst result = obj?.person?.getName(); Nullish Coalescing ?? Nullish Coalescing (??) is an operator similar to ||. The difference between them is that ||’s judgment standard for the previous value is falsy, that is: Boolean value false, 0, -0, &#39;&#39; empty string, null , undefined, NaN. ?? The criterion for judging the previous value is null or undefined instead of false. 123const userInput = &quot;&quot;const storedData1 = userInput || &quot;DEFAULT&quot; //If userInput is falsy, use the following value.const storedData2 = userInput ?? &quot;DEFAULT&quot; //If userInput is null or, use the subsequent value.","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"TypeScript","slug":"JS-TS/TypeScript","permalink":"https://redre4per.github.io/categories/JS-TS/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://redre4per.github.io/tags/TypeScript/"}]},{"title":"Advanced types - intersection types, type Guard，Discriminated union","slug":"Typescript/10 intersection types, type Guard, Discriminated union","date":"2021-01-11T00:29:31.000Z","updated":"2023-09-11T02:18:23.210Z","comments":true,"path":"2021/01/11/Typescript/10 intersection types, type Guard, Discriminated union/","link":"","permalink":"https://redre4per.github.io/2021/01/11/Typescript/10%20intersection%20types,%20type%20Guard,%20Discriminated%20union/","excerpt":"","text":"intersection types “&amp;” intersection types allow us to combine other types. Use &amp; to combine types. The combined type contains all properties and methods of those combined types. 123456789type Admin = &#123; name: string; privileges: string[];&#125;;type Employee = &#123; name: string; startDate: Date;&#125;type ElevatedEmployee = Admin &amp; Employee; //This type contains all properties and methods of Admin and Employee. intersection types are closely related to interface inheritance because the same functionality can be achieved using interfaces. 123456789interface Admin &#123; name: string; privileges: string[];&#125;;interface Employee &#123; name: string; startDate: Date;&#125;interface ElevatedEmployee extends Admin, Employee &#123;&#125;; When combining multiple union types using intersection types, the intersection (common part) is obtained. 123type Combinable = string | number;type Numeric = number | boolean;type Universal = Combinable &amp; Numeric; //type Universal = number Type Gaurd type protection Type protection is used to converge types, that is, to converge variables that may have multiple types into an exact type. Type guarding is a term that describes detecting the existence of a property or method before trying to use it. typeof type protection (used to detect non-object) typeof can only compare types known to JS, namely object, string, number, and boolean. TS custom types cannot be compared. 1234567type Combinable = string | number;function add(a: Combinable, b: Combinable) &#123; if (typeof a === &quot;string&quot; || typeof b === &quot;string&quot;) &#123; return a.toString() + b.toString(); &#125; return a + b;&#125; in type protection (used to detect object) After two objects are unioned, it is impossible to use typeof to determine whether they contain a certain attribute, because the type is object (typeof emp === &quot;object&quot;). There is also no way to detect whether type is a custom type (typeof emp === &quot;Employee&quot;), because JS does not know the custom type. This is because typeof uses JS instead of TS at runtime, so it can only compare the type obtained by typeof with the type known to JS. The in keyword can check for prohibited attributes in TS. 123456789101112interface Admin &#123; name: string; privileges: string[];&#125;;interface Employee &#123; name: string; startDate: Date;&#125;type UnknownEmployee = Employee | Admin;function printEmp (emp: UnknownEmployee) &#123;if(&quot;privileges&quot; in emp)&#123; ... &#125;; //Check whether privileges is an attribute on emp.&#125; Type protection of instanceof (used to detect object, only for instances of class, cannot be used for interface) The function implemented by the type protection of in is similar to that of in, but more elegant. Used to detect whether an object is an instance of a class. If it is an interface, instanceof cannot be used to detect it. 1234567891011121314151617181920212223class Car &#123; drive()&#123; console.log(&quot;Driving&quot;) &#125;&#125;class Truck &#123; drive()&#123; console.log(&quot;Driving&quot;) &#125; loadCargo(amount: number) &#123; console.log(&quot;Loading cargo ...&quot; + amount); &#125;&#125;type Vehicle = Car | Truck; //[Note]const v1 = new Car();const v2 = new Truck(); function useVehicle(vehicle: Vehicle) &#123; vehicle.drive(); //Shared methods if (vehicle instanceof Truck) &#123; //Detect instance vehicle.loadCargo(1000); &#125;&#125; Note: Car and Truck are two classes, but in TypeScript, a class is also a type, just like basic data types (such as string and number) and other custom types . Therefore, we can combine the Car and Truck types into a union type Vehicle. Discriminated Unions Discriminated Unions Discriminated Unions is a design pattern that can be used when working with union types to make it easier to implement type protection. It is used for the type of object. A type resulting from the union of two different types, which usually have some related but different properties or methods. Discriminated Unions means that in each object (type) that makes up the union, there is a public property that describes the object. So we can use this public property in type detection to achieve 100% type safety. Not using Discriminated Unions: 1234567interface Bird &#123; flyingSpeed: number;&#125;interface Horse &#123; runningSpeed: number;&#125;type Animal = Bird | Horse; Use Discriminated Unions: 12345678910111213141516interface Bird &#123; type: &quot;bird&quot;; flyingSpeed: number;&#125;interface Horse &#123; type: &quot;horse&quot;; runningSpeed: number;&#125;type Animal = Bird | Horse;function moveAnimal(animal: Animal) &#123; let speed; switch (animal.type) &#123; case &quot;bird&quot;: speed = animal.flyingSpeed; break; case &quot;horse&quot;: speed = animal.runningSpeed; break; &#125;&#125;","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"TypeScript","slug":"JS-TS/TypeScript","permalink":"https://redre4per.github.io/categories/JS-TS/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://redre4per.github.io/tags/TypeScript/"}]},{"title":"Interface","slug":"Typescript/09 interface","date":"2021-01-10T00:29:31.000Z","updated":"2023-09-11T02:29:09.695Z","comments":true,"path":"2021/01/10/Typescript/09 interface/","link":"","permalink":"https://redre4per.github.io/2021/01/10/Typescript/09%20interface/","excerpt":"","text":"interface An interface is a grammatical structure used to describe the shape of an object. It defines what properties and methods an object should have, as well as their type. Interfaces can be used as type declarations, function parameters, class members, etc. Unlike classes, interfaces are not used as blueprints, but are just custom types. 1234567interface Person &#123; name: string; age: number; greet(phrase: string): void; //How to write method 1, standard syntax form of function sayHello: () =&gt; void; //How to write method 2, in the form of type annotation greet(): (phrase: string) =&gt; void //Function overloaded form. Indicates that the greet function does not accept parameters, but returns a function.&#125; The difference between interface and custom type type In many cases, you can replace interface with type and it will work just like before. But interface and type are not exactly the same. Interface can only be used to describe the structure of an object, and type can also store other objects, such as union types, etc. However, when using an interface, it is clear that it is used to define the structure of an object. Classes should be described with interface instead of type. An interface can be thought of as a contract that a class must adhere to. If you use type to describe a class, you may lose some of the extra features provided by interface, such as extends and implements. Use interface to implement the class To use the keyword implements (implementation). There is a difference between implementation and inheritance. You can implement multiple interfaces at one time, separated by ,. 123456interface Greetable &#123;name: string; greet(phrase: string): void;&#125; class Person implements Greetable &#123;&#125; The class must contain the properties and methods in the implemented interface, and can write properties and methods outside the interface. Therefore, interfaces are often used to share functionality between different classes, regardless of the specific implementation of the functionality (because there can be no implementation or value in the interface). This is a bit like an abstract class, but the interface has no implementation details. By implementing interface, you can easily share functions between subclasses, and each subclass must add its own function implementation (fixed structure, different methods). readonly modifier in interface Private and public modifiers cannot be added to the interface, but readonly can be added. It means that this property can only be set once in any object generated based on this interface, and is read-only thereafter. readonly can also be used on type. If a class implements this interface, even if the corresponding attribute in the class does not write readonly, it cannot be changed. extends of interface Interfaces can extend other interfaces, similar to class inheritance. 123456interface Named &#123; readonly name: string;&#125;interface Greetable extends Named &#123; greet(phrase: string): void;&#125; An interface can extend multiple interfaces, separated by ,. 123interface Greetable extends Named, AnotherInterface &#123; greet(phrase: string): void;&#125; Use interface to define function structure In addition to defining object structures, interfaces can also be used to define functions. (In fact, custom type definition functions are more common) Note that the parameter is followed by : instead of =&gt;. Also, no method name is added here, so it is an anonymous function. 12345interface MyFunc &#123; (a: number, b: number): number;&#125;const add: MyFunc = (a, b) =&gt; a + b;console.log(add(2, 3)); // Output: 5 optional properties and methods Optional properties can be defined in interfaces and classes. Optional properties can be specified by adding ? after the property name. 1234interface Named &#123; readonly name: string; outputName?: string;&#125; How to write optional methods: 12345interface MyInterface &#123; requiredMethod(): void; optionalMethod?(): void; //Function writing method 1 sayHello?: () =&gt; void; //Function writing method 2&#125; If you want to mark the properties initialized by the constructor in the class as optional, you need to use ? in both constructor() and the attribute type declaration of the class (Note: This is not rigorous, see the next paragraph) . Then when using new to create an instance, it is OK if there is no optional attribute in the parameter. In practice these ? are loosely related. For example, you can remove name: string as optional, mark ? in constructor(), and assign a default value in the constructor. Just make it logical. 123456789101112class Person implements Greetable &#123; name?: string; //Use? Identificationoptional age: 30; constructor(n?: string)&#123; //Use? Identificationoptional if(n) &#123; this.name = n; &#125; &#125;&#125; let user1 = mew Person(); //There can be no optional parameters Interface in TS is compiled into JS code The interface does not exist after compilation into JS. The interface is pure TS functionality and is only available during development and compilation (pure development feature).","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"TypeScript","slug":"JS-TS/TypeScript","permalink":"https://redre4per.github.io/categories/JS-TS/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://redre4per.github.io/tags/TypeScript/"}]},{"title":"Inheritance","slug":"Typescript/08 inheritance","date":"2021-01-09T00:29:31.000Z","updated":"2023-09-11T02:12:41.928Z","comments":true,"path":"2021/01/09/Typescript/08 inheritance/","link":"","permalink":"https://redre4per.github.io/2021/01/09/Typescript/08%20inheritance/","excerpt":"","text":"Inheritance Inheritance is used to create subclasses of a class. The subclass has the properties and methods of the parent class, and also has the exclusive properties and methods of the subclass. The keyword for inheritance is extends. Subclasses can only inherit from one parent class, which is different from interface’s implement. Constructor of subclass If the subclass does not write a constructor, the subclass inherits the constructor of the parent class. The incoming parameters and corresponding properties are exactly the same as those of the parent class. 1234class Department &#123; constructor(private name: string, private id: string) &#123;&#125;&#125;class ITDepartment extends Department &#123;&#125; Subclasses have their own constructors When adding your own constructor in a subclass, you must add super() in the subclass. super() accepts the parameters of the parent class constructor. In the constructor, super() should be used before other code. 123456789class Department &#123; constructor(private id: string, private name: string) &#123;&#125;&#125;class ITDepartment extends Department &#123; constructor(private id: string) &#123; super(id, &quot;IT&quot;); //super receives the parameters of the parent class constructor. The first parameter is a variable, and the second parameter is hard-coded by the subclass itself. &#125;&#125;const accounting = new ITDepartment(&quot;d1&quot;); Subclasses can also add new parameters to the constructor. 12345class ITDepartment extends Department &#123; constructor(private id: string, public admins: string[]) &#123; //Add new parameters super(id, &quot;IT&quot;); &#125;&#125; protected modifier Private properties are actually only accessible from within the class in which they are defined, not from within inherited subclasses. For example: 1234567891011121314class Department &#123; private employees: string[] = []; //private constructor(private id: string, private name: string) &#123;&#125;&#125;class ITDepartment extends Department &#123; constructor(private id: string) &#123; super(id, &quot;IT&quot;); &#125; addEmployee(name: string)&#123; this.employees.push(name); //Cannot be added at this time because the employees attribute is private. &#125;&#125;const accounting = new ITDepartment(&quot;d1&quot;);accounting.addEmployee(&quot;derek&quot;); //Cannot be added at this time because the employees attribute is private. At this point we need to use the protected modifier. It ensures that the modified properties&#x2F;methods are available not only within the class, but also in any class that extends the class. getter and setter getter and setter are get and set keywords. They are to give the outside world a way to assign and obtain values in the class, and they can also add logic, such as judgment, etc. before assignment and value acquisition. The getter must return a value. What should be noted here is that although the properties of getters and setters are declared with (), they are not used with (). This means that the setter and getter are not executed as a method, but are only accessed as a property. Getters and setters share property names. Externally, whether it is a getter or a setter will be automatically determined based on assignment or value acquisition. 123456789101112131415161718class Person &#123; private _age: number; //_age, different from age() below get age(): number &#123; return this._age; &#125; set age(newAge: number) &#123; if (newAge &lt; 0) &#123; throw new Error(&quot;Age cannot be negative.&quot;); &#125; this._age = newAge; &#125;&#125; const person = new Person();person.age = -30; // set age (will throw an error) Note that there is no ()console.log(person.age); // get age (will not be executed due to the error) Note that there is no () static static methods and properties The static keyword is used to define static members of a class, which are members that belong to the class itself rather than to instances of the class. **Static members can be methods or properties. A static method is a method that is called directly without relying on an instance of a class. Static methods can access static properties and other static methods, but not instance properties or instance methods. In TS, static methods are defined using the static keyword, for example: 1234567class MyClass &#123; static myStaticMethod() &#123; console.log(&quot;This is a static method.&quot;); &#125;&#125; MyClass.myStaticMethod(); It should be noted that static members cannot be accessed by instantiated objects, only through the class itself. Static members cannot be accessed by non-static members in the class. For example, this.static member in the constructor will report an error. This is because they refer to an instance created based on the class, and static properties are not available on instances. Static members are detached from the instance. If you need to access a static member from a non-static member, you need to replace this with the class name: 1234567class Department &#123; static fiscalYear = 2020; private employees: string[] = []; constructor(private id: string, private name: string) &#123; console.log(Department.fiscalYear); //Class name. Static member &#125;&#125; abstract abstract class An abstract class is a class defined using the abstract keyword. Abstract classes cannot be instantiated, but can only be inherited. Abstract classes are used to force all derived classes to share some common properties and methods without providing specific values in the base class. Abstract classes can contain abstract methods and non-abstract methods. Abstract methods are methods that have no implementation (that is, there is no &#123;&#125; part in the method) and they must be implemented in a derived class. Non-abstract methods are implemented methods, and derived classes can choose whether to override them. A derived class must implement all abstract methods, otherwise it must itself be an abstract class. 123456789101112abstract class Animal &#123; abstract makeSound(): void; //Abstract method, no &#123;&#125; move(): void &#123; console.log(&quot;Moving...&quot;); &#125; //Non-abstract method&#125; class Cat extends Animal &#123; // Derived class makeSound(): void &#123; console.log(&quot;Meow!&quot;); &#125;&#125; const cat = new Cat();cat.makeSound(); // &quot;Meow!&quot;cat.move(); // &quot;Moving...&quot; In the example, Animal is an abstract class, which contains an abstract method makeSound and a non-abstract method move. Cat inherits Animal and implements the makeSound method. Note that the move method is not overridden in Cat, so it inherits the implementation in Animal. The main function of abstract classes is to define some common functions and stipulate that subclasses must implement certain methods, thereby improving code reusability and maintainability. singleton mode and private constructor private constructor The Singleton (single case) pattern is to ensure that there is always only one instance of a class and provide a global access point to obtain the instance. Implementations of the Singleton pattern usually include a private constructor, a static method to obtain the singleton instance, and a static property to save the singleton instance. Singleton instances can only be created once and are managed in static methods. When you need to use a singleton instance, just call the static method. private constructor refers to a constructor that can only be called inside the class. Private constructors are often used to implement patterns such as singleton pattern or factory pattern. Private constructors cannot be called outside the class to create instances of the class, they can only be used inside the class (i.e. ensuring that we cannot call new). 123456789101112131415161718class Singleton &#123; private static instance: Singleton; private constructor() &#123; // ... &#125; public static getInstance(): Singleton &#123; if (!Singleton.instance) &#123; Singleton.instance = new Singleton(); &#125; return Singleton.instance; &#125;&#125; const singleton1 = Singleton.getInstance();const singleton2 = Singleton.getInstance();console.log(singleton1 === singleton2); // true","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"TypeScript","slug":"JS-TS/TypeScript","permalink":"https://redre4per.github.io/categories/JS-TS/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://redre4per.github.io/tags/TypeScript/"}]},{"title":"Class","slug":"Typescript/07 Class","date":"2021-01-08T00:29:31.000Z","updated":"2023-09-11T02:07:20.140Z","comments":true,"path":"2021/01/08/Typescript/07 Class/","link":"","permalink":"https://redre4per.github.io/2021/01/08/Typescript/07%20Class/","excerpt":"","text":"Class &amp; Instances Classes are blueprints for objects. Objects are instances of classes. A class defines what an object looks like and what properties and methods it contains. Classes make it easy to create multiple similar objects. Classes are syntactic sugar for constructors. In TypeScript, class is also a type, just like basic data types (such as string and number) and other custom types. Therefore, we can combine multiple classes into a union type. Concept of class: Class: defines the abstract characteristics of a thing, including its properties and methods Object: instance of a class, generated through new Three major characteristics of object-oriented (OOP): encapsulation, inheritance, and polymorphism Encapsulation: Hide the details of data operation and expose only the external interface. The external caller does not need (and cannot) know the details to access the object through the externally provided interface. This also ensures that the outside world cannot arbitrarily change the data inside the object. Inheritance: A subclass inherits a parent class. In addition to having all the characteristics of the parent class, the subclass also has some more specific characteristics. Polymorphism: Different related classes generated by inheritance can have different responses to the same method. For example, Cat and Dog both inherit from Animal, but implement their own eat method respectively. At this time, for a certain instance, we can directly call the eat method without knowing whether it is Cat or Dog, and the program will automatically determine how to execute eat -Accessors (getters &amp; setters): used to change the reading and assignment behavior of attributes Modifiers: Modifiers are keywords used to qualify the properties of members or types. For example, public means public properties or methods Abstract Class: An abstract class is a base class for other classes to inherit from. Abstract classes are not allowed to be instantiated. Abstract methods in abstract classes must be implemented in subclasses Interfaces: Public properties or methods between different classes, which can be abstracted into an interface. Interfaces can be implemented by classes. A class can only inherit from another class, but can implement multiple interfaces Class writing Capitalize the first letter of class names. Constructor method: constructor is the keyword. It is essentially a function that is bound to the class, and to any objects created based on the class, and is executed when the class creates an object. It is used to do some initialization work for the constructed object. Constructors use this to store parameters into class properties. 1234567class Department &#123; name: string; //You can assign an initial value here with name: string = &quot;default&quot;;, but generally you don&#x27;t do this, instead use a constructor. constructor(n: string) &#123; this.name = n; //Store the parameters in the attribute name. &#125;&#125; Create an instance of a class: Use the keyword new and pass in the parameters required in the constructor. 1const accounting = new Department(&quot;Accounting&quot;); The difference between classes in TS and JS ES6 version of JS In TS, the type of the attribute is first declared, and then the constructor is used to pass in the parameters and assign values to the attribute. In JS, there is no need to declare attribute types, so attributes are not declared in advance. 1234567&quot;use strict&quot; //Compiled JS codeclass Department &#123; //There is no name: string; line constructor(n: string) &#123; this.name = n; &#125;&#125;const accounting = new Department(&quot;Accounting&quot;); ES5 version of JS There are no classes in ES5 JS. So it became a constructor. 12345678&quot;use strict&quot;var Department = (function () &#123; function Department(n) &#123; this.name = n; &#125; return Department;&#125;)var accounting = new Department(&quot;Accounting&quot;); this in TS To reference a property or method of a class from within the class, the this keyword must be used. TS can change the default point of this by declaring this pointer to the method in the class, such as describe(this: Department)&#123;&#125;. In JS, this points to the object in which the function is called. Functions must be called by objects. For example: 123456789101112class Department &#123; name: string; constructor(n: string) &#123; this.name = n; &#125; describe()&#123; console.log(&quot;Department: &quot; + this.name); &#125;&#125;const accounting = new Department(&quot;Accounting&quot;);const accountingCopy = &#123; describe: accounting.describe &#125;;accountingCopy.describe(); //The output is Department: undefind. Because this points to accountingCopy. In TS, this in the method describe(this: Department)&#123;&#125; will always point to the instance of Department. 123456789101112class Department &#123; name: string; constructor(n: string) &#123; this.name = n; &#125; describe(this: Department)&#123; //Let this point to the instance of department console.log(&quot;Department: &quot; + this.name); &#125;&#125;const accounting = new Department(&quot;Accounting&quot;);const accountingCopy = &#123; describe: accounting.describe &#125;;accountingCopy.describe(); //An error will be reported here. Because this in the describe() method cannot find the name attribute of accountingCopy If you add the name attribute to the accountingCopy object, the code will run normally. 12const accountingCopy = &#123; name: &quot;DUMMY&quot;, describe: accounting.describe &#125;;accountingCopy.describe(); //The output is Department: DUMMY. private and public modifiers The properties and methods in the class are accessible from the outside by default (that is, public by default). For example, there is an array in the class, and there are methods in the class to modify the array: 123456class Department &#123; employees: string[] = []; addEmployee(employee: string) &#123; this.employees.push(employee); &#125;&#125; At this time, if we create an instance and write accounting.employees[2] = &quot;Anna&quot;, the employees attribute in the instance can also be modified. But this is not standardized and can easily lead to errors. What we want is that the array can only be modified externally by calling the addEmployee() method in the class. Therefore, you need to use the private attribute at this time. At this time the employees property can only be accessed from within the class. 123456class Department &#123; private employees: string[] = []; addEmployee(employee: string) &#123; this.employees.push(employee); &#125;&#125; Note that methods in a class can also be marked private. 1234567891011121314class Example &#123; private doSomethingPrivate() &#123; console.log(&#x27;This is a private method.&#x27;); &#125; public doSomethingPublic() &#123; console.log(&#x27;This is a public method.&#x27;); this.doSomethingPrivate(); // Private methods can be called in public methods &#125;&#125; const example = new Example();example.doSomethingPublic(); // Public methods can be calledexample.doSomethingPrivate(); // Private methods cannot be called Abbreviation for class instance initialization In the above code, to initialize a property we need to specify the type of the property in the class, and then use this in the constructor to pass the parameters into the initial value: 12345678class Department &#123; private name: string; id: string; constructor(n: string, i: string) &#123; this.name = n; this.id = i; &#125;&#125; Writing this way is cumbersome. You can remove the assignment in the constructor and the attribute declaration in the class, and complete all operations in the constructor parameter at once. At this time, the parameters will still be passed in, and the value will be stored in the created attribute after being passed in. Simplified to: 123class Department &#123; constructor(private name: string, public id: string) &#123;&#125;&#125; It should be noted here that public cannot be omitted at this time. **Because this is an explicit TS directive, it tells TS that you not only want these parameters in the constructor, but also create properties for this class with the exact same names. readonly modifier Used to identify certain fields that cannot be changed after initialization. For example: 123class Department &#123; constructor(private name: string, public readonly id: string) &#123;&#125;&#125; readonly can also be used in interfaces. Use the readonly keyword in the interface to mark a property as a read-only property. The value of this property can only be set when the object is initialized or in the constructor, and cannot be modified again after the object is created.","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"TypeScript","slug":"JS-TS/TypeScript","permalink":"https://redre4per.github.io/categories/JS-TS/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://redre4per.github.io/tags/TypeScript/"}]},{"title":"Funtion types","slug":"Typescript/06 Function types","date":"2021-01-07T00:29:31.000Z","updated":"2023-09-11T02:08:28.579Z","comments":true,"path":"2021/01/07/Typescript/06 Function types/","link":"","permalink":"https://redre4per.github.io/2021/01/07/Typescript/06%20Function%20types/","excerpt":"","text":"Type of function In addition to the types of function parameters, the function itself (return result) also has a type. Function return result type TS is also inferred. You should not set the type explicitly if there is no particular reason to do so, and it is better to use TS inference. The way to explicitly declare the type of a function is: 123function add(n1: number, n2: number): number &#123; return n1 + n2;&#125; If the result of return does not match the explicitly declared type, TS will report an error. void, undefined A function that does not return any value and is of type void (no explicit declaration required). There is a difference between void type and undefined type in TS. The void type indicates that the function does not have a return statement, and the undefined type indicates that the function does not return an actual value when it returns, such as return; (that is, there is a return statement, but it does not return a value). Type of function variable Sometimes we can assign a function to a variable. At this time, the type of the variable is a function. 123456function add(n1: number, n2: number): number &#123; return n1 + n2;&#125; let combineValue: (a: number, b:number) =&gt; number;combineValue = add The function variable type is written as an arrow function. Both parameter type and return type must be written. Type of callback function The parameters of a function can also be functions, that is, callback functions. Type writing: 1234567891011function addAndHandle(n1: number, n2: number, cb: (number) =&gt; void) &#123; const result = n1 + n2; cb(result);&#125;addAndHandle(10, 20, (result) =&gt; &#123; console.log(result);&#125;);addAndHandle(10, 20, (result) =&gt; &#123; console.log(result); return result; //No error reported&#125;); It should be noted here that when the callback function type in the main function is void, if the callback function has a return statement and returns a value, no error will be reported. The void type of the callback function means that any value returned by the callback function will not be used by the main function. Therefore it cannot be used in the main function to obtain data using const result2 = cb(result). Types of arrow functions The type of the arrow function can use the function type annotation, that is, (params) =&gt; returnType, for example: 123type MyFunc = (a: number, b: number) =&gt; number;const add: MyFunc = (a, b) =&gt; a + b;console.log(add(2, 3)); // Output: 5 How to write the interface of the function: 12345interface MyFunc &#123; (a: number, b: number): number;&#125;const add: MyFunc = (a, b) =&gt; a + b;console.log(add(2, 3)); // Output: 5","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"TypeScript","slug":"JS-TS/TypeScript","permalink":"https://redre4per.github.io/categories/JS-TS/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://redre4per.github.io/tags/TypeScript/"}]},{"title":"Types - any, unknown, never","slug":"Typescript/05 Types - any, unknown, never","date":"2021-01-06T00:29:31.000Z","updated":"2023-09-11T01:57:30.790Z","comments":true,"path":"2021/01/06/Typescript/05 Types - any, unknown, never/","link":"","permalink":"https://redre4per.github.io/2021/01/06/Typescript/05%20Types%20-%20any,%20unknown,%20never/","excerpt":"","text":"any The any type is the most flexible type specified in TS, and any basically ensures that the TS compiler cannot check anything. But any also takes away all the benefits brought by TS and should be avoided as much as possible. unknown unknown is more strict than any. unknown is better than any when assigning a value of unknown type to a value of fixed type. The difference is: Assignability A value of type any can be assigned to a variable of any type, and a value of any type can be assigned to a variable of type any , which means that the any type can easily interact with other types. Values of unknown type cannot be directly assigned to variables of other types, nor can values of other types be directly assigned to variables of unknown type. Type checking or type assertion is required before assignment can be made. 123456let userInput: unknown;let userName: string; userInput = 5;userInput = &quot;Derek&quot;;userName = userInput; //Error report. If the userInput type is any, no error will be reported. Type Inference When using the any type, TypeScript does not type check or type infer the variable or value, which means that the any type may mask potential type errors. When using an unknown type, TypeScript performs type checking and type inference on the variable or value, which can help developers better catch potential type errors. Type Safety The TypeScript compiler does not enforce type checking when using the any type, which can lead to potential runtime errors. The TypeScript compiler enforces type checking when using unknown types, which can help developers avoid potential runtime errors. To sum up, the main differences between any and unknown types are in assignability, type inference and type safety. In TypeScript, you should try to avoid using any type. Instead, use unknown type and perform type checking or type assertion when necessary. never Never is the type of function. It means that the function never generates a return value, such as the function directly throws an error, etc. Throwing an error causes the script to crash, so a return value is never generated. 123function generateError(message: string, code: number): never &#123; throw &#123;message: message, errorCode: code&#125;;&#125;","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"TypeScript","slug":"JS-TS/TypeScript","permalink":"https://redre4per.github.io/categories/JS-TS/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://redre4per.github.io/tags/TypeScript/"}]},{"title":"Types - union, literal, custom/aliases","slug":"Typescript/04 Types - union, literal, aliases","date":"2021-01-05T00:29:31.000Z","updated":"2023-09-11T02:09:24.831Z","comments":true,"path":"2021/01/05/Typescript/04 Types - union, literal, aliases/","link":"","permalink":"https://redre4per.github.io/2021/01/05/Typescript/04%20Types%20-%20union,%20literal,%20aliases/","excerpt":"","text":"union union type The writing method is Parameter: Type 1|Type 2|Type 3.... indicates that the parameters can be assigned these types of values. like: 123function combine(input1: string | number, input2: string | number)&#123; const result = input1 + input2; //error report&#125; In the example, const result = input1 + input2 cannot be written directly within the function. This is because TS does not analyze what is in the union type, so it cannot detect whether these values can perform the + operation. Therefore, you have to write the if(typeof...) type detection code within the function yourself. A common use case for union types is to allow a function to receive arguments more flexibly, but then use different logic in the function depending on the exact type obtained. This allows the function to handle many different types of values. But this is not necessary. There may also be scenarios where union is used without subsequent type judgment, depending on the function logic. union can be used to combine type, class and interface. Because they are all types in TS. After union, you can use type a = to get the value. Literal literal type Literal types are based on union types. Literal type means that not only the type of the variable is determined, but the optional value is also determined. In the TS automatic inference of constant, the result is not a certain type, but a fixed value, such as: 1const number2 = 2.8 //The inferred result is const number2: 2.8 In the function of the union type example, if we want to add a third parameter to identify the result type, and the third parameter is a string, according to the previous writing method, we have to add a lot of judgments to the function: 123456function combine(input1: string | number, input2: string | number, result: string)&#123; if(result === &quot;as-number&quot;)&#123;...&#125;; if(result === &quot;as-string&quot;)&#123;...&#125;;&#125;const combinedAges = combine(30, 26, &quot;as-number&quot;);const combinedString = combine(&quot;Hello&quot;, &quot;World&quot;, &quot;as-string&quot;); The flaw here is that when calling the function, enter the third parameter &quot;as-number&quot; or &quot;as-string&quot;, and you must ensure that there are no spelling errors. We could improve this with an enum, but if there are only two possible values, a Literal type is a good choice. like: 12345678function combine(input1: string | number,input2: string | number,result: &quot;as-number&quot; | &quot;as-string&quot;)&#123; if(result === &quot;as-number&quot;)&#123;...&#125;; if(result === &quot;as-string&quot;)&#123;...&#125;;&#125; This way we only allow these two strings as parameters, not any strings. At this time, if we use the result value to make it equal to other strings, TS will directly report an error. Custom types&#x2F;Type Aliases TS supports giving types other names. The keyword type needs to be used, and the first letter of the custom type must be capitalized. like: 1type Combinable = number; //All number types can be replaced by Combinable types. Meaningless. Normally, **custom types can be used in combination with union &#x2F; literal types. ** 12type Combinable = number | string; //All number | string can be replaced by Combinable.type ResultDescription = &quot;as-number&quot; | &quot;as-string&quot;; Custom types are useful because they encode the type into the programmer’s own type name and reuse it in subsequent code. Similar to the extraction function. Custom types are used for object types Custom types can also be used for object types. like: 12type User = &#123; name: string; age: number &#125;;const u1: User = &#123; name: &#x27;Max&#x27;, age: 30 &#125;; // this works! Or simplify the code: 12345678910111213141516171819//////////////////////Before simplifying//////////////////////function greet(user: &#123; name: string; age: number &#125;) &#123; console.log(&#x27;Hi, I am &#x27; + user.name);&#125;function isOlder(user: &#123; name: string; age: number &#125;, checkAge: number) &#123; return checkAge &gt; user.age;&#125; ///////////////////////Simplified/////////////////////type User = &#123; name: string; age: number &#125;;function greet(user: User) &#123; console.log(&#x27;Hi, I am &#x27; + user.name);&#125;function isOlder(user: User, checkAge: number) &#123; return checkAge &gt; user.age;&#125; It is very similar to interface and is usually replaced by interface.","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"TypeScript","slug":"JS-TS/TypeScript","permalink":"https://redre4per.github.io/categories/JS-TS/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://redre4per.github.io/tags/TypeScript/"}]},{"title":"Types - Array, Tuple, Enum","slug":"Typescript/03 Types - array, tuple, enum","date":"2021-01-04T00:29:31.000Z","updated":"2023-09-11T02:10:00.265Z","comments":true,"path":"2021/01/04/Typescript/03 Types - array, tuple, enum/","link":"","permalink":"https://redre4per.github.io/2021/01/04/Typescript/03%20Types%20-%20array,%20tuple,%20enum/","excerpt":"","text":"TS support for arrays The array type is written as array name: data type in array[], such as hobbies: string[]. Using arrays inside and outside objects is exactly the same. Another way to write it is Array&lt;type&gt;, for example hobbies: Array&lt;string&gt;. These two ways of writing are equivalent. TS will also automatically infer the array type if an initial value is assigned to the array (instead of an empty array). like: 1234const person = &#123; name: &quot;Derek&quot;, hobbies: [&quot;Sport&quot;, &quot;Cooking&quot;] //TS will infer the type as hobbies: string[]&#125;; Arrays in TS cannot be of mixed types In TS, if a type is defined for an array, elements of other types cannot be added to it. If you want an array to contain elements of different types, the solutions are: Assign any type to the array. any is flexible, but gives up all the benefits provided by TS. 12let activities: any[];activities = [&quot;Sports&quot;, 1]; Tuple Union type array Tuple Tuple Tuples are fixed-length and fixed-type arrays. Tuples are added by TS. The type is written as role: [number, string];. 12345const person = &#123; name: &quot;Derek&quot;, hobbies: [&quot;Sport&quot;, &quot;Cooking&quot;], role: [2, &quot;author&quot;] //Tuple, TS inferred type is role:(string | number)[], which is a union type, not a tuple&#125;; You can see that the result of TS inference is a union type array, not a tuple. The length of this kind of array is not fixed, you can continue to add elements to it, modify the type of an element, etc. So tuple types need to be explicitly set. 123456789const person: &#123; name: string; hobbies: string; role: [number, string]; //How to write tuple type.&#125; = &#123; name: &quot;Derek&quot;, hobbies: [&quot;Sport&quot;, &quot;Cooking&quot;], role: [2, &quot;author&quot;]&#125;; The assignment to each positional element in the tuple is only the type declared by the tuple. For example, in the above tuple, if the assignment 1234person.role[0] = &quot;Derek&quot;; //Error reportperson.role[1] = 10; //error reportperson.role = [0, &quot;admin&quot;, &quot;user&quot;]; //Error reportperson.role.push(&quot;user&quot;); //No error reported The first three are wrong. But push() is not restricted by tuples. Enum enumeration Enum convention begins with a capital letter. Because enumeration is also a custom type. An enumeration lists all possible values of a variable. 1enum Role &#123; ADMIN, READ_ONLY, AUTHOR &#125;; Enum automatically identifies values as numbers. The default number is the index of the value in the array. When the mouse hovers over the enum value, (enum member) Role.AUTHOR = 2 will be displayed. You can also not use the default numeric identifier and assign it manually: 1enum Role &#123; ADMIN = 5, READ_ONLY = 100, AUTHOR = 200&#125;; If only the first value is manually assigned a numeric ID, subsequent values are automatically assigned increasing numeric IDs. Manually assigned IDs can also be non-numeric. Can also be mixed. like: 1enum Role &#123; ADMIN = &#x27;my_admin&#x27;, READ_ONLY = 100, AUTHOR = 200&#125;; Usage when using enumeration values is: 1let role = Role.ADMIN; //The identification value of the tuple value will be obtained, such as my_admin.","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"TypeScript","slug":"JS-TS/TypeScript","permalink":"https://redre4per.github.io/categories/JS-TS/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://redre4per.github.io/tags/TypeScript/"}]},{"title":"Types - primitive, object","slug":"Typescript/02 Types - primitive, object","date":"2021-01-03T00:29:31.000Z","updated":"2023-09-11T02:10:14.989Z","comments":true,"path":"2021/01/03/Typescript/02 Types - primitive, object/","link":"","permalink":"https://redre4per.github.io/2021/01/03/Typescript/02%20Types%20-%20primitive,%20object/","excerpt":"","text":"Core Types Primitive types: number, string, boolean reference types: object, Array TS exclusive typs: Tuple, Enum, any Primitive types are written in TS as parameter: type, such as n1: number. Type Casting case issue In TS, core primitive types are always lowercase, such as string, number, etc. String, Number, etc. will not appear. TS type inference 123const number1 = 5;const printResult = true;const string1 = &quot;Result is: &quot;; Why is there no type written in the above code? As written: 1234const number1: number = 5;const printResult: boolean = true;const string1: string = &quot;Result is: &quot;;//You can write it like this, but it is redundant and not a good practice. This is because TS has a built-in feature called type inference. This means that TS understands variables and constants because the programmer initialized the variable&#x2F;constant with a number&#x2F;boolean&#x2F;string. Hover the mouse over the variable to see the inferred type. Only when variables&#x2F;constants are not initialized, do you need to manually write the type, such as: 1let number2: number; TS support for object types TS infers the object type. That is, for the properties in the object, there is type inference. If you want to use an attribute that is not in the object, TS will directly report an error. If you manually set the type of the object, for example, just set it to object without writing the internal attribute type of the object, an error will also be reported when using the existing attributes in the object: 12345const person: object = &#123;name: &quot;Derek&quot;,age: 18&#125;;console.log(person.name); //error report Therefore, to manually set the object type, it should be written as: 1234567const person: &#123; name: string; age: number;&#125; = &#123;name: &quot;Derek&quot;,age: 18&#125;; //Correct writing Nested objects When encountering a nested object, the types can be directly nested layer by layer. 123456789&#123; id: string; price: number; tags: string[]; details: &#123; title: string; description: string; &#125;&#125;","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"TypeScript","slug":"JS-TS/TypeScript","permalink":"https://redre4per.github.io/categories/JS-TS/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://redre4per.github.io/tags/TypeScript/"}]},{"title":"Typescript Introduction","slug":"Typescript/01 TS intro","date":"2021-01-02T00:29:31.000Z","updated":"2023-09-11T01:42:43.654Z","comments":true,"path":"2021/01/02/Typescript/01 TS intro/","link":"","permalink":"https://redre4per.github.io/2021/01/02/Typescript/01%20TS%20intro/","excerpt":"","text":"What is TypeScript TS is a superset of JavaScript. TS takes JS and adds new features and syntax to it. TS cannot be executed directly in JS environment (such as browser, node.js). TS is a programming language and a tool. It is a powerful compiler that compiles TS code into JS code. That is, the programmer writes TS code with all the new features and all the benefits, and the result is normal JS code. TS gives programmers the opportunity to find errors in their code while the browser is running, before the script is run. In other words, TS provides additional error checking during project development (compliation). This catches and fixes errors early on. JS can only find errors at runtime. TypeScript overview Types: Many mistakes can be avoided. Next-gen JS features: Use modern JS features and still generate and publish code that works in older browsers. TS-specific features: such as interfaces and Generics (generics). Meta-Programming features: such as Decorators. Rich Configuration Option: TS can be configured and fine-tuned according to requirements to make it more strict or loose. Can be supported in non-TS projects: via modern tools and modern IDEs. Why use TypeScript Since JS variables&#x2F;constants have no type restrictions, the code execution results may be completely different from the original intention. For example: 12345function add(num1, num2)&#123;return num1 + num2;&#125;console.log(add(&#x27;2&#x27;, &#x27;3&#x27;)) //The result is 23 because it is string concatenation.console.log(add(input1.value, input2.value)) //This will make the error more subtle. If you want to solve this problem through JS, you need to add an if conditional judgment to verify the incoming parameters. But using TS, you can find errors while writing code. 12345function add(num1: number, num2: number)&#123;return num1 + num2;&#125;console.log(add(&#x27;2&#x27;, &#x27;3&#x27;)) //Report an error directly at this timeconsole.log(add(+input1.value, +input2.value)) Unary plus operator (+) In JavaScript, you can convert a value to a number using the unary plus operator (+). When the unary plus operator is used before a non-numeric value, JavaScript attempts to convert the value to a number. If the value cannot be converted to a number, NaN is returned. So if you use +input.value in JavaScript, it will try to convert the value of the input element (usually a string) to a numeric type. This can be used to ensure that the value obtained from the input element is of numeric type, rather than a string type, so that correct numerical calculations can be performed in subsequent calculations. A website that can convert TS code into JS code typescriptlang.org","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"TypeScript","slug":"JS-TS/TypeScript","permalink":"https://redre4per.github.io/categories/JS-TS/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://redre4per.github.io/tags/TypeScript/"}]},{"title":"Create new project with Next.js","slug":"NextJS/00 Create new project","date":"2021-01-01T00:29:31.000Z","updated":"2023-09-11T02:13:45.673Z","comments":true,"path":"2021/01/01/NextJS/00 Create new project/","link":"","permalink":"https://redre4per.github.io/2021/01/01/NextJS/00%20Create%20new%20project/","excerpt":"","text":"Packages and plug-ins to be installed in the project next.js engine locking eslint prettier lint-staged vs config testing (jest, cypress) git hooks (husky) conventional commit UI (chakra ui) tailwind daisyUI redux tool kit storybook Next.js It’s in the official documentation. npx create-next-app@latest Then just keep selecting the default option. Next.js contains many settings, such as ESlint and jest related content (written in the document). When asked for the name, enter . to create the project in the current folder. Engine locking In the Next.js project configuration, engine locking is an option that controls whether Next.js should lock the version of the Node.js engine used. When the engine locking option is enabled, Next.js will lock on the Node.js engine version used in the project, which ensures that the same Node.js version is used when building and running the application. This can help avoid issues caused by differences between different versions of the Node.js engine, making applications more stable and reliable. In Next.js’s project configuration, “engine locking” is an option that controls whether Next.js should lock the version of the Node.js engine used. Specifically, when the engine locking option is enabled, Next.js will lock on the Node.js engine version used in the project, which ensures that the same Node.js version is used when building and running the application. This can help avoid issues caused by differences between different versions of the Node.js engine, making applications more stable and reliable. Engine locking is inside webpack. Documentation can be found in npm docs under engines. In the project, you can add the code after the script in package.json: 123456&quot;engineStrict&quot;: true, &quot;engines&quot;: &#123; &quot;node&quot;: &quot;&gt;=14.0.0&quot;, &quot;npm&quot;: &quot;&gt;=8.0.0&quot;, &quot;yarn&quot;: &quot;please-use-npm&quot; //It is forbidden to use yarn &#125;, eslint ESLint can be found in the Next.js documentation. If you use Next.js, it is already installed. eslint has also been set in the script of package.json. The difference between lint and prettier is that prettier beautifies the code, while lint makes the code comply with the rules. The lint config file is in .eslintrc.json. After installing prettier, you need to write new rules here. prettier It can be found in Next.js documentation. 12npm install --save-dev --save-exact prettiernpm install --save-dev eslint-config-prettier After installation, add the following code in .eslintrc.json. Note that there is an order of addition, and it needs to be added after &quot;next/core-web-vitals&quot;. 12&#123; &quot;extends&quot;: [&quot;next&quot;, &quot;prettier&quot;] &#125; //Added content&#123; &quot;extends&quot;: [&quot;next/core-web-vitals&quot;, &quot;next&quot;, &quot;prettier&quot;] &#125; //After adding After that, add a comment to the scripts in package.json: 1&quot;prettier&quot;: &quot;prettier --write .&quot; Then run npm run prettier to automatically beautify the code. The actual instruction executed here is npm run prettier --write .. lint-staged Sometimes I want to upload code, but not all files comply with lint. If lint-staged is not installed, all files must meet the requirements of lint. If lint-staged is present, only staged files need to meet lint requirements. That is, in addition to the changes in commit, there is one more staged changes. 1npm install --save-dev lint-staged vsconfig The file should be created in the .vscode folder in the root directory and named settings.json. You can set part of it in the preference-setting of vscode app. For example, change Files: Auto Save to afterDelay. Can be set in settings.json: 1234&#123; &quot;editor.formatOnSave&quot;: true, //Automatically format code when saving a file &quot;default.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;&#125; At this time, prettier will be used to automatically adjust the format when the entire project is saved. I tried it and found that I can’t automatically use prettier to change the format when I write it this way. But when I delete the line “editor.defaultFormatter”: “esbenp.prettier-vscode”, I can automatically use prettier to change the format. What could be the reason for this? This issue may be caused by a conflict between VS Code’s default formatter and the Prettier plugin. The “editor.defaultFormatter” setting specifies the default formatter, but if another formatter (such as the VS Code default formatter) is registered earlier than Prettier, then it will be used to format the code instead of Prettier. . Testing Next.js has a lot of testing integrated into it. So just click Document to install it. If you use react instead of next, you need to set up a lot more settings. Jest Install Jest: 1npm install --save-dev jest jest-environment-jsdom @testing-library/react @testing-library/jest-dom Then follow the document, create the jest.config.js file in the directory, and paste the content in the document. This document also contains content such as Handling stylesheets and image imports under testing. Then add the command to scripts in package.json: 1&quot;test&quot;: &quot;jest --watch&quot; Create test file: According to the documentation, create the file in the root directory: __tests__/index.test.jsx. Cover rate and the like need to be set in the jest.config.js file. See the jest documentation. Cypress Install Cypress 1npm install --save-dev cypress Then add in package.json scripts: 1&quot;cypress&quot;: &quot;cypress open&quot; There is also how to write cypress in the documentation. git hooks (husky) and conventional commit conventional commit Conventional commit is so that the commit must meet certain rules, such as fix(server): send cors headers. Install: 1npm install --save-dev @commitlint/config-conventional @commitlint/cli Then use the commands in the documentation to create the commitlint.config.js file: 1echo &quot;module.exports = &#123;extends: [&#x27;@commitlint/config-conventional&#x27;]&#125;&quot; &gt; commitlint.config.js Note: The file created in this way is not in utf-8 format, and an error will always be reported when using husky pre-commit. You need to create one with an empty notepad, write the statement and save it as a file in utf-8 format. git hooks (husky) Git hook (husky) is a Git client hook tool that allows developers to execute some custom scripts before or after Git events occur. By using Git hooks, code specification checking, unit testing, code packaging, automatic deployment and other operations can be completed automatically, improving development efficiency and reducing errors. Common Git hooks include pre-commit, post-commit, pre-push, etc. Among them, pre-commit is executed before the code is submitted and can be used to check code style, run unit tests and other operations; post-commit is executed after the code is submitted and can be used to update documents, send emails and other operations; pre-push is Executed before code push, it can be used to check code quality, run end-to-end tests, etc. Install and activate. After activation, the .husky folder will appear: 12npm install husky --save-devnpx husky install Then follow the documentation to add a hook, and in Husky’s own documentation, find and install another Hook: 12npx husky add .husky/commit-msg &#x27;npx --no -- commitlint --edit $&#123;1&#125;&#x27;npx husky add .husky/pre-commit &quot;npm test&quot; Since there is no need to let it run for the time being, use # to comment out npm test in the pre-commit file in .husky: 123#!/usr/bin/env sh. &quot;$(dirname -- &quot;$0&quot;)/_/husky.sh&quot;# npm test At this time, if the text does not comply with the rules during commit, husky will prompt an error. Finally, set the pre-commit check item. First add in scripts in package.json: 1&quot;pre-commit&quot;: &quot;npm run prettier &amp;&amp; npm run lint &amp;&amp; npm run test&quot; At this time, you may need to change the original &quot;test&quot;: &quot;jest --watch&quot; to &quot;test&quot;: &quot;jest&quot;. Then write in the .husky&#x2F;pre-commit file 1npm run pre-commit If there is a problem with husky and it is stuck and cannot be submitted, you should use git commit --no-verify -m &quot;xxx&quot; to temporarily block husky. Tailwind Follow documentation to install tailwind. Here -D and -dev are the same. 12npm install -D tailwindcss postcss autoprefixernpx tailwindcss init -p Then follow the documentation to replace the content in the tailwind.config.js file with: (The following may not be the latest, please refer to the documentation) 123456789101112131415/** @type &#123;import(&#x27;tailwindcss&#x27;).Config&#125; */module.exports = &#123; content: [ &quot;./app/**/*.&#123;js,ts,jsx,tsx&#125;&quot;, &quot;./pages/**/*.&#123;js,ts,jsx,tsx&#125;&quot;, &quot;./components/**/*.&#123;js,ts,jsx,tsx&#125;&quot;, // Or if using `src` directory: &quot;./src/**/*.&#123;js,ts,jsx,tsx&#125;&quot;, ], theme: &#123; extend: &#123;&#125;, //The content of design system is written here. Documentation: https://tailwindcss.com/docs/theme &#125;, plugins: [],&#125; Then delete the contents of the globals.css file and replace it with: 123@tailwind base;@tailwind components;@tailwind utilities; Then set tailwind Automatic IntelliSense in the .vscode&#x2F;settings.json file (requires the Tailwind CSS IntelliSense plug-in to be installed): 123456&quot;editor.quickSuggestions&quot;: &#123; &quot;strings&quot;: true&#125;,&quot;tailwindCSS.experimental.classRegex&quot;: [ &quot;([\\&quot;&#x27;])(?:tw|tw-s|tw-state)\\\\(([^)]+)\\\\1&quot;] daisyUI daisyUI is a plug-in for tailwind. Install: 1npm i daisyui Then add daisyui in the tailwind.config.js file. 1234module.exports = &#123; //... plugins: [require(&quot;daisyui&quot;)],&#125; Redux-toolkit Install according to Documentation. 12npm install @reduxjs/toolkitnpm install react-redux According to document, you need to install it in store&#x2F;store.ts (the document says app&#x2F;store.js): 12345678910import &#123; configureStore &#125; from &#x27;@reduxjs/toolkit&#x27; export const store = configureStore(&#123; reducer: &#123;&#125;,&#125;) // Infer the `RootState` and `AppDispatch` types from the store itselfexport type RootState = ReturnType&lt;typeof store.getState&gt;// Inferred type: &#123;posts: PostsState, comments: CommentsState, users: UsersState&#125;export type AppDispatch = typeof store.dispatch Finally, install the provider in _app.tsx under the pages folder (if there is a UI package outside the component, the provider must be outside the UI): 12345678910import &#123; store &#125; from &#x27;../store/store&#x27;; //provider relatedimport &#123; Provider &#125; from &#x27;react-redux&#x27;; //provider related export default function App(&#123; Component, pageProps &#125;: AppProps) &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;Component &#123;...pageProps&#125; /&gt; &lt;/Provider&gt; )&#125; Storybook There are a lot of configurations required to use storybook and tailwind together, please refer to Document, Video. Other settings There are also some other settings for cc-app later in the video. Among the more useful ones are: .eslintignore Some officially recommended plugins in .eslintrc and some tips in rules. .prettierignore Set prettier rules in .prettierrc …","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"Next.js","slug":"Front-end/Next-js","permalink":"https://redre4per.github.io/categories/Front-end/Next-js/"}],"tags":[{"name":"Next.js","slug":"Next-js","permalink":"https://redre4per.github.io/tags/Next-js/"}]}],"categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"ES6","slug":"JS-TS/ES6","permalink":"https://redre4per.github.io/categories/JS-TS/ES6/"},{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/categories/Test/"},{"name":"React-testing-library","slug":"Test/React-testing-library","permalink":"https://redre4per.github.io/categories/Test/React-testing-library/"},{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Stripe payment","slug":"Others/Stripe-payment","permalink":"https://redre4per.github.io/categories/Others/Stripe-payment/"},{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"},{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"},{"name":"Other","slug":"Others/Other","permalink":"https://redre4per.github.io/categories/Others/Other/"},{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"https://redre4per.github.io/categories/HTML-CSS/"},{"name":"CSS","slug":"HTML-CSS/CSS","permalink":"https://redre4per.github.io/categories/HTML-CSS/CSS/"},{"name":"Database","slug":"Database","permalink":"https://redre4per.github.io/categories/Database/"},{"name":"MongoDB","slug":"Database/MongoDB","permalink":"https://redre4per.github.io/categories/Database/MongoDB/"},{"name":"Express.js","slug":"Back-end/Express-js","permalink":"https://redre4per.github.io/categories/Back-end/Express-js/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"},{"name":"Axios","slug":"Front-end/Axios","permalink":"https://redre4per.github.io/categories/Front-end/Axios/"},{"name":"Vanilla JavaScript","slug":"JS-TS/Vanilla-JavaScript","permalink":"https://redre4per.github.io/categories/JS-TS/Vanilla-JavaScript/"},{"name":"TypeScript","slug":"JS-TS/TypeScript","permalink":"https://redre4per.github.io/categories/JS-TS/TypeScript/"},{"name":"Next.js","slug":"Front-end/Next-js","permalink":"https://redre4per.github.io/categories/Front-end/Next-js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://redre4per.github.io/tags/ES6/"},{"name":"Promise","slug":"Promise","permalink":"https://redre4per.github.io/tags/Promise/"},{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/tags/Test/"},{"name":"React-testing-library","slug":"React-testing-library","permalink":"https://redre4per.github.io/tags/React-testing-library/"},{"name":"Stripe","slug":"Stripe","permalink":"https://redre4per.github.io/tags/Stripe/"},{"name":"Payment","slug":"Payment","permalink":"https://redre4per.github.io/tags/Payment/"},{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"},{"name":"Mongoose","slug":"Mongoose","permalink":"https://redre4per.github.io/tags/Mongoose/"},{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"},{"name":"Hooks","slug":"Hooks","permalink":"https://redre4per.github.io/tags/Hooks/"},{"name":"VSCode","slug":"VSCode","permalink":"https://redre4per.github.io/tags/VSCode/"},{"name":"CSS","slug":"CSS","permalink":"https://redre4per.github.io/tags/CSS/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://redre4per.github.io/tags/MongoDB/"},{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"Express.js","slug":"Express-js","permalink":"https://redre4per.github.io/tags/Express-js/"},{"name":"npm","slug":"npm","permalink":"https://redre4per.github.io/tags/npm/"},{"name":"Axios","slug":"Axios","permalink":"https://redre4per.github.io/tags/Axios/"},{"name":"Vanilla JavaScript","slug":"Vanilla-JavaScript","permalink":"https://redre4per.github.io/tags/Vanilla-JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://redre4per.github.io/tags/TypeScript/"},{"name":"Next.js","slug":"Next-js","permalink":"https://redre4per.github.io/tags/Next-js/"}]}