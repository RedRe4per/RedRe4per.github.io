{"meta":{"title":"Derek Zhu's Blog","subtitle":"Derek Blog","description":"Derek Blog, originated from my notes","author":"Derek Zhu","url":"https://RedRe4per.github.io","root":"/"},"pages":[],"posts":[{"title":"Promise basic","slug":"JavaScript/ES6/4 Promise basic","date":"2022-11-06T07:07:12.000Z","updated":"2023-09-11T01:16:03.606Z","comments":true,"path":"2022/11/06/JavaScript/ES6/4 Promise basic/","link":"","permalink":"https://redre4per.github.io/2022/11/06/JavaScript/ES6/4%20Promise%20basic/","excerpt":"","text":"Promise: A new solution for asynchronous programming introduced in ES6. Promises are mainly to solve the previous problem of callback hell. Promise is a constructor that encapsulates an asynchronous operation and can get its success or failure result. Promise accepts a function parameter, this function parameter has two formal parameters, the first is success (resolved by default), and the second is failure (reject by default). When calling resolve() Promise takes the success path, calling reject() takes the failure path. 1234567891011//Instantiate a Promise objectconst p = new Promise(function(resolve, reject)&#123; //resolve &amp; reject. It&#x27;s just an unspoken rule, you can name it yourself setTimeout(function()&#123; let data = &#x27;obj in database&#x27;; if(Math.random()&gt;0.5)&#123; resolve(data); //custom &#x27;success&#x27; &#125;else&#123; reject(data); //custom &#x27;failure&#x27; &#125; &#125;, 1000);&#125;); After success or failure, the then() method of the Promise object can be called. The then() method accepts two function-type parameters. Both function parameters have formal parameters. The successful formal parameter is generally called value, and the failed formal parameter is generally called reason. 1p.then(function(value)&#123;&#125;, function(reason)&#123;&#125;) The first function argument in then() is called when the Promise status is fulfilled. where value is the parameter of the previous resolve(). 123p.then(function(value)&#123; console.log(value) //The value value is the parameter passed in by resolve() in the previous Promise&#125;, function(reason)&#123;&#125;) When the Promise status is rejected, the second function argument in then() is called. where the reason value is the parameter of the previous reject(). 1234p.then(function(value)&#123; &#125;,function(reason)&#123; console.log(reason) //The reason value is the parameter passed in by reject() in the previous Promise.&#125;) Promise encapsulates an example of an Ajax request. Ajax request for JS in ES5 123456789101112const xhr = new XMLHttpRequest(); //The first step: create an objectxhr.open(&quot;GET&quot;,&quot;http://api.apiopen.top/getJoke&quot;); //Part 2: Initializationxhr.send(); //The third step: sendxhr.onreadystatechange = function()&#123; //Step 4: Bind events and process response results if(xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123; console.log(xhr.response); //Processing successful results &#125;else&#123; console.error(xhr.status); //Process the result of failure &#125; &#125;&#125; Encapsulating Ajax with Promises 123456789101112131415161718192021const p = new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;,&quot;http://api.apiopen.top/getJoke&quot;); xhr.send(); xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123; resolve(xhr.response); //Declare success first, and pass parameters to then() before processing &#125;else&#123; reject(xhr.status); //Declare failure first, and pass parameters to then() before processing &#125; &#125; &#125;&#125;)// Specify success/failure callbackp.then(function(value)&#123; console.log(value) //Success, pass in the parameter xhr.response of resolve() as the actual parameter of the formal parameter value.&#125;,function(reason)&#123; console.err(reason) //If it fails, pass in the parameter xhr.status of reject() as the actual parameter of the formal parameter reason.&#125;) This example shows that Promises handle asynchronous success&#x2F;failure results differently than in ES5. It turns out that ES5 operates in the callback function, and now the callback is specified by the then() method after the asynchronous task. This is clearly structured and doesn’t create callback hell problems. then() function Promise instances have a then() method, that is, the then() method is defined on the prototype object Promise.prototype. Parameter 2 is optional. The return result of then() is also a Promise object. 12345678910111213const p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;ERROR!&#x27;) &#125;, 1000)&#125;)const result = p.then(value =&gt; &#123; console.log(value)&#125;, reason =&gt; &#123; console.warn(reason)&#125;)console.log(result); //The result is a Promise object, and the result is resolved/fulfilled (new version) The return result of the then() method The state of the Promise object is determined by the execution result of the callback function. If the result returned in the callback function is non promise type data, status is success, and the return value is the success value of the object. 12345678const result = p.then(value =&gt; &#123; console.log(value) return &#x27;success!&#x27;;&#125;, reason =&gt; &#123; console.warn(reason)&#125;)console.log(result); //The status of the result is &#x27;resolved&#x27; and the value is &#x27;success!&#x27;. When no return is written, the default return result inside the function is undefined. undefined is not a Promise type object, so the return status result is also success. 12345678const result = p.then(value =&gt; &#123; console.log(value) //return &#x27;success!&#x27;; no return&#125;, reason =&gt; &#123; console.warn(reason)&#125;)console.log(result); //The status of the result is &#x27;resolved&#x27; and the value is undefined. If the result returned in the callback function is a promise object, the state returned by the internal promise object determines the return of the then() method The state of the promise, and the value of the internal promise is the value of the promise returned by the then() method. 12345678910const result = p.then(value =&gt; &#123; console.log(value) return new Promise((resolve, reject) =&gt; &#123; //The return status of this promise determines the status of the promise returned by the then() method. resolve(&#x27;ok&#x27;); &#125;)&#125;, reason =&gt; &#123; console.warn(reason)&#125;)console.log(result); //The status of the result is &#x27;resolved&#x27; and the value is &#x27;ok&#x27;. 123456789const result = p.then(value =&gt; &#123; console.log(value) return new Promise((resolve, reject) =&gt; &#123; //reject, similarly reject(&#x27;error&#x27;); &#125;, reason =&gt; &#123; console.warn(reason)&#125;)console.log(result); //The status of the result is &#x27;rejected&#x27; and the value is error. If an error is thrown, then() returns a promise with a status of rejected and value as the value of the thrown error. Note that throw new Error(&#39;test&#39;); and reject(new Error(&#39;test&#39;)); are equivalent. 123456789const result = p.then(value =&gt; &#123; console.log(value) throw new Error(&#x27;Error diagnosis&#x27;) //Throwing an error, there is a throw, such as throw &#x27;ERROR&#x27;; also acceptable. &#125;)&#125;, reason =&gt; &#123; console.warn(reason)&#125;)console.log(result); //The status of the result is &#x27;rejected&#x27; and the value is &#x27;Error diagnosis&#x27;. The chained invocation of the then() method, and the reason parameter can be omitted 1234p.then(value =&gt; &#123;&#125;).then(value =&gt; &#123;&#125;).then(value =&gt; &#123;&#125;) Callback hell can be avoided by chaining calls. Chain call example: Each call passes in new data and saves all data on the chain. 12345678910111213141516171819202122const p = new Promise((resolve, reject) =&gt; &#123; //The first promise on the chain fs.readFile(&quot;./resources/file1.md&quot;, (err, data) =&gt; &#123; //node.js syntax resolve(data); &#125;);&#125;);p.then(value =&gt; &#123; //The 2nd promise on the chain return new Promise((resolve, reject) =&gt; &#123; fs.readFile(&quot;./resources/file2.md&quot;, (err, data) =&gt; &#123; resolve([value, data]); //The value is the data of file1, and the data is the data of file2. &#125;); &#125;);&#125;).then(value =&gt; &#123; //The 3rd promise on the chain。Note that value here is the resolve value of the second promise on the chain:[value, data], which is the data of file1 and file2. return new Promise((resolve, reject) =&gt; &#123; fs.readFile(&quot;./resources/file3.md&quot;, (err, data) =&gt; &#123; value.push(data); resolve(value); &#125;); &#125;);&#125;).then(value =&gt; &#123; //The value value is the content (array of) of the first three files console.log(value.join(&#x27;\\r\\n&#x27;)); //combine&#125;) Break the Promise chain In promise chains without catch(), each then() on the chain has two function arguments, success and failure. But note that whether it succeeds or fails (return non-Promise, return a successful Promise, throw an error), it will trigger then() on the next chain. If you want to end the chain call directly after a then() in the chain fails to trigger, you need to call a Promise instance with a initialized state in the then() failure function. 1return new Promise(() =&gt; &#123;&#125;); catch() Promise.prototype.catch() is syntactic sugar for .then(null, rejection), catch() method is used to specify the callback of Promise failure, which can uniformly handle errors on the Promise chain. Even if catch() is used, all then()s in the chain do not need to write failure callbacks. 12345const p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&quot;Error!&quot;); &#125;, 1000)&#125;); 123p.then(function(value)&#123;&#125;, function(reason)&#123; //Method 1: Specify the failed callback through then() console.error(reason)&#125;) 123p.catch(function(reason)&#123; //Method 2: Specify the failure callback through catch(). Use the first value argument to write then(). console.error(reason)&#125;) Micro task, Macro task The code in new Promise(), except asynchronous code and resolve, will be executed directly in synchronous order. And resolve will be put into the micro task queue, so it will be executed after the synchronous code is executed. The code in promise.then() is asynchronous and placed in the micro task queue. So the execution order is after the synchronous code. And promise only has three states: pending, fulfilled, rejected. Therefore, as long as resolve or reject is encountered, the state will be condensed, and the following fulfilled, rejected, if any, will not be executed. But if there is other code behind the resolve or reject code, such as console.log(), then this part of the code will continue to be executed synchronously. If the promise is pending, neither .then() nor .catch() will execute. If there are two asynchronous tasks, one is a micro task such as promise, and the other is a macro task such as setTimeout, then the micro will be executed first, and then the macro will be executed. Therefore, the code execution order is, synchronization &gt; micro task &gt; macro task. At the same time, after each macro task or micro task is executed, the system will recheck the macro task queue and macro task queue. Therefore, newly generated tasks with high priority will be executed first.","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"ES6","slug":"JS-TS/ES6","permalink":"https://redre4per.github.io/categories/JS-TS/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://redre4per.github.io/tags/ES6/"},{"name":"Promise","slug":"Promise","permalink":"https://redre4per.github.io/tags/Promise/"}]},{"title":"Rerender jest-axe","slug":"Test/React-testing-library/07 Rerender jest-axe","date":"2022-10-18T06:16:12.000Z","updated":"2022-11-10T15:26:02.774Z","comments":true,"path":"2022/10/18/Test/React-testing-library/07 Rerender jest-axe/","link":"","permalink":"https://redre4per.github.io/2022/10/18/Test/React-testing-library/07%20Rerender%20jest-axe/","excerpt":"","text":"render() rerender is used to simulate props changing. How to get rerender(): 1const &#123;rerender&#125; = render(&lt;FavoriteNumber /&gt;); rerender() uses and passes parameters rerender() is used to test the new props of the component, so its argument is the component with props. 12...rerender(&lt;FavoriteNumber max=&#123;10&#125; /&gt;) axe() axe() is a helper for jest. Can be used to help us check various properties of the container. Note that axe is asynchronous. 1234567import &#123;axe&#125; from &#x27;jest-axe&#x27;test(&#x27;the form is accessible&#x27;, async() =&gt; &#123; const &#123;container&#125; = render(&lt;Form /&gt;) const results = await axe(container) expect(results.violations).toHaveLength(0)&#125;) The above method uses axe(), but does not get a useful error message. So you can use the special methods that come with axe() . 12345678import &#123;axe, toHaveNoViolations&#125; from &#x27;jest-axe&#x27;import &#x27;jest-axe/extend-expect&#x27; //Replace expect.extend(toHaveNoViolations), simplify the codetest(&#x27;the form is accessible&#x27;, () =&gt; &#123; const &#123;container&#125; = render(&lt;Form /&gt;) const results = await axe(container) expect(results).toHaveNoViolations()&#125;)","categories":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/categories/Test/"},{"name":"React-testing-library","slug":"Test/React-testing-library","permalink":"https://redre4per.github.io/categories/Test/React-testing-library/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/tags/Test/"},{"name":"React-testing-library","slug":"React-testing-library","permalink":"https://redre4per.github.io/tags/React-testing-library/"}]},{"title":"Jest test methods","slug":"Test/React-testing-library/06 Jest test methods","date":"2022-10-18T01:26:45.000Z","updated":"2022-11-10T15:23:03.513Z","comments":true,"path":"2022/10/18/Test/React-testing-library/06 Jest test methods/","link":"","permalink":"https://redre4per.github.io/2022/10/18/Test/React-testing-library/06%20Jest%20test%20methods/","excerpt":"","text":"Format expect(A).ValidateItem() is used in React testing library and Jest to verify functionality. Expect() Assertion Summary 1 [Expect() Assertion Summary 2](https://www.w3cschool.cn/jest_cn/ jest_expect.html) ​ Usage Test call&#x2F;disable expect() parameters Validation item method meaning events such as onClick toBeCalled() expect to be called events such as onClick toBeCalledTimes(x) expect to be called x times button toBeCalledWith(x) Expected to be called by the x event button toBeDisabled() expect button to be disabled Value comparison expect() parameters Validation item method meaning input toHaveValue(x) expect input value x DOM toHaveClass(x) expects DOM to have className x DOM toHaveTextContent(x) expects DOM to have literal x DOM toHaveTextContent(x) expects DOM to have literal x Hook, value, other toBe() expect equal variable name toBeWithinRange(a, b) Expected value is in range properties&#x2F;properties of the axe result toHaveLength(x) expect arr length equal to x Component testing expect() parameters Validation item method meaning asFragment() toMatchSnapshot() Expect no changes to components queryByX(‘x’) toBeNull() expect component x not to be rendered queryByX(‘x’) (.not).toBeInTheDocument() expect component x (not) in file jest-axe method expect() parameters Validation item method meaning axe result toHaveNoViolations(0) axe’s violations array has length 0 Other usage Test whether a child element contains a class name 12345678910test(&quot;Test whether the child element contains a class name&quot;, () =&gt; &#123; const Demo = (&#123; loading &#125;) =&gt; ( &lt;button aria-label=&quot;Button&quot;&gt; &lt;span className=&#123;loading ? &quot;loading&quot; : &quot;button&quot;&#125;&gt;button&lt;/span&gt; &lt;/button&gt; ); const &#123; baseElement &#125; = render(&lt;Demo loading /&gt;); const ele = baseElement.getElementsByClassName(&quot;loading&quot;); expect(ele.length).toBe(1);&#125;); Test the asynchronous call event 1await waitFor(() =&gt; expect(fn).toBeCalledWith(&quot;click&quot;)); 1234test(&#x27;is divisible by external value&#x27;, async () =&gt; &#123; await expect(100).toBeDivisibleByExternalValue(); await expect(101).not.toBeDivisibleByExternalValue();&#125;); await waitForNextUpdate(); Wait for the next update, default will wait 1000 milliseconds. Timer e&#x3D;method meaning jest.useFakeTimers() use fakeTimer jest.runAllTimers() execute all timers jest.useRealTimers() use realTimer ​ Custom matcher function Similar to expect.toXXXX() , we can customize the matcher function. 1234567891011121314151617181920212223242526272829303132333435363738import &#123;expect&#125; from &#x27;@jest/globals&#x27;;function toBeWithinRange(actual, floor, ceiling) &#123; if ( typeof actual !== &#x27;number&#x27; || typeof floor !== &#x27;number&#x27; || typeof ceiling !== &#x27;number&#x27; ) &#123; throw new Error(&#x27;These must be of type number!&#x27;); &#125; const pass = actual &gt;= floor &amp;&amp; actual &lt;= ceiling; if (pass) &#123; return &#123; message: () =&gt; `expected $&#123;this.utils.printReceived( actual, )&#125; not to be within range $&#123;this.utils.printExpected( `$&#123;floor&#125; - $&#123;ceiling&#125;`, )&#125;`, pass: true, &#125;; &#125; else &#123; return &#123; message: () =&gt; `expected $&#123;this.utils.printReceived( actual, )&#125; to be within range $&#123;this.utils.printExpected( `$&#123;floor&#125; - $&#123;ceiling&#125;`, )&#125;`, pass: false, &#125;; &#125;&#125;expect.extend(&#123; toBeWithinRange,&#125;);","categories":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/categories/Test/"},{"name":"React-testing-library","slug":"Test/React-testing-library","permalink":"https://redre4per.github.io/categories/Test/React-testing-library/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/tags/Test/"},{"name":"React-testing-library","slug":"React-testing-library","permalink":"https://redre4per.github.io/tags/React-testing-library/"}]},{"title":"FireEvent to simulate user operation","slug":"Test/React-testing-library/05 FireEvent to simulate user operation","date":"2022-10-17T12:36:19.000Z","updated":"2022-11-17T03:32:41.405Z","comments":true,"path":"2022/10/17/Test/React-testing-library/05 FireEvent to simulate user operation/","link":"","permalink":"https://redre4per.github.io/2022/10/17/Test/React-testing-library/05%20FireEvent%20to%20simulate%20user%20operation/","excerpt":"","text":"fireEvent fireEvent was originally in the @testing-library&#x2F;dom package, but @testing-library&#x2F;react rewrote it and gave it additional React-specific functionality. It can simulate user actions to trigger events. usage instruction event fireEvent.click(DOM) mouse click on the DOM fireEvent.change(input, { target: { value: “x” } }); User enters x fireEvent.mouseOver(DOM); Move the mouse into the DOM fireEvent.keyPress(inputEl, { key: “Enter”, code: “Enter”, charCode: 13 }); keyboard press event Note that in fireEvent.change(input, &#123; target: &#123; value: &quot;x&quot; &#125; &#125;);, &#39;&#39; should be used here even if the input format is a number.","categories":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/categories/Test/"},{"name":"React-testing-library","slug":"Test/React-testing-library","permalink":"https://redre4per.github.io/categories/Test/React-testing-library/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/tags/Test/"},{"name":"React-testing-library","slug":"React-testing-library","permalink":"https://redre4per.github.io/tags/React-testing-library/"}]},{"title":"Methods to get DOM","slug":"Test/React-testing-library/04 Methods to get DOM","date":"2022-10-17T05:12:27.000Z","updated":"2022-11-10T14:57:42.584Z","comments":true,"path":"2022/10/17/Test/React-testing-library/04 Methods to get DOM/","link":"","permalink":"https://redre4per.github.io/2022/10/17/Test/React-testing-library/04%20Methods%20to%20get%20DOM/","excerpt":"","text":"Aria-label try not to use role and aria-label in css. It’s all about accessibility. aria-label=&quot;cancelbtn&quot;, will read cancelbtn directly. So aria-label is for reading. If there is no aria-label, the value of role will be pronounced. If there is no role, read the default role, the button tag in html. When both aria-label and role exist, role will be read after aria-label is read. If you write this, use the reader to test. Therefore, do not use role indiscriminately, the consequences are very serious. Many websites now have cookies, which are mandated by the GDPR. Europe and the United States will be fined. Get the source of the DOM method These method sources are all destructuring of render(&lt;component&gt;), such as: 123const &#123;getByLableText, getByRole, rerender, debug&#125; = render( &lt;FavoriteNumber /&gt;,) ​ Websites and plugins to help get the DOM Website for testing elements: https://testing-playground.com/. Chrome plugin for testing elements: Testing Playground. ​ getByRole(). For testing, getByRole() is preferred. Its parameter is the text in html. ​ getByTestId() The test can get the element with screen.getByTestId(“id”) . The id needs to be annotated with data-testid &#x3D; {} in the body element. Everything that starts with data is useless to html, only for test. ​ getByLabelText() Get the element using the id in the Label. queryByRole() This method is similar to getByRole(). The difference between them is that when the test component is not rendered, if the component is not found, the error message of getByRole() will be bad. And queryByRole() is designed for this situation.","categories":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/categories/Test/"},{"name":"React-testing-library","slug":"Test/React-testing-library","permalink":"https://redre4per.github.io/categories/Test/React-testing-library/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/tags/Test/"},{"name":"React-testing-library","slug":"React-testing-library","permalink":"https://redre4per.github.io/tags/React-testing-library/"}]},{"title":"Render, debug","slug":"Test/React-testing-library/03 Render, debug","date":"2022-10-17T01:38:05.000Z","updated":"2022-11-10T14:51:27.497Z","comments":true,"path":"2022/10/17/Test/React-testing-library/03 Render, debug/","link":"","permalink":"https://redre4per.github.io/2022/10/17/Test/React-testing-library/03%20Render,%20debug/","excerpt":"","text":"Simple reusable rendering method In this method, we pass in the component as a parameter: 12345function render(ui) &#123; const div = document.createElement(&#x27;div&#x27;) ReactDOM.render(&lt;FavoriteNumber /&gt;, div) getQueriesForElement(div)&#125; But there is no return here. We need to return an object with all queries. At the same time, we’re going to rename the div to container and add it to return . 123456789101112function render(ui) &#123; const container = document.createElement(&#x27;div&#x27;) ReactDOM.render(ui, container) const queries = getQueriesForElement(container) return &#123;container, ...queries&#125;&#125;test(&#x27;renders a number input with a label &quot;Favorite Number&quot;&#x27;, () =&gt; &#123; const &#123;getByLabelText&#125; = render(&lt;FavoriteNumber /&gt;) const input = getByLabelText(/favorite number/i) expect(input).toHaveAttribute(&#x27;type&#x27;, &#x27;number&#x27;)&#125;) In this code, we replace the previous three lines of code with render to make it generic. 1const &#123;getByLabelText&#125; = render(&lt;FavoriteNumber /&gt;) //new 123const div = document.createElement(&#x27;div&#x27;) // old is replaced.ReactDOM.render(&lt;FavoriteNumber /&gt;, div)const &#123;getByLabelText&#125; = getQueriesForElement(div) ​ Using the built-in render method Actually, the render method already exists in the react testing library. 1import &#123;render&#125; from &#x27;@testing-library/react&#x27; ​ Use debug to find errors debug and debug() can be used anywhere, with or without arguments. debug() can see what the DOM looks like at this node. E.g: 1234567test(&#x27;renders a number input with a label &quot;Favorite Number&quot;&#x27;, () =&gt; &#123; const &#123;getByLabelText, debug&#125; = render(&lt;FavoriteNumber /&gt;) debug() const input = getByLabelText(/favorite number/i) expect(input).toHaveAttribute(&#x27;type&#x27;, &#x27;number&#x27;) debug(input)&#125;) ​","categories":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/categories/Test/"},{"name":"React-testing-library","slug":"Test/React-testing-library","permalink":"https://redre4per.github.io/categories/Test/React-testing-library/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/tags/Test/"},{"name":"React-testing-library","slug":"React-testing-library","permalink":"https://redre4per.github.io/tags/React-testing-library/"}]},{"title":"Jest DOM, DOM testing","slug":"Test/React-testing-library/02 Jest DOM, DOM testing","date":"2022-10-16T08:56:27.000Z","updated":"2022-11-10T14:45:02.811Z","comments":true,"path":"2022/10/16/Test/React-testing-library/02 Jest DOM, DOM testing/","link":"","permalink":"https://redre4per.github.io/2022/10/16/Test/React-testing-library/02%20Jest%20DOM,%20DOM%20testing/","excerpt":"","text":"A simple test example 1234567891011import React from &#x27;react&#x27;import &#123;FavoriteNumber&#125; from &#x27;../favorite-number&#x27;import ReactDOM from &#x27;react-dom&#x27;test(&#x27;renders a number input with a label &quot;Favorite Number&quot;&#x27;, () =&gt; &#123; const div = document.createElement(&#x27;div&#x27;) ReactDOM.render(&lt;FavoriteNumber /&gt;, div) console.log(div.innerHTML) //You can use console.log to see the results in the terminal. expect(div.querySelector(&#x27;input&#x27;).type).toBe(&#x27;number&#x27;) expect(div.querySelector(&#x27;label&#x27;).textContent).toBe(&#x27;Favorite Number&#x27;))&#125;) The result can be seen in the terminal. expect(div.querySelector(&#39;label&#39;).textContent).toBe(&#39;Favorite Number&#39;)) can be reversed to verify that the false output passes the test. If the result is fail, assertions run normally. ​ Using Jest DOM to boost assertions In the previous method, the error message is not helpful. For example, if the input is wrong in div.querySelector(&#39;input&#39;), an error TypeError: Cannot read property &#39;type&#39; of null will be reported, and it will be marked in div on. We use testing-library&#x2F;jest-dom to solve this problem. It has many methods, such as &#123;toHaveAttribute, toHaveTextContent&#125; . To simplify this code, such as expect.extend(jestDom), use import &#39;@testing-library/jest-dom/extend-expect&#39; to import the package. Or you can automatically import this package in jest.setup.js for all files. The modified assertion is: 12345678import &#x27;@testing-library/jest-dom/extend-expect&#x27;test(&#x27;renders a number input with a label &quot;Favorite Number&quot;&#x27;, () =&gt; &#123; const div = document.createElement(&#x27;div&#x27;) ReactDOM.render(&lt;FavoriteNumber /&gt;, div) expect(div.querySelector(&#x27;input&#x27;)).toHaveAttribute(&#x27;type&#x27;,&#x27;number&#x27;) expect(div.querySelector(&#x27;label&#x27;)).toHaveTextContent(&#x27;Favorite Number&#x27;)&#125;) At this time, if the input is written incorrectly, the error will become: 12expect(received).toHaveAttribute()received value must be an HTMLElement or an SVGElement. Received has value: null At this point it is easier to understand and fix. Use assertions to ensure label and element match exactly If there is no match, if the value of htmlFor in label is modified, the test can still pass. But there will be an error when the screen reader reads it. We can use an assertion to get the element corresponding to the label. 123456789import &#123;queries&#125; from &#x27;@testing-library/dom&#x27; // can be done in the configuration filetest(&#x27;renders a number input with a label &quot;Favorite Number&quot;&#x27;, () =&gt; &#123; const div = document.createElement(&#x27;div&#x27;) ReactDOM.render(&lt;FavoriteNumber /&gt;, div) const input = queries.getByLabelText(div, &#x27;Favorite Number&#x27;) expect(input).toHaveAttribute(&#x27;type&#x27;,&#x27;number&#x27;) //Simplified because of the previous line //The next line is deleted because of duplication&#125;) queries.getByLabelText(div, &#39;Favorite Number&#39;) will cause the DOM testing library to search all children of this div for a label containing this text. At the same time, the previous div.querySelector(&#39;label&#39;) can also be deleted, because its content is already contained in queries.getByLabelText(div, &#39;Favorite Number&#39;). This method is case sensitive. But users of screen reader don’t care about case, so it should be written as: 123456test(&#x27;renders a number input with a label &quot;Favorite Number&quot;&#x27;, () =&gt; &#123; const div = document.createElement(&#x27;div&#x27;) ReactDOM.render(&lt;FavoriteNumber /&gt;, div) const input = queries.getByLabelText(div, /Favorite Number/i) expect(input).toHaveAttribute(&#x27;type&#x27;,&#x27;number&#x27;)&#125;) This regex ignores case. Use getQueriesForElement to simplify div fetching From getQueriesForElement , we can access many other queries from the DOM testing library to find elements in the render DOM. 123456789import &#123;queries, getQueriesForElement&#125; from &#x27;@testing-library/dom&#x27;test(&#x27;renders a number input with a label &quot;Favorite Number&quot;&#x27;, () =&gt; &#123; const div = document.createElement(&#x27;div&#x27;) ReactDOM.render(&lt;FavoriteNumber /&gt;, div) const &#123;getByLabelText&#125; = getQueriesForElement(div) const input = getByLabelText(/Favorite Number/i) expect(input).toHaveAttribute(&#x27;type&#x27;,&#x27;number&#x27;)&#125;) What’s done here is that the testing library&#x2F;DOM module is added, and we pull in getQueriesForElement. We get queries for div. Now, getByLabelText is pre-bound to that div, so we can take the text matching regex as a parameter and get the input. Then we can assert on that input that it has a numeric type.","categories":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/categories/Test/"},{"name":"React-testing-library","slug":"Test/React-testing-library","permalink":"https://redre4per.github.io/categories/Test/React-testing-library/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/tags/Test/"},{"name":"React-testing-library","slug":"React-testing-library","permalink":"https://redre4per.github.io/tags/React-testing-library/"}]},{"title":"Installation, config","slug":"Test/React-testing-library/01 Installation & config","date":"2022-10-15T14:47:09.000Z","updated":"2022-11-10T14:27:06.214Z","comments":true,"path":"2022/10/16/Test/React-testing-library/01 Installation & config/","link":"","permalink":"https://redre4per.github.io/2022/10/16/Test/React-testing-library/01%20Installation%20&%20config/","excerpt":"","text":"Install 1npm install --save-dev @testing-library/dom After installation, the setupTests.js file will be generated under src. ​ unit test file location The unit test file can be placed in the same folder as the text file, named text.test.js. In fact, as long as it is consistent with the text. In CourtCanva, the project is to keep all the test files together. This way is to create a __tests__ folder under src. Sometimes test files are written directly under src, but in most cases they are written in the __tests__ folder. ​ Check which query should be used for test For testing, just getbyRole(button, name: text in html). or data-testid&#x3D;{}. Everything that starts with data is useless to html, only for test. But the test can get the element with screen.getByTestId(“id”) . Or use the website to find test elements Testing Playground online , Testing Playground plugin to download the plugin. Websites are also available. Configuration test file The configuration of the test file is in jest.config.js in the root directory. Course can use the configuration package written by Kent C. Dodds to Simple configuration like 123456const config = require(&#x27;kcd-scripts/jest&#x27;)module.exports = &#123; ...config ConverageThreshold: &#123;&#125;,&#125; ​ Simple summary of the test Basic common verification writing Expect() Assertion Summary Expect() Assertion Summary 2","categories":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/categories/Test/"},{"name":"React-testing-library","slug":"Test/React-testing-library","permalink":"https://redre4per.github.io/categories/Test/React-testing-library/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/tags/Test/"},{"name":"React-testing-library","slug":"React-testing-library","permalink":"https://redre4per.github.io/tags/React-testing-library/"}]},{"title":"Stripe webhook","slug":"Others/Stripe/4 Stripe webhook","date":"2022-10-10T21:20:40.000Z","updated":"2022-11-10T09:34:45.359Z","comments":true,"path":"2022/10/11/Others/Stripe/4 Stripe webhook/","link":"","permalink":"https://redre4per.github.io/2022/10/11/Others/Stripe/4%20Stripe%20webhook/","excerpt":"","text":"Using webhooks First search for stripe cli, find the relevant version, download and unzip it. Select the x86_64 version. Enter cmd in the folder where the unzipped file is located, then enter stripe login to log in. After jumping to the stripe web page and logging in, go back to cmd and enter stripe listen --forward-to localhost:8000/v1/webhook . At this time, you can get the siging secret, which is valid for 90 days. E.g: 1whsec_9fd569e590734157a0d8xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Then fill this key into the .env of the backend. Update data via webhook First of all, the webhook collects data through events. The webhook will continuously monitor the interface. When the payment-related behavior occurs, such as ready to pay, paid, etc., the webhook will receive events. Because we currently only need to update the database after a payment occurs, we need to filter the events to only fire the callback function after the payment. The updated data comes from the webhook listener. But we still need the id of the database document to update the existing data. This id exists before the payment action, so it can be transmitted through the metadata field. When creating the Stripe session, we have passed the id to Stripe via metadata. So when updating the data, we can just take the data from metadata. metadata cannot store complex nested objects, so we only pass in the id, and other data can be stored in the database. webhook listening event Whenever an event such as payment intend, payment success, payment failure occurs, the webhook can listen to the event. Therefore, we need to filter the events, and then call the callback function after the event occurs to process the data in the next step. 1234567891011121314151617181920212223async function webhookHandler(req, res) &#123; const sig = req.headers[&quot;stripe-signature&quot;]; let event; try &#123; event = stripeAPI.webhooks.constructEvent(req.body, sig, endpointSecret); &#125; catch (err) &#123; console.log(&#x27;ERROR&#x27;, err.message); return res.status(400).send(`Webhook error: $&#123;err.message&#125;`); &#125; if (event.type === &#x27;checkout.session.completed&#x27;) &#123; const session = event.data.object; return fulfillOrder(session) .then(() =&gt; res.status(200)) .catch((err) =&gt; res.status(400).send(`Webhook Error: $&#123;err.message&#125;`)); &#125;&#125;const fulfillOrder = async (session) =&gt; &#123; const order = await Order.findById(session.metadata.orderId).exec(); ...&#125; Set routes in JSON raw format We cannot use webhooks without setting up routes in JSON raw format. For express.js: 1app.use(&#x27;/v1/webhook&#x27;, express.raw(&#123;type: &quot;*/*&quot;&#125;)) For nest.js: 12345678910111213141516171819//src/app.module.tsimport &#123; applyRawBodyOnlyTo, JsonBodyMiddleware, RawBodyMiddleware,&#125; from &quot;@golevelup/nestjs-webhooks&quot;;export class AppModule implements NestModule &#123; // Apply raw body parsing to the routes with path &quot;stripe/webhook&quot;, // and then to automatically apply JSON body parsing to all other routes // with the exclusion of the raw routes. configure(consumer: MiddlewareConsumer) &#123; applyRawBodyOnlyTo(consumer, &#123; method: RequestMethod.ALL, // path should be the same as webhookConfig controllerPrefix (settled in stripe module) path: &quot;stripe/webhook&quot;, &#125;); &#125;&#125; 12345678910import &#123; MongoExceptionFilter &#125; from &quot;./common/filters/mongoose-exception.filter&quot;;async function bootstrap() &#123; //bodyParser setting const app = await NestFactory.create&lt;NestExpressApplication&gt;(AppModule, &#123; bodyParser: false, &#125;); app.enableCors(); app.set(&quot;trust proxy&quot;, 1); app.useGlobalPipes() Flowchart","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Stripe payment","slug":"Others/Stripe-payment","permalink":"https://redre4per.github.io/categories/Others/Stripe-payment/"}],"tags":[{"name":"Stripe","slug":"Stripe","permalink":"https://redre4per.github.io/tags/Stripe/"},{"name":"Payment","slug":"Payment","permalink":"https://redre4per.github.io/tags/Payment/"}]},{"title":"Stripe hosted page front-end","slug":"Others/Stripe/3 Stripe hosted page front-end","date":"2022-10-07T10:49:02.000Z","updated":"2022-11-17T03:30:36.834Z","comments":true,"path":"2022/10/07/Others/Stripe/3 Stripe hosted page front-end/","link":"","permalink":"https://redre4per.github.io/2022/10/07/Others/Stripe/3%20Stripe%20hosted%20page%20front-end/","excerpt":"","text":"Stripe hosted checkout: Front-end The frontend receives the sessionID and uses this id to redirect the user to the stripe checkout page. The front-end needs to be packaged as follows: stripe package: npm i @stripe/stripe-js react stripe: npm i @stripe/react-stripe-js Then set the publish key as an environment variable and set REACT_APP_PUBLISHABLE_KEY in .env. Introduce package, configure Stripe In the front-end code, first introduce Elements &amp; loadStripe in the outermost root component src&#x2F;index.js, and then create stripePromise. After that, wrap &lt;Elements&gt; around the &lt;App/&gt; component and pass in the stripePromise parameter. This way we can use stripe objects in arbitrary components. 12345678910111213import &#123; Elements &#125; from &#x27;@stripe/react-stripe-js&#x27;;import &#123; loadStripe &#125; from &#x27;@stripe/stripe-js;&#x27;const stripePromise = loadStripe(process.env.REACT_APP_PUBLISHABLE_KEY)const root = ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;));root.render( &lt;React.StrictMode&gt; &lt;Elements stripe=&#123;stripePromise&#125;&gt; &lt;App /&gt; &lt;/Elements&gt; &lt;/React.StrictMode&gt;); After setting, you need to restart the project. Create checkout component We need to complete a checkout component to help users jump to the Stripe hosted checkout page. 12345678910111213const dataObj = &#123; line_items: line_items, customer_email: &quot;blhxp1@gmail.com&quot;, orderId: orderId &#125;; axios(&#123; method: &#x27;POST&#x27;, url: &#x27;/payment/create-checkout-session&#x27;, data: dataObj &#125;).then(response =&gt; &#123; const &#123; sessionId &#125; = response.data; stripe.redirectToCheckout(&#123; sessionId &#125;) &#125;).catch(err =&gt; &#123; console.log(err) &#125;); Create payment success and payment cancel pages We need to create payment success and payment cancel, which are used to help users jump back to our website after completing the payment. If we want to carry order information in these two pages, we need to put the data ID into the url from the Stripe backend: 12success_url: `$&#123;process.env.DOMAIN&#125;/payment?status=success&amp;orderId=$&#123;order_Id&#125;`,cancel_url: `$&#123;process.env.DOMAIN&#125;/payment?status=failure&amp;orderId=$&#123;order_Id&#125;`, How the front-end receives the id For React, the frontend can use useLocation() to receive the id. For Next.js, the front end can use the SSR method and pass in the context parameter to receive the id. 123export const getServerSideProps: GetServerSideProps = async (context) =&gt; &#123; const &#123; orderId, status &#125; = context.query;&#125;","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Stripe payment","slug":"Others/Stripe-payment","permalink":"https://redre4per.github.io/categories/Others/Stripe-payment/"}],"tags":[{"name":"Stripe","slug":"Stripe","permalink":"https://redre4per.github.io/tags/Stripe/"},{"name":"Payment","slug":"Payment","permalink":"https://redre4per.github.io/tags/Payment/"}]},{"title":"Stripe hosted page back-end","slug":"Others/Stripe/2 Stripe hosted page back-end","date":"2022-10-04T21:04:29.000Z","updated":"2022-11-10T09:30:15.119Z","comments":true,"path":"2022/10/05/Others/Stripe/2 Stripe hosted page back-end/","link":"","permalink":"https://redre4per.github.io/2022/10/05/Others/Stripe/2%20Stripe%20hosted%20page%20back-end/","excerpt":"","text":"Stripe hosted checkout: Back-end Provides a pre-build hosted payment page that can be used for a one-time payment or subscription. The advantage is that there is no need to create a custom integration, stripe already does all the UI. This is the easiest and fastest way. However, in this way, it cannot be customized and the ui cannot be changed. Process The customer selects the item they want to buy and clicks the checkout button; Initiate a request to the backend (including information about the item to be purchased) to create a checkout session; On the backend (for the item to be purchased), create a checkout session through the request Stripe Api; The Stripe API returns a session object; The session ID (a single property needed to complete the checkout) is sent to the front end. This session id value is used to redirect the user to the hosted stripe page to complete the checkout process. In this way, most of the important tasks are already done by Stripe. For our backend, we need to do a few things to set up the checkout session; for the frontend, we need to get a line items array list, which contains an array of objects, each element is an item the user wants to buy. Without these values, we cannot create a checkout session. We will also pre-populate an email address on stripe hosted checkout page. This means we also need the consumer’s mailbox. So, our request object needs at least line items. email If not passed in, customers need to enter their own email. Create Checkout session First install the backend stripe package: npm i stripe Created with the minimum required parameters. First we need to create a stripe api object on the backend in a separate stripe.js file. In the backend file, we instantiate a new stripe object and pass it a secret key. We can import this file later to use the stripe api to connect to the stripe service. 12const stripeAPI = require(&#x27;stripe&#x27;)(process.env.SECRET_KEY);module.exports = stripeAPI; Processing logic In another file, api&#x2F;checkout.js, contains the function to create the checkout session. Include the domain url in the function, because the user will be redirected to the stripe hosted page, and after the checkout is complete, the user will be redirected to your page. The parameters for stripeAPI are available in strip api documentation. The format of success_url, cancel_url is fixed. The res.json only needs to return the sessionID, because just the session id will redirect the user to the stripe hosted page. 1234567891011121314151617181920212223242526272829const stripeAPI = require(&#x27;./stripe&#x27;);async function createCheckoutSession(req, res)&#123; const domainUrl = process.env.WEB_APP_URL; //domain url, usually localhost3000 const &#123; line_items, customer_email &#125; = req.body; // session cannot be created without these two parameters if(!line_items || !customer_email)&#123; return res.status(400).json(&#123; error: &#x27;missing required session parameters&#x27;&#125;) &#125; let session; try &#123; //stripe api doc contains session = await stripeAPI.checkout.sessions.create(&#123; payment_method_types: [&#x27;card&#x27;], mode: &#x27;payment&#x27;, line_items, customer_email, success_url: `$&#123;domainUrl&#125;/success?session_id=&#123;CHECKOUT_SESSION_ID&#125;`, cancel_url: `$&#123;domainUrl&#125;/cancel`, shipping_address_collection: &#123; allowed_countries: [&#x27;GB&#x27;, &#x27;US&#x27;] &#125; &#125;); res.status(200).json(&#123; sessionId: session.id, &#125;) &#125; catch (error) &#123; console.log(error); res.status(400).json(&#123; error: &#x27;an error occurred, unable to create session&#x27;&#125;); &#125;&#125;module.exports = createCheckoutSession Postman connection test After writing the backend code, use postman to test to see if the session id can be generated. Refer to the official documentation for the format. 123456789101112131415161718&#123; &quot;line_items&quot;: [ &#123; &quot;quantity&quot;: 1, &quot;price_data&quot;: &#123; &quot;currency&quot;: &quot;aud&quot;, &quot;unit_amount&quot;: 100, &quot;product_data&quot;: &#123; &quot;name&quot;: &quot;canva test 1&quot;, &quot;description&quot;: &quot;court canva designed production, stripe demo&quot;, &quot;images&quot;: [&quot;https://jr-bookinglet-2.s3.ap-southeast-2.amazonaws.com/github/canva.jpg&quot;] &#125; &#125; &#125; ], &quot;customer_email&quot;: &quot;blhxp1@gmail.com&quot;&#125;","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Stripe payment","slug":"Others/Stripe-payment","permalink":"https://redre4per.github.io/categories/Others/Stripe-payment/"}],"tags":[{"name":"Stripe","slug":"Stripe","permalink":"https://redre4per.github.io/tags/Stripe/"},{"name":"Payment","slug":"Payment","permalink":"https://redre4per.github.io/tags/Payment/"}]},{"title":"Introduction to Stripe","slug":"Others/Stripe/1 Introduction","date":"2022-10-04T00:29:31.000Z","updated":"2022-11-10T11:55:40.346Z","comments":true,"path":"2022/10/04/Others/Stripe/1 Introduction/","link":"","permalink":"https://redre4per.github.io/2022/10/04/Others/Stripe/1%20Introduction/","excerpt":"","text":"Introduce Stripe code consists of two parts: front-end and back-end. The front end tokenizes customer information and uses stripe elements to collect sensitive information. General flow All payments need to go through the backend server. When the user is ready to pay, the backend server will send a request to set whether to create a session or a payment intend. The Stripe Api will respond with an object containing the session id or client secret. After that, they will be sent back to the front-end app, and they will be used to complete the payment. Whether it’s a one-time payment or a subscription, this is the process. The backend is the core and also connects to the stripe api. Payment gateway Handle payments at a global scale; PCI Compliance; Encrypt credit card data; Store credit card data securely; Method to realize Stripe hosted checkout Customized checkout Create stripe account Public key &amp; Secret key. In Dashboard, you can see that stripe has test mode and live mode. The secret key is used in the backend and should be placed in the .env file and cannot be exposed. Stripe dashboard Key points: View API keys: Public key and Secret key. View statistics of all payments, specific information for each payment. Check Stripe’s error message. View and deploy webhooks, locally&#x2F;online. View customer information. Set 3D secure (More - Radar - Fraud &amp; risk - Rules)","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Stripe payment","slug":"Others/Stripe-payment","permalink":"https://redre4per.github.io/categories/Others/Stripe-payment/"}],"tags":[{"name":"Stripe","slug":"Stripe","permalink":"https://redre4per.github.io/tags/Stripe/"},{"name":"Payment","slug":"Payment","permalink":"https://redre4per.github.io/tags/Payment/"}]},{"title":"Database migration","slug":"NestJS/13 Database migration","date":"2022-09-28T04:11:26.000Z","updated":"2022-11-12T00:02:21.309Z","comments":true,"path":"2022/09/28/NestJS/13 Database migration/","link":"","permalink":"https://redre4per.github.io/2022/09/28/NestJS/13%20Database%20migration/","excerpt":"","text":"Database Migration Database migrations provide a way to incrementally update the database schema and keep it in sync with the application data model, while preserving the existing data in our database. Build, run, and restore migrations. TypeORM provides us with a dedicated CLI that we can use. The migration classes are separate from the Nest application source code. This is because their lifecycle is maintained by the TypeORM CLI. Therefore, we cannot take advantage of dependency injection and other Nest specific features for database migrations. Migration Configuration Before creating a new migration, we need to create a new TypeORM configuration file and set up our database connection correctly. First create an ormconfig.js file in the root directory to configure all the ports, passwords, etc. we use from the Docker Compose file. There are some additional key values to let the TypeORM migration know where our entities and migration files will be. TypeORM migrations need to process compiled files, which Nest will output in the &#x2F;dist&#x2F;folder folder. 12345678910111213module.exports = &#123; type: &#x27;postgres&#x27;, host: &#x27;localhost&#x27;, port: 5432, username: &#x27;postgres&#x27;, password: &#x27;pass123&#x27;, database: &#x27;postgres&#x27;, entities: [&#x27;dist/**/*.entity.js&#x27;], migrations: [&#x27;dist/migrations/*.js&#x27;], cli: &#123; migrationsDir: &#x27;src/migrations&#x27;, &#125;,&#125; Create Migration File Command: npx typeorm migration:create -n filename. npx allows us to use executable packages without installation. This directive generates a new migration file in the &#x2F;src&#x2F;migrations directory. The up() is where we want to indicate what needs to be changed and how, and the down() method is where we want to undo or roll back any of those changes. Migration Instructions npm typeorm migration:run migration; npm typeorm migration:revert reverts. The commands in the courtCanva project are npm run migrate-up ; npm run migrate-down . Syntax When naming the file, use time + status + table name.js insertOne 12345module.exports = &#123; async up(db) &#123; await db.collection(&quot;documentName&quot;).insertOne(&#123;&#125;) &#125;&#125; insertMany 12345module.exports = &#123; async up(db) &#123; await db.collection(&quot;documentName&quot;).insertMany([]) &#125;&#125; updateOne 12345678910module.exports = &#123; async up(db) &#123; await db .collection(&quot;documentName&quot;) .updateOne(&#123; fieldName: &quot;value&quot; &#125;, &#123; $set: &#123; field1: &quot;value1&quot;, field2: &quot;value2&quot;,&#125;&#125;, &#123; $unset: [&quot;field3&quot;, &quot;field4&quot;] &#125;, ); &#125;,&#125;; Precautions The default value&#x2F;initial value of the schema in the database will not be generated when the database is migrated, such as isDeleted, updatedAt, etc., so you need to write it yourself. The creation time can be used with createdAt: new Date() .","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"}]},{"title":"Add index to Schema","slug":"NestJS/12 Add index to Schema","date":"2022-09-27T12:52:07.000Z","updated":"2022-11-10T03:47:28.365Z","comments":true,"path":"2022/09/27/NestJS/12 Add index to Schema/","link":"","permalink":"https://redre4per.github.io/2022/09/27/NestJS/12%20Add%20index%20to%20Schema/","excerpt":"","text":"index Indexes are special lookup tables that database search engines can use to speed up data retrieval. Without an index, Mongo must perform a collection scan, which means it must scan every document in the collection to select those that match the query. In Mongoose, indexes can be defined at the field level or at the schema level. Using a single index A common search request is to retrieve events by event name. In the schema file: 123456789101112131415import &#123; Schema &#125; from &#x27;@nestjs/mongoose&#x27;;@Schema()export class Event extends mongoose.Document &#123;@Props()type: string;@Props(&#123; index: true &#125;) //Add normal indexname: string;@Props(mongoose.SchemaTypes.Mixed)payload: Record&lt;string, any&gt;;&#125;export const EventSchema = SchemaFactory.createForClass(Event); Compound Index A single index references multiple properties. Multiple properties need to be added to EventSchema.index(&#123;&#125;). 12345678910111213141516import &#123; Schema &#125; from &#x27;@nestjs/mongoose&#x27;;@Schema()export class Event extends mongoose.Document &#123;@Props()type: string;@Props(&#123; index: true &#125;) //Add normal indexname: string;@Props(mongoose.SchemaTypes.Mixed)payload: Record&lt;string, any&gt;;&#125;export const EventSchema = SchemaFactory.createForClass(Event);EventSchema.index(&#123; name: 1, type: -1&#125;); Where 1 represents ascending order, -1 represents descending order, the same as sort() in mongoose.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"}]},{"title":"Transactions","slug":"NestJS/11 Transactions","date":"2022-09-25T03:07:52.000Z","updated":"2022-11-10T14:04:07.753Z","comments":true,"path":"2022/09/25/NestJS/11 Transactions/","link":"","permalink":"https://redre4per.github.io/2022/09/25/NestJS/11%20Transactions/","excerpt":"","text":"Transaction We perform multiple operations on the database, making sure they only happen if everything is successful. A database transaction represents a unit of work performed in a database management system, and a transaction is a reliable way to accomplish multiple tasks independently of other transactions. Note that there are other advanced techniques that leverage Nest scope providers and interceptors to automatically wrap every “write” query in a transaction. Necessity of transactions: For example, there are two tables: account table and information table, and there is a relationship between these two tables. Therefore, when we add data in one table, we have to add data to another table at the same time. However, this is a two-step operation (that is, in the first step, I need to add data in the account table, and in the second step, I need to add data in the information table). What if one of the operations fails? If the account is added successfully, but the information fails. If it is not handled, it will result in that the account has no information. So the transaction comes into play. In a transaction, all of them must be successful to be considered as a new success. Otherwise it is a failure. Add new CLI entity nest g class events/entities/event.entity --no-spec . This file is in the root directory. After creation, in the event.entity.ts file, change the class name EventEntity to Event, otherwise Entity will enter the database collection name. 123456789101112131415import &#123; Schema &#125; from &#x27;@nestjs/mongoose&#x27;;@Schema()export class Event extends mongoose.Document &#123; //Inheritance@Props()type: string;@Props()name: string;@Props(mongoose.SchemaTypes.Mixed) // means &quot;anything can happen&quot;.payload: Record&lt;string, any&gt;;&#125;export const EventSchema = SchemaFactory.createForClass(Event); payload is a generic property where we will store the event payload. These payloads are essentially a dictionary filled with values of type any . Then also add the Event to the MongooseModule.forFeature([ ]) array in coffees.module.ts : 1234567891011121314151617@Module(&#123; imports: [ MongooseModule.forFeature([ &#123; name: Coffee.name, schema: CoffeeSchema, &#125;, &#123; // add here name: Event.name, schema: EventSchema, &#125;, ]), ], controllers: [CoffeesController], providers: [CoffeesService],&#125;)export class CoffeesModule &#123;&#125; Also add the Event to the coffee schema file coffee.entity.ts: 123456789101112131415161718import &#123; Schema &#125; from &#x27;@nestjs/mongoose&#x27;;@Schema()export class Coffee extends Document &#123; //To inherit Document. @Prop() name: string; @Prop() brand: string; @Prop(&#123; default:0 &#125;) //Add here recommendations: number; @Prop([String]) flavors: string[];&#125;export const CoffeeSchema = SchemaFactory.createForClass(Coffee); //output Create transaction To create a transaction, use the Connection object from mongoose in coffees.service.ts. 12345678910111213141516171819202122232425262728293031323334353637383940import &#123; Injectable, NotFoundException &#125; from &#x27;@nestjs/common&#x27;;import &#123; InjectModel &#125; from &#x27;@nestjs/mongoose&#x27;;import &#123; Connection, Model &#125; from &#x27;mongoose&#x27;;import &#123; Coffee &#125; from &#x27;./entities/coffee.entity&#x27;;@Injectable()export class CoffeesService &#123; constructor( @InjectModel(Coffee.name) private readonly coffeeModel: Model&lt;Coffee&gt;, @InjectConnection() private readonly connection: Connection, //connection @InjectModel(Event.name) private readonly eventModel: Model&lt;Event&gt;, //Event )&#123;&#125;async findAll(paginationQuery: PaginationDto)&#123; const &#123;limit, offset&#125; = paginationQuery; return this.coffeeModel.find().skip(offset).limit(limit)exec(); &#125;; async recommendCoffee(coffee: Coffee)&#123; const session = await this.connection.startSession(); //Create a new mongo session session.startTransaction(); try &#123; //The whole session should be wrapped in try catch coffee.recommendations++; const recommendEvent = new this.eventModel(&#123; name: &#x27;recommend_coffee&#x27;, type: &#x27;coffee&#x27;, payload: &#123; coffeeId: coffee.id &#125;, &#125;); await recommondEvent.save(&#123; session &#125;); await coffee.save(&#123; session &#125;); await session.commitTransaction(); &#125; catch (err) &#123; await session.abortTransaction(); &#125; finally &#123; session.endSession(); &#125; &#125;&#125;","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"}]},{"title":"Interact with MongoDB, pagination","slug":"NestJS/10 Interact with mongoDB","date":"2022-09-24T09:47:37.000Z","updated":"2022-11-12T00:02:15.134Z","comments":true,"path":"2022/09/24/NestJS/10 Interact with mongoDB/","link":"","permalink":"https://redre4per.github.io/2022/09/24/NestJS/10%20Interact%20with%20mongoDB/","excerpt":"","text":"Inject model into service Use the @injectModel() decorator and pass in the schema name. Model&lt;schema class name&gt; is a fixed notation. Same here as express, but also write async&#x2F;await to make Promises easier to manage and more readable. Enter this.coffeeModel. here to see all available methods. Compared to mongoose in express, this.coffeeModel here is equivalent to the original Schema name (capitalized), such as Store, Category, User, etc. In the service file: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import &#123; Injectable, NotFoundException &#125; from &#x27;@nestjs/common&#x27;;import &#123; InjectModel &#125; from &#x27;@nestjs/mongoose&#x27;;import &#123; Model &#125; from &#x27;mongoose&#x27;;import &#123; Coffee &#125; from &#x27;./entities/coffee.entity&#x27;;@Injectable()export class CoffeesService &#123; constructor( @injectModel(Coffee.name) private readonly coffeeModel: Model&lt;Coffee&gt;, )&#123;&#125;async findAll()&#123; return this.coffeeModel.find().exec(); &#125;; async findOne(id: string)&#123; const coffee = await this.coffeeModel.findOne(&#123; _id: id&#125;).exec(); if(!coffee) &#123; throw new NotFoundException(`Coffee #$&#123;id&#125; not found`); &#125; return coffee; &#125;; async create(createCoffeeDto: CreateCoffeeDto)&#123; //Type verification const coffee = new this.coffeeModel( createCoffeeDto ); return coffee.save(); &#125;; async create(createCoffeeDto: CreateCoffeeDto)&#123; //Another way of writing const coffee = await this.coffeeModel.create( createCoffeeDto ); return coffee; &#125;; async update(id: string, updateCoffeeDto: UpdateCoffeeDto)&#123; const existingCoffee = await this.coffeeModel.findByIdAndUpdate(&#123; _id: id &#125;, &#123; $set: updateCoffeeDto &#125;, &#123; new: true &#125;).exec(); if(!exsitingCoffee)&#123; throw new NotFoundException(`Coffee #$&#123;id&#125; not found`); &#125;return coffee; &#125; async remove(id: string)&#123; const coffee = await this.findOne(id); return coffee.remove(); &#125;&#125; $set: Update a field in the document instead of replacing it all. In remove , there is no need to remove the manual validation (!coffee) , as findOne will automatically return an error when it cannot find the target. ​ Changes in Controller file First id should be changed from number to string. This is because in mongoDB _id is a string and not a number. If this is not changed, the ValidationPipe will try to automatically convert the “id” of any incoming object to a number, resulting in a lot of random errors. Pagination First create pagination: nest g class common/dto/pagination-query.dto --no-spec . The pagination is created with a new class name in order to hold things that are not tied to any specific field and can be reused by multiple controllers. In the pagination-query.dto file: 12345678910111213import &#123; Type &#125; from &#x27;class-transformer&#x27;;export class PaginationQueryDto &#123; @IsOptional() @IsPositive() @Type(() =&gt; Number) //This can be removed by global setting implicit conversion limit: number; @IsOptional() @IsPositive() @Type(() =&gt; Number) //This can be removed by global setting implicit conversion offset: number;&#125; In main.ts file: 12345678910111213async function bootstrap() &#123; const app = await NestFactory.create(AppModule); app.useGlobalPipes( new ValidationPipe(&#123; whitelist: true, transform: true, forbidNonwhitelisted: true, transformOptions: &#123; enableImplicitConversion: true, //Set this item &#125; &#125;) )&#125; In the controller file: 123456789@Injectable()export class CoffeesService &#123; constructor( @injectModel(Coffee.name) private readonly coffeeModel: Model&lt;Coffee&gt;, )&#123;&#125;async findAll(@Query() paginationQuery: PaginationQueryDto)&#123; return this.coffeeModel.findAll(paginationQuery).exec(); &#125;; In the service file: 12345678910111213141516import &#123; Injectable, NotFoundException &#125; from &#x27;@nestjs/common&#x27;;import &#123; InjectModel &#125; from &#x27;@nestjs/mongoose&#x27;;import &#123; Model &#125; from &#x27;mongoose&#x27;;import &#123; Coffee &#125; from &#x27;./entities/coffee.entity&#x27;;@Injectable()export class CoffeesService &#123; constructor( @injectModel(Coffee.name) private readonly coffeeModel: Model&lt;Coffee&gt;, )&#123;&#125;async findAll(paginationQuery: PaginationDto)&#123; const &#123;limit, offset&#125; = paginationQuery; return this.coffeeModel.find().skip(offset).limit(limit)exec(); &#125;;&#125; ​ Sort syntax 1234Post.find(&#123;&#125;).sort(&#x27;test&#x27;).exec(function(err, docs) &#123; ... &#125;);Post.find(&#123;&#125;).sort([[&#x27;date&#x27;, -1]]).exec(function(err, docs) &#123; ... &#125;);Post.find(&#123;&#125;).sort(&#123;test: 1&#125;).exec(function(err, docs) &#123; ... &#125;);Post.find(&#123;&#125;, null, &#123;sort: &#123;date: 1&#125;&#125;, function(err, docs) &#123; ... &#125;);","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"},{"name":"Mongoose","slug":"Mongoose","permalink":"https://redre4per.github.io/tags/Mongoose/"}]},{"title":"Mongoose model","slug":"NestJS/09 Mongoose model","date":"2022-09-23T02:07:48.000Z","updated":"2022-11-10T02:56:40.221Z","comments":true,"path":"2022/09/23/NestJS/09 Mongoose model/","link":"","permalink":"https://redre4per.github.io/2022/09/23/NestJS/09%20Mongoose%20model/","excerpt":"","text":"Data model schema These models are responsible for creating, reading and deleting documents from the Mongo database. We need to create a schema first. The schema can be created manually using NestJS decorator or mongoose. Create schema with NestJS decorator Create the schema in coffee.entity.ts in the entities folder. The file structure is: 12345678|-- src |-- coffees |-- coffees.module.ts |-- coffees.controller.ts |-- coffees.service.ts |-- dto |-- entities |-- coffee.entity.ts 12345678import &#123; Schema &#125; from &#x27;@nestjs/mongoose&#x27;;@Schema()export class Coffee extends Document&#123; //To inherit Document. name: string; brand: string; flavors: string[];&#125; //This is incomplete, see next code block The @Schema() decorator maps our Coffee class to the MongoDB collection of the same name, but with an extra ‘s’ at the end. Mongo automatically makes all collections plural and lowercase by default. The id is not needed here because mongoose adds the _id attribute by default. Define properties: @Prop() Add the @Prop() decorator to all our properties. 123456789101112131415import &#123; Schema &#125; from &#x27;@nestjs/mongoose&#x27;;@Schema()export class Coffee extends Document &#123; //To inherit Document. @Prop() name: string; @Prop() brand: string; @Prop([String]) //Because flavors is an array of strings, [String] should be passed in @Prop(). flavors: string[];&#125;export const CoffeeSchema = SchemaFactory.createForClass(Coffee); //output Introduce the mongoose model into the module file Add MongooseModule.forFeature() to the module file, passing in an Array of objects. We use forFeature() to register Mongoose in our submodule. 12345678import &#123; MongooseModule &#125; from &#x27;@nestjs/mongoose&#x27;;@Module(&#123; imports: [MongooseModule.forFeature([ //Note [], the element is an object. &#123; name: Coffee.name, //Coffee.name is obtained from coffee.entity.ts schema: CoffeeSchema, // Also obtained from coffee.entity.ts, but the final output. &#125;])], controllers: [CoffeesController], providers: [CoffeesService] &#125;) coffee.name is just a way to get the function name from a JavaScript class, which in this case gives us a string. Common spelling Ref 12@Prop(&#123; type: MongooseSchema.Types.ObjectId, ref: &quot;Price&quot; &#125;)price: Price; Do not repeat spelling 12@Prop(&#123; unique: true &#125;)email: string; default value 12345@Prop(&#123; default: false &#125;)isDeleted: boolean;@Prop(&#123; type: Date, default: new Date() &#125;) //The default is the current timecreatedAt: Date; Object notation 123456@Prop(&#123; type: Object, required: true &#125;) courtSize: &#123; name: string; length: number; width: number; &#125; Maximum and minimum writing 12@Prop(&#123; required: true, minLength: 5, maxLength: 50 &#125;)name: string; Object array writing 12@Prop(&#123; type: Array, required: true &#125;)colors: [&#123; name: string; value: string &#125;];","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"},{"name":"Mongoose","slug":"Mongoose","permalink":"https://redre4per.github.io/tags/Mongoose/"}]},{"title":"Docker Mongoose","slug":"NestJS/08 Docker Mongoose","date":"2022-09-21T10:54:02.000Z","updated":"2022-11-12T00:02:10.797Z","comments":true,"path":"2022/09/21/NestJS/08 Docker Mongoose/","link":"","permalink":"https://redre4per.github.io/2022/09/21/NestJS/08%20Docker%20Mongoose/","excerpt":"","text":"Docker containerization The benefits of using Docker: flexible, lightweight, portable, loosely coupled. They can be built locally to the cloud and run anywhere, and finally containers are loosely coupled, which means containers are highly self-sufficient and encapsulated. This allows us to replace or upgrade containers without disrupting any other containers. Essentially, a container is just a running process with some additional encapsulation features applied. This helps keep containers isolated from the host and other containers. Docker compose: is a tool for defining and running multiple container docker applications, through docker compose we can use yaml files to configure our application services. Configure MongoDB Use the Docker Compose tool and its YAML configuration to set up everything you need. Create a docker-compose.yml file in the root directory. Spacing&#x2F;indentation&#x2F;dashes in YAML all matter. The most important thing in the file is the db service, the Docker image using ‘Mongo’. A Docker image is a multi-layered file that will execute code in our docker container. In this case, it will create a Mongo database. 12345678910version: &quot;3&quot;services: db: image: mongo restart: always environment: - MONGODB_DATABASE=nest-course //database name ports: - 27017:27017 //Default port. Docker sets up the database on port 27017 and we can also access it outside of docker. Use the docker compose CLI to run the db service: docker-compose up -d . The d flag means we want to run the containers in detached mode, meaning they run in the background. If there are other services here and you want to run a specific service, you can do so by entering its name. When nothing is passed in, docker compose will generate all defined services. Use mongoose in nest Install: npm i mongoose @nestjs/mongoose. @nestjs&#x2F;mongoose is for integrating nest with mongoose. Type safety: npm i -D @type/mongoose . Install the mongoose typescript definition as a ‘dev’ dependency. @nestjs&#x2F;mongoose comes with a set of useful decorators and MongooseModule. set mongoose In app.module.ts in the root directory, add MongooseModule.forRoot(&#39;mongodb://localhost:27017/nest-course&#39;) in imports: [ ] . The second parameter is not present here, it is a configuration option. nest-course is the database name. At this point, use npm run start:dev to start the application, and mongodb can connect.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"},{"name":"Mongoose","slug":"Mongoose","permalink":"https://redre4per.github.io/tags/Mongoose/"}]},{"title":"DTO data verification","slug":"NestJS/07 DTO","date":"2022-09-20T13:04:18.000Z","updated":"2022-11-09T07:16:37.427Z","comments":true,"path":"2022/09/20/NestJS/07 DTO/","link":"","permalink":"https://redre4per.github.io/2022/09/20/NestJS/07%20DTO/","excerpt":"","text":"DTO DTO is short for data transfer object. A DTO is an object that encapsulates data and sends it from one application to another. DTOs help us define interfaces or inputs and outputs within the system. That is, the DTO defines the format of the data to be received. Similar to schema (but only validates the incoming data part). The objectId is automatically generated by the database and does not need to be verified. DTOs are just simple objects, they don’t contain any business logic, methods, or anything that needs to be tested. Generate DTO file Generated location: under the dto folder of the same level as coffees.controller.ts. 12345678|-- src |-- coffees module folder |-- coffees.module.ts //helps us keep our code organized and establish clear boundaries for the application and its functionality. |-- coffees.controller.ts |-- coffees.service.ts |-- dto |-- create-coffee.dto |-- update-coffee.dto //Different DTOs should be placed in separate files How to generate: Use nest cli: nest generate class path and name.dto --no-spec , abbreviated as nest g class path and name.dto --no-spec . For example, nest g class coffees/dto/create-coffee.dto --no-spec . --no-spec was added to avoid generating test files. DTO document In &#x2F;dto&#x2F;create-coffee.dto： 12345export class CreateCoffeeDto &#123; name: string; brand: string; flavors: string[];&#125; Use in controller DTO In coffees.controller.ts： 1234@Post()create(@Body() createCoffeeDto: CreateCoffeeDto) &#123; return this.coffeesService.create(createCoffeeDto); //Note that a DTO instance is used when creating here&#125; DTO Tag Properties readonly guarantees that the property is not modified 12345export class CreateCoffeeDto &#123; readonly name: string; readonly brand: string; readonly flavors: string[];&#125; ? guarantees that the attribute is optional. This guarantees that @Patch can update any tiny part. 12345export class UpdateCoffeeDto &#123; name?: string; //Note? Location brand?: string; //Attention? Location flavors?: string[]; //Note? Location&#125; Data validation: ValidationPipe The downside of DTOs is that we don’t know who or what is calling these requests, how to make sure the incoming data has the correct shape, or if the data is missing necessary fields. NestJS provides ValidationPipe to solve this exact problem. ValidationPipe provides a convenient way to enforce validation rules on incoming client payloads (data). Programmers can specify these rules by using simple comments in the DTO. Application is set to use ValidationPipe In src&#x2F;main.ts, add app.useGlobalPipes(new ValidationPipe()) . Also install two packages: npm i class-validator class-transformer. 1234567import &#123; ValidationPipe &#125; from &#x27;@nestjs/common&#x27;;async function bootstrap()&#123; const app = await NestFactory.create(AppModule); app.useGlobalPipes(new ValidationPipe()) await app.listen(3000);&#125; It can then be modified in the DTO file. See the class-validator documentation to see all decorators. 1234567891011import &#123; IsString &#125; from &#x27;class-validator&#x27;;export class CreateCoffeeDto &#123; @IsString() readonly name: string; @IsString() readonly brand: string; @IsString(&#123; each: true &#125;) //Indicates that each item in the array is expected to be a string. readonly flavors: string[];&#125; If the input data does not conform to the rules, it will automatically respond with a 400 BadRequest code and indicate the reason in the message. Create’s validation is reused for Update The writing in “Error” section is cumbersome and can be simplified. nestjs provides several utility functions as part of the package @nestjs&#x2F;mapped-types. These functions help us quickly perform common conversions of these types. First install the package: npm i @nestjs/mapped-types. Then change the update-coffee.dto.ts file to: 123456import &#123;PartialType&#125; from &#x27;@nestjs/mapped-types&#x27;;import &#123;CreateCoffeeDto&#125; from &#x27;./create-coffee.dto&#x27;;export class UpdateCoffeeDto extends PartialType(CreateCoffeeDto)&#123; &#125; The PartialType function is very useful because what it does for us is return the type of the class we pass to it, with all properties set to optional. And it also inherits all validation rules applied through the decorator. It also dynamically adds a single additional validation rule to each field @IsOptional() . Some properties we hope cannot be updated, such as user_id. In this case the @Exclude() decorator can be used to prevent property updates. ValidationPipe whitelist Whitelisting is used to filter out properties that should not be received by method handlers. By whitelisting acceptable properties, any properties not included in the whitelist are automatically stripped from the resulting object. Whitelisting is used by entering some options into the ValidationPipe. In main.ts: 123456async function bootstrap()&#123; const app = await NestFactory.create(AppModule); app.useGloblePipes(new ValidatePipe(&#123; whitelist: true, //add whitelist &#125;)&#125; The whitelist also has an option to stop processing requests and throw an error if there are any non-whitelisted attributes: 1234567async function bootstrap()&#123; const app = await NestFactory.create(AppModule); app.useGloblePipes(new ValidatePipe(&#123; whitelist: true, forbidNonWhitelisted: true, // throws an error when there is a non-whitelisted attribute &#125;)&#125; Guaranteed that the shape of the payload (the incoming object, i.e. the payload) is as expected As in @Post(), createCoffeeDto is not an instance of CreateCoffeeDto. This means that the payload is the shape of CreateCoffeeDto, but not an instance. ValidationPipe can help us convert this object to what we expect. Enable globally: 12345678async function bootstrap()&#123; const app = await NestFactory.create(AppModule); app.useGloblePipes(new ValidatePipe(&#123; whitelist: true, transform: true, // set here forbidNonWhitelisted: true, &#125;)&#125; This transform can also perform primitive type conversions for things like boolean and number. By default, the parameters in path and query are of type string. When adding transform: true, if we change the string in findOne(@Param(&#39;id&#39;) id: string)&#123;&#125; to a number, it will cause problems because coffeesService.findOne() expects a string as a parameter (custom in nestJS.4). Because at this time id has been changed to number type. This feature has a very slight performance impact. Automatic conversion type 1@Type(() =&gt; Number) //If the string type is passed, no error will be reported, and it will be automatically converted to the number type Validation of nested objects 12345@IsObject()@IsNotEmpty()@ValidateNested(&#123; each: true &#125;) //Must have this@Type(() =&gt; Design)readonly design: Design;","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"}]},{"title":"Modularization","slug":"NestJS/06 Modularization","date":"2022-09-17T02:41:17.000Z","updated":"2022-11-09T07:00:14.063Z","comments":true,"path":"2022/09/17/NestJS/06 Modularization/","link":"","permalink":"https://redre4per.github.io/2022/09/17/NestJS/06%20Modularization/","excerpt":"","text":"Reasonable nest architecture, create modules A well-structured architecture should employ multiple modules, each encapsulating a set of closely related functions. The function should contain controller, service, etc. Also, test files and test data files are placed here. Create module directive: nest g module module_name. This will create the module and automatically import the module file into the parent module. The structure is: 12345|--src |-- coffees module folder |-- coffees.module.ts //helps us keep our code organized and establish clear boundaries for the application and its functionality. |-- coffees.controller.ts |-- coffees.service.ts @Module decorator In the coffees.module.ts file, the decorator before the CoffeesModule class is @Module(&#123;&#125;) . It provides data to support application structure. The module decorator requires a single object whose properties describe the module and all contexts. The attributes of the @Module decorator have four kinds of content: controllers: API root, we want this module to be instantiated. exports: List the providers in the current module, which should be available everywhere. This module will be imported. imports: Allows us to list other modules of this module. providers: an array. Lists services that need to be instantiated by the nest injector. Any provider here will only be available in this module unless it is added to the exports array. Incorporate the file into the module file Included in the file as attributes of the @Module decorator: [array]. 1234import &#123;Module&#125; from &#x27;@nestjs/common&#x27;; @Module(&#123;controllers: [CoffeesController], providers: [CoffeesService]&#125;)export class CoffeesModule&#123;&#125;","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"}]},{"title":"Errors","slug":"NestJS/05 Errors","date":"2022-09-15T08:05:27.000Z","updated":"2022-11-09T06:51:32.486Z","comments":true,"path":"2022/09/15/NestJS/05 Errors/","link":"","permalink":"https://redre4per.github.io/2022/09/15/NestJS/05%20Errors/","excerpt":"","text":"Wrong choice in Nest Throwing an exception Use library-specific response objects Create interceptors and use exception filters Additionally, nest has helper methods for all common error responses, including helper classes. Throw an exception In the service file: 1234567findOne(id: string)&#123; const coffee = this.coffees.find(item =&gt; item.id === +id); if(!coffee)&#123; throw new HttpException(`Coffee #$&#123;id&#125; not found`, HttpStatus.NOT_FOUND); &#125; return coffee;&#125; ​ Help class Including NotFoundException, InternalServiceErrorException, BadRequestException, etc. 1234567findOne(id: string)&#123; const coffee = this.coffees.find(item =&gt; item.id === +id); if(!coffee)&#123; throw new NotFoundException(`Coffee #$&#123;id&#125; not found`); //Replace here, but return the same &#125; return coffee;&#125; ​ Nest’s built-in exception layer automatically catches exceptions Similar to express-error to automatically process packages. ​","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"}]},{"title":"Service","slug":"NestJS/04 Service","date":"2022-09-14T06:15:07.000Z","updated":"2022-11-09T06:40:10.479Z","comments":true,"path":"2022/09/14/NestJS/04 Service/","link":"","permalink":"https://redre4per.github.io/2022/09/14/NestJS/04%20Service/","excerpt":"","text":"Create service When creating a service, first enter nest generate service, abbreviated nest g s. Enter the name after that. service is used to process logic and can be reused after being extracted. In nest, each service is a provider. Provider The main idea of Provider is that it can inject dependencies. This means that various relationships can be created between objects, and the logic to wire object instances together can all be handled by the Nest runtime system, rather than trying to create and manage this type of dependency injection yourself. Provider in nest is a class with a decorator named @Injectable(). Provider dependency If we want to inject the provider, we can simply use the constructor. In the Contoller file, write constructor()&#123;&#125; in the Controller class. 123456789101112import &#123; CoffeesService &#125; from &#x27;./coffees.service&#x27;;@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; constructor(private readonly coffeesService: CoffeesService)&#123;&#125; @Post() @HttpCode(HttpStatus.GONE) //Decorator position, return 410GONE. create(@Body(&#x27;name&#x27;) body)&#123; return body; &#125;&#125; private: TypeScript usage that allows us to declare and initialize CoffeesService members at once in the same place. And it’s only accessible within the class itself, hence private. readonly: Ensures that the referenced service is not modified and content is only accessed from it. coffeesService : Named parameter. : CoffeesService: In typeScript, use types to manage dependencies. nest will resolve CoffeesService by creating an instance of CoffeesService and returning it to our CoffeesController , or returning an existing instance if there is one. This dependency is resolved and passed to the controller constructor, or assigned to the property specified here. Service，CRUD In service document： 12345678910111213141516171819202122232425import &#123; Coffee &#125; from &#x27;./entities/coffee.entity&#x27;; //coffee class@Injectable()export class CoffeesService &#123; private coffees: Coffee[] = [ //Create an array, using multiple instances. &#123; id: 1, name: &#x27;Shipwreck Roast&#x27;, brand: &#x27;Buddy Brew&#x27;, flavors: [&#x27;chocolate&#x27;, &#x27;vanilla&#x27;] &#125; ]; findAll()&#123;return this.coffees&#125;; findOne(id: string)&#123;item =&gt; item.id === +id&#125;; create(createCoffeeDto: any)&#123;this.coffees.push(createCoffeeDto)&#125;; update(id: string, updateCoffeeDto: any)&#123; const existingCoffee = this.findOne(id); if(exsitingCoffee)&#123;&#125; &#125; remove(id: string)&#123; const coffeeIndex = this.coffees.findIndex(item =&gt; item.id === +id); if(coffeeIndex &gt;= 0)&#123; this.coffees.splice(coffeeIndex, 1) &#125;; &#125;&#125; Use dependencies in controller In the controller file: 123456789101112131415161718192021222324252627282930@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; constructor(private readonly coffeesService: CoffeesService)&#123;&#125; @Get() findAll(@Query() paginationQuery)&#123; //const &#123;limit, offset&#125; = paginationQuery; return this.coffeesService.findAll(); &#125; @Get(&#x27;:id&#x27;) findOne(@Param(&#x27;id&#x27;) id:string)&#123; return this.coffeesService.findOne(id); &#125; @Post() create(@Body() body)&#123; return this.coffeesService.create(body); &#125; @Patch(&#x27;:id&#x27;) update(@Param(&#x27;id&#x27;) id: string, @Body() body)&#123; return this.coffeesService.update(id, body); &#125; @Delete(&#x27;:id&#x27;) remove(@Param(&#x27;id&#x27;) id: string)&#123; return this.coffeesService.remove(id); &#125;&#125;","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"}]},{"title":"Pagination @Put(), @Delete()","slug":"NestJS/03 Put, Delete, Pagination","date":"2022-09-14T02:19:51.000Z","updated":"2022-11-12T00:01:53.362Z","comments":true,"path":"2022/09/14/NestJS/03 Put, Delete, Pagination/","link":"","permalink":"https://redre4per.github.io/2022/09/14/NestJS/03%20Put,%20Delete,%20Pagination/","excerpt":"","text":"Status code problem Nest will give a default status code of 200 when the request is successful. But we can also customize the status code and return. Nest does not need to memorize all status codes, you can use @HttpCode(HttpStatus. Prompt) to select the prompt status, which will automatically return the corresponding status code. 12345678910import &#123; Controller, Get, Param, Post, Body &#125; from &#x27;@nestjs/common&#x27;;@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; @Post() @HttpCode(HttpStatus.GONE) //Decorator position, return 410GONE. create(@Body(&#x27;name&#x27;) body)&#123; return body; &#125;&#125; @HttpCode(HttpStatus.hint) is placed before the callback function, which means that the result returned by the callback function after it must be the only definite status. @Res() native express response processing method The @Res() decorator can be used in endpoint method parameters, allowing us to use native express response handling methods. 1234567@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; @Get() findAll(@Res() response)&#123; response.status(200)send(&#x27;This action returns all coffees&#x27;); &#125;&#125; This approach is flexible and provides header manipulation, library specific functionality, etc., but should be used with care. It has the disadvantage of losing compatibility with Nest features that rely on Nest’s standard response handling, such as interceptors and the @HttpCode() decorator. It also makes the code harder to test and has to mock the response object. Put and Patch Put replaces the entire resource, so we need to include the entire object in the request payload. Patch is different in that it only modifies part of the resource. We could even just update a single property of the resource if we wanted to. The corresponding methods for Put and Patch are update . 1234567@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; @Patch(&#x27;:id&#x27;) update(@Param(&#x27;id&#x27;) id: string, @Body() body)&#123; //Pay attention to the spelling return `This action updates #$&#123;id&#125; coffee`; &#125;&#125; Pay attention to the spelling here. When using Params, Query or req.body parameters, you must first declare the corresponding @ decorator. In addition, if it is all res.body, it should be written as @Body() body , () cannot be lost. Delete The corresponding method of Delete is remove() . 1234567@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; @Delete(&#x27;:id&#x27;) remove(@Param(&#x27;id&#x27;) id: string)&#123; //remove, note that id is also passed in return `This action removes #$&#123;id&#125; coffee`; &#125;&#125; ​ Pagination We want to use path parameters: identify a specific resource, and when using query parameters: filter or sort that resource. The @Query decorator in Nest is used to get all or a specific part of query parameters. 12345678@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; @Get() findAll(@Query() paginationQuery)&#123; const &#123; limit, offset&#125; = paginationQuery; return `This action returns all coffees. Limit: $&#123;limit&#125;, offset: $&#123;offset&#125;`; &#125;&#125;","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"}]},{"title":"Controller, @Get(), @Post()","slug":"NestJS/02 Controller, Get, Post","date":"2022-09-13T13:11:29.000Z","updated":"2022-11-09T06:16:13.281Z","comments":true,"path":"2022/09/13/NestJS/02 Controller, Get, Post/","link":"","permalink":"https://redre4per.github.io/2022/09/13/NestJS/02%20Controller,%20Get,%20Post/","excerpt":"","text":"Generate a controller by running the Nest CLI Command: nest generate controller, which can be abbreviated as nest g co. Then enter the name of the controller. (If you don’t want to generate test files, you should type nest g co --no-spec ) After running, nest will help us create a folder containing controller and spec files. At this time, the app.module.ts file will automatically introduce this controller to the controllers array. If you want to create a controller in a subfolder of src, the command can be rewritten as nest generate controller modules/abc. If you want to see the simulated output, you can use nest generate controller modules/abc --dry-run. He doesn’t actually create the file. URL access and controller matching mechanism Nest uses @Controller(&#39;route&#39;) to match controller and url. 12@Controller(&#x27;coffees&#x27;) //It can be accessed when accessing http://localhost:3000/coffees with GET.export class CoffeesController &#123;&#125; When controller is empty, it will return 404 and error message. Also note that methods like Controller and Get&#x2F;Post are imported from @nestjs&#x2F;common. Build http handler, Get First introduce Methods such as Get from @nestjs&#x2F;common. The corresponding methods for Get are findAll() and findOne. 123456789import &#123; Controller, Get &#125; from &#x27;@nestjs/common&#x27;;@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; @Get() findAll()&#123; return &#x27;This action returns all coffees&#x27;; &#125;&#125; Nested Paths In a class decorated with @Controller(&#39;primary path&#39;), secondary paths can be nested. 1234567@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; @Get(&#x27;flavors&#x27;) //Put the secondary route here. findAll()&#123; return &#x27;This action returns all coffees&#x27;; &#125;&#125; At this time, visit localhost:3000&#x2F;coffees&#x2F;flavors to access the content. Use routing parameters (dynamic path) You can use route parameters by writing (&#39;:id&#39;) in the decorator, and import Param from @nestjs&#x2F;common. The @Param() decorator allows us to take all incoming request parameters and use them in the body of the method. When nothing is passed inside the @Param() decorator, it receives all request parameters, let’s access params.id from the object. 123456789import &#123; Controller, Get, Param &#125; from &#x27;@nestjs/common&#x27;;@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; @Get(&#x27;:id&#x27;) //Put the secondary route here. findOne(@Param() params)&#123; return `This action returns #$&#123;params.id&#125; coffees`; &#125;&#125; When the @Param() decorator passes in a parameter, first declare the parameter type, and then use the parameter directly. 123456789import &#123; Controller, Get, Param &#125; from &#x27;@nestjs/common&#x27;;@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; @Get(&#x27;:id&#x27;) findOne(@Param(&#x27;id&#x27;) id: string)&#123; //The parameter type is declared here. return `This action returns #$&#123;id&#125; coffees`; &#125;&#125; ​ Post and @Body decorators The @Body decorator is used to get all or specific parts of request.body. Note that both Post and Body are imported from @nestjs&#x2F;common. The corresponding method of Post is create . 123456789import &#123; Controller, Get, Param, Post, Body &#125; from &#x27;@nestjs/common&#x27;;@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; @Post() create(@Body() body)&#123; return body; &#125;&#125; As with the @Param decorator, it is possible not to access the body as a whole, but a specific part. 123456789import &#123; Controller, Get, Param, Post, Body &#125; from &#x27;@nestjs/common&#x27;;@Controller(&#x27;coffees&#x27;)export class CoffeesController &#123; @Post() create(@Body(&#x27;name&#x27;) body)&#123; //Incoming parameters return body; &#125;&#125; The problem with this way is that if only certain properties are accessed, other properties will not be validated.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"}]},{"title":"Introduction to Nest.js","slug":"NestJS/01 Introduction","date":"2022-09-13T11:31:49.000Z","updated":"2022-11-09T05:39:45.112Z","comments":true,"path":"2022/09/13/NestJS/01 Introduction/","link":"","permalink":"https://redre4per.github.io/2022/09/13/NestJS/01%20Introduction/","excerpt":"","text":"Difference between NestJS and NodeJS NestJS is a framework that lets programmers focus on the application problem at hand rather than the tiny implementation details like setting up TypeScript, API routing, error handling, middleware setup, etc. Think of NestJS as a layer on top of NodeJS itself, abstracting away difficult tasks, tools and boilerplate code, and adding a complete toolkit for application development. NestJS uses express as the bottom layer by default, or you can choose Fastify or others (but you need to set up a compatible library). Before using NestJS First install NodeJS, version 12 or 13 at least. View in Terminal: node --version. Install cli: npm i -g @nestjs/cli. Check the version number of nest after installation: nest --version. Nest cli nest cli is a companion tool for nestJS, which can help us generate files, run, compile and even bundle our applications. It contains many commands, which can be viewed with nest --help. Create your first nest application In Terminal, enter nest new. Then follow the prompts to select the name and package manager. After creation, enter cd new file name, npm run start, you can open and browse to localhost: 3000 to open the file. Nest folder structure Inside the Nest app, everything has a defined structure. In the folder, there are many files that are familiar before, but be aware of a specific unique file called Nest cli json . The entry file of nest is the main.ts file under src. Nest files are created with NestFactory.create(AppModule). AppModule is the root module of our application and contains everything our application needs to run. It consists of many small modules that combine to form a complete application. After opening the app.module.ts file, you can see the decorator @Module(). Decorators can be used on classes or other methods. The first layer in @Module(&#123; &#125;) is the controllers and providers of the entry-level file app.modules.js, if not, delete it. After that, import: [] is used to load other modules. Folders for these modules are placed in the src directory. controller and service basic Controller is a class, but with the @Controller() decorator. Controllers are used to handle specific requests. The controller needs to use service to separate the logic. In the app.controller.ts file: 123456789@Controller()export class AppController&#123; constructor(private readonly appService: AppService)&#123;&#125; @Get() getHello(): string&#123; return this.appService.getHello(); &#125;&#125; In the app.service.ts file: 123456@Injectable()exports class AppService &#123; getHello(): string&#123; return &#x27;Hello World!&#x27;; &#125;&#125; API test software Insomnia &amp; Postman Start Nest in dev mode npm run start: dev. This mode integrates nodemon functionality.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"}],"tags":[{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"}]},{"title":"Custom hooks","slug":"React/H10 Custom hooks","date":"2022-09-03T11:57:27.000Z","updated":"2022-11-12T01:25:47.973Z","comments":true,"path":"2022/09/03/React/H10 Custom hooks/","link":"","permalink":"https://redre4per.github.io/2022/09/03/React/H10%20Custom%20hooks/","excerpt":"","text":"Where to use With custom Hooks, component logic can be extracted into reusable functions. React Hooks means that components should be written as pure functions as much as possible. If external functions and side effects are required, use hooks to “hook” external code in. React Hooks are those hooks. Custom hooks rules **A custom Hook is a function whose name starts with “use“, and other Hooks can be called inside the function. **React will treat functions starting with use differently from other functions. Therefore, functions other than Custom hooks cannot begin with use. scenes to be used The main usage scenarios of Custom hooks: Extract the business logic layer Encapsulate general logic Monitor browser status Split complex components Use Cases Written by myself in the CourtCanva project. scenes to be used: If you write it with a package function, you need to package the function in useEffect(), which will lead to code redundancy. That is, the various states obtained by useStoreSelector() cannot be directly called in external functions, but need to be passed in through parameters. At this time, the encapsulation function requires a large number of parameters, and functions such as useDispatch() are also passed in as parameters. In this case, using a custom Hook is the best choice. This can simplify the code and does not need to pass in the Redux state from the outside, because the custom Hook can call the Redux state or other Hooks internally. 12345678910111213141516171819202122232425import &#123; useStoreSelector &#125; from &quot;@/store/hooks&quot;;import useCourt from &quot;@/hooks/useCourt&quot;;import &#123; setCourtDataUrl &#125; from &quot;@/store/reducer/canvasControlSlice&quot;;import &#123; switchRuler &#125; from &quot;@/store/reducer/buttonToggleSlice&quot;;import &#123; resetAll &#125; from &quot;@/store/reducer/canvasControlSlice&quot;;const useImageDataUrl = (stageRef: RefObject&lt;Konva.Stage&gt;) =&gt; &#123; const dispatch = useDispatch(); const &#123; borderLength &#125; = useCourt(); const selectedColor = useStoreSelector((state) =&gt; state. courtColor. selectedColor); const rulerState = useStoreSelector((state) =&gt; state. buttonToggle. isRulerOn); useEffect(() =&gt; &#123; if (!stageRef.current) return; dispatch(resetAll()); rulerState ? dispatch(switchRuler(false)) : null; const image = stageRef.current.toDataURL(&#123; pixelRatio: 1.5, &#125;); dispatch(setCourtDataUrl(image)); rulerState ? dispatch(switchRuler(true)) : null; &#125;, [selectedColor, borderLength]);&#125;;export default useImageDataUrl;","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"},{"name":"Hooks","slug":"Hooks","permalink":"https://redre4per.github.io/tags/Hooks/"}]},{"title":"List of My VSCode plugins","slug":"Others/VScode plugins","date":"2022-07-03T01:26:48.000Z","updated":"2022-11-12T03:17:54.122Z","comments":true,"path":"2022/07/03/Others/VScode plugins/","link":"","permalink":"https://redre4per.github.io/2022/07/03/Others/VScode%20plugins/","excerpt":"","text":"Auto Close Tag Auto Rename Tag HTML Snippets Babel ES6&#x2F;ES7 Debugger for Chrome ESLint JavaScript (ES6) code snippets Code Spell Checker Node.js Modules Intellisense React-Native&#x2F;React&#x2F;Redux snippets for ES6&#x2F;ES7 TSLint vscode-styled-components Color Highlight Custom CSS and JS Loader EditorConfig for VS Code File Templates Git History (git log) Material Icon Theme Prettier Theme — Seti-Monokai Docker Dev Containers glean JS CodeFormer: Javascript Refactoring &amp; Code Automation Live Server Live Share Tailwind CSS intelliSence vscode-styled-components VSCode React Refactor Wallaby.js","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Other","slug":"Others/Other","permalink":"https://redre4per.github.io/categories/Others/Other/"}],"tags":[{"name":"VSCode","slug":"VSCode","permalink":"https://redre4per.github.io/tags/VSCode/"}]},{"title":"useEffect","slug":"React/H02 useEffect","date":"2022-06-18T13:12:05.000Z","updated":"2022-11-12T01:14:16.486Z","comments":true,"path":"2022/06/18/React/H02 useEffect/","link":"","permalink":"https://redre4per.github.io/2022/06/18/React/H02%20useEffect/","excerpt":"","text":"useEffect() side effects Pure functions can only perform data calculations. Where should operations that do not involve calculations (such as generating logs, storing data, changing application status, etc.) be written? Functional programming refers to operations that have nothing to do with data calculations as “side effects” (side effect). If the function directly contains operations that produce side effects, it is no longer a pure function, and we call it an impure function. Pure functions can contain side effects only through indirect means (i.e. through other function calls). ​ useEffect() basic usage For example, we want the page title (document.title) to change when the component loads. Then, the operation of changing the page title is a side effect of the component and must be implemented through useEffect(). By default, useEffect is executed every time the component renders. 12345678import React, &#123; useEffect &#125; from &#x27;react&#x27;;function Welcome(props) &#123; useEffect(() =&gt; &#123; document.title = &#x27;Loading complete&#x27;; &#125;); return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; ​ useEffect() second parameter Sometimes, we don’t want useEffect() to be executed every time it is rendered. At this time, we can use its second parameter, use an array to specify the dependencies of the side effect function, and re-render only when the dependencies change. 123456function Welcome(props) &#123; useEffect(() =&gt; &#123; document.title = `Hello, $&#123;props.name&#125;`; &#125;, [props.name]); return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; In the above example, the second parameter of useEffect() is an array, which specifies the dependencies of the first parameter (side effect function) (props.name ). The side effect function executes only when this variable changes. If the second parameter is an empty array, it indicates that the side effect parameter does not have any dependencies. Therefore, the side effect function will only be executed once after the component is loaded into the DOM, and will not be executed again after the component is re-rendered. useEffect() purpose Any side effects can be introduced using useEffect(). Its common uses are as follows. data fetching event monitoring or subscription (setting up a subscription) changing the DOM output log (logging) The most common usage is to fetch data, execute useEffect() only once when the component is mounted, and use setState() to put the fetched data into the state. The return value of useEffect() Side effects occur as components are loaded, and may need to be cleaned up when the component is unloaded. If there is any content mounted on dom in useEffect(), you need to use return to clear it. Otherwise, problems will occur, such as memory overflow causing more and more cards. useEffect() allows returning a function that is executed when the component is unmounted, cleaning up side effects. useEffect() does not return any value if there is no need to clean up side effects. In actual use, since the side effect function is executed every time it is rendered by default, the cleanup function will not only be executed once when the component is unloaded, but will also be executed once every time the side effect function is re-executed. Used to clean up side effects from the last render. Use the return value of useEffect() to interrupt outstanding network requests Both axios and fetch have similar methods to interrupt network requests, such as abort() method. You can put the API request in useEffect() and the abort() method in return. At this time, if the API is called repeatedly by triggering useEffect, abort() in the return of the previous useEffect will be triggered. If the previous API request was not completed, it will be interrupted. Notes for useEffect() There is one caveat when using useEffect(). If there are multiple side effects, and there is no relationship between them, multiple useEffect() should be called, and should not be written together. useEffect() does not want to return any value. Therefore, if you put a timer in it, because the timer will return the thread number, it will generate a value. If you don’t use const x=, you will get an error.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"},{"name":"Hooks","slug":"Hooks","permalink":"https://redre4per.github.io/tags/Hooks/"}]},{"title":"useState","slug":"React/H01 useState","date":"2022-06-16T02:28:47.000Z","updated":"2022-11-12T01:08:08.921Z","comments":true,"path":"2022/06/16/React/H01 useState/","link":"","permalink":"https://redre4per.github.io/2022/06/16/React/H01%20useState/","excerpt":"","text":"Basic usage 1const [count, setCount] = useState(initialState) count is to read state, setCount is to update state, and initialState is initial value. ​ State is an array Because React rendering only checks a shallow copy of state, React will not re-render if you only change the value in the array, rather than changing the address of the array. The solution is to copy the original array and reassign it to the state after changing it. State is an object Because React rendering only checks a shallow copy of state, React will not re-render if you only change the value in the object, rather than changing the object address. The solution is to copy the original object and reassign it to the state after the change. Arrow function update Official website. If the new state was computed using the previous state, a function can be passed to setState. The function will receive the previous value, and return an updated value. Here is an example setState that uses two forms of the counter component: The “+” and “-“ buttons use the functional form because the updated value is based on the previous value. But the “reset” button uses the normal form because it always sets the count back to the initial value. If your update function returns the exact same value as the current state, subsequent re-renders will be skipped entirely. 1234567891011function Counter(&#123;initialCount&#125;) &#123; const [count, setCount] = useState(initialCount); return ( &lt;&gt; Count: &#123;count&#125; &lt;button onClick=&#123;() =&gt; setCount(initialCount)&#125;&gt;Reset&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+&lt;/button&gt; &lt;/&gt; );&#125; Arrow functions update state in a way that makes React execute this line before going to the next line. In the normal setState(value) method, sometimes React will execute out of order due to performance optimization. State self-change in useState() Sometimes the state in useState() is used for self-increment and self-decrement, etc. At this time, it is impossible to write code like setCount(count++);, because const [count, setCount] = useState(0); when initially defined, count is a constant. Any direct modification of the state will report an error. But you can use setCount(count+1); instead. Another way is to write an arrow function in setCount(), and then evaluate the formal parameters. The value of the formal parameter is count, which is the first parameter of useState(). 123const increment = () =&gt; &#123; setCount((prev) =&gt; prev + 1);&#125; ​ The value of useState in the callback function will not change In the code below, the number on the page is always 1 greater than the console’s number. This is because the count value passed into the callback function will not change in the callback function. When setCount() is passed for the second time, its parameter count is still obtained from the outside, not the previous line in the callback function, so only 1 is added each time. 1234567891011121314const Footer = () =&gt; &#123; const [count, setCount] = useState(0); const handleCount = () =&gt; &#123; setCount(count+1); setCount(count+1); //Second time. console.log(count); &#125; return( &lt;footer&gt; &lt;p&gt;count: &#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;handleCount&#125;&gt;click me&lt;/button&gt; &lt;/footer&gt; )&#125; ​ useState() note React will run all the code on the component when it re-renders. Therefore, if setState() is not triggered by an event, it will cause re-rendering all the time, causing errors. This is because the state drives the data. Every time the state is set, it will re-render, and then call setState() to set the state again during rendering, infinite loop. If you only want to render once, use useEffect(). When using TS, such as useState&lt;String&gt;(&quot;&quot;), when must the type be defined? If the initial value of the parameter is null, the type needs to be declared. Such as useState&lt;String | null&gt;(&quot;&quot;); double type. The types that can be inferred in ts do not need to be written.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"},{"name":"Hooks","slug":"Hooks","permalink":"https://redre4per.github.io/tags/Hooks/"}]},{"title":"Responsive design","slug":"CSS/R01 Responsive design","date":"2022-05-11T11:12:37.000Z","updated":"2022-11-12T05:40:42.762Z","comments":true,"path":"2022/05/11/CSS/R01 Responsive design/","link":"","permalink":"https://redre4per.github.io/2022/05/11/CSS/R01%20Responsive%20design/","excerpt":"","text":"Responsive Layout One page corresponds to multiple devices. When the device screen&#x2F;pc webpage size changes, the page layout (not the element&#x2F;text size) will be changed automatically. Therefore, there is no need to write mobile pages separately. make suitable choices Bad choice: Choose popular fixtures. The downside is that devices come in a variety and are updated. A good choice: do a survey on 4 types of equipment, each with a width range. The downside is that equipment can still change. The perfect choice: by visual design. Responsive Development Principles of Responsive Development It is to use media queries to set the layout and style for devices of different widths, so as to adapt to the purpose of different devices. Device division Size interval (size refers to width) Layout container (usually) width setting Very Small Screen (Mobile) &lt;768px 100% Small screen devices (tablets) &gt;&#x3D;768px ~ &lt;992px 750px Moderate devices (desktop monitors) &gt;&#x3D;992px ~ &lt;1200px 970px widescreen devices (large desktop monitors) &gt;&#x3D;1200px 1170px Responsive layout container Responsive requires a parent as a layout container to cooperate with child elements to achieve change effects. The principle is to change the size of the layout container through media queries under different screens, and then change the arrangement and size of the sub-elements inside, so as to realize different page layout and style changes under different screens. Common widths of layout containers are shown in the table above. The container is a little less than the screen to make the page centered and aligned with blanks on both sides, which looks better. You can use media query to write .container &#123;&#125; by yourself in four cases. Media query Responsive design should be realized through media query. 12345@media only screen and (max-width: 600px) &#123; body &#123; background-color: lightblue; &#125;&#125; only screen is because there is a printer, speech and screen reader. For example, when the page supports printing, you can write only printer to define what content should be displayed. max-width: 600px is the old design scheme, that is, laptop is preferred. min-width: 600px Modern design is mobile-first. Such as Tailwind, Chakra. In addition, there are also horizontal&#x2F;flat parameters, such as orientation: landscape. These are advanced actions, for phones and tablets.","categories":[{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"https://redre4per.github.io/categories/HTML-CSS/"},{"name":"CSS","slug":"HTML-CSS/CSS","permalink":"https://redre4per.github.io/categories/HTML-CSS/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://redre4per.github.io/tags/CSS/"}]},{"title":"Reference","slug":"DataBase/MongoDB/7 Reference","date":"2022-04-30T02:38:05.000Z","updated":"2022-11-12T00:00:29.822Z","comments":true,"path":"2022/04/30/DataBase/MongoDB/7 Reference/","link":"","permalink":"https://redre4per.github.io/2022/04/30/DataBase/MongoDB/7%20Reference/","excerpt":"","text":"The schema part of the associated code In the schema we care about two pieces of information: the type of the association id (type), and which collection the association is (ref). The association of mongoose can only store id, and cannot store other fields because it is not supported. If you want to store fields other than id, you need to write the corresponding logic to get the fields. If it is to many, it is necessary to use association attribute s: [&#123; &#125;], if it is one to one, it is necessary to Use Associative property: &#123; &#125; . Example for many-to-many bidirectional association: 12345//schema 1courses: [&#123; type: mongoose.Types.ObjectId, //If the id type is String, write String. ref: &#x27;Course&#x27; //The model name associated with the collection, note that it is capitalized.&#125;] 12345//schema 2students: [&#123; type: mongoose.Types.ObjectId, ref: &#x27;Student&#x27;&#125;] ​ The controller part of the associated code Divided into two parts: add association and delete association. Add association Note here that in a many-to-many relationship, addCourseToStudent() and addStudentToCourse() are the same thing. Here you need to get the id information of the two parties you want to associate, and this information is written on the url: /v1/students/:id/courses/:code. If it is to add an association, the method is POST. What needs to be guaranteed is that the variable names (:id, :code) on the url must be consistent with those in const &#123; &#125; = req.params. After getting the id, first verify whether the (two) ids exist. In addition, since two id objects need to be used to verify the existence of the function, it is necessary to import the schema of another id object, such as const Course = require(&#39;../modules/course&#39;); 1234567891011121314151617181920async function addCourseToStudent(req, res)&#123; const &#123; id, code &#125; = req.params; //Take two ids const student = await Student.findById(id).exec(); //Verify that id1 exists const course = await Course.findById(code).exec(); //Verify that id2 exists if (!student || !course) &#123; //Process when there is no id return res.status(404).json(&#123; error: &#x27;Category or Subcategory not found&#x27;, &#125;); &#125; student.courses.addToSet(course._id); //It is recommended to use addToSet instead of push to avoid repetition course.students.addToSet(student._id); //Two-way binding //If it is a one-to-one relationship, that is, the associated id is not an array, it only needs to be written as student.course = course._id await student.save(); //save await course.save(); //save return res.json(student);&#125; After writing, export this function and register the route in the routing file. 1studentRouter.post(&#x27;/:id/courses/:code&#x27;, addCourseToStudent) Remove association is very similar to adding. Just change the function name in the add code to removeCourseToStudent and then addToSet() to pull(). Also, the request method should be changed from POST to DELETE. There are two logics for deletion, one is to delete whether there is a connection or not; the other is to detect whether there is a connection first, and then delete it. Usually don’t care, because the front end will know whether there is a relationship when fetching data, and the delete option will pop up when there is a relationship. If it is a one-to-one relationship, simply reassign the resource of ref to undefined. Schema and path issues for two-way binding In two-way binding, the ref in the schema must be written by both parties. However, in the controller and router, only one of them needs to be coded, because when the unilateral controller is coded, the schema of both sides will be directly introduced, and _id will be added to both sides and saved on both sides. Get the associated data after creating the association: populate() In the getXXXById() function in the controller file, add populate(&#39;field&#39;) after the findById(id) function. 123456async function getStudentById(req, res)&#123; const &#123;id&#125; = req.params; const student = await Student.findById(id).populate(&#x27;course&#x27;).exec(); if(!student)&#123;return ...&#125;; res.json(student);&#125; If the document corresponding to the query id is not associated, populate() will not report an error, but only the associated item will not be displayed. The principle here is that the principle of populate is that mongoose sends two requests to the database and splices them together. This is determined by the database structure of mongoose. All data cannot be obtained in one request, so splicing exists on the server side. Instead, sql is stitched together in the database. But mongodb also supports database-side splicing processing, which uses aggregation. Later optimization may be used, and populate can be used in the initial stage. populate() also supports fetching only a subset of fields. Same as MongoDB section 2.3.5. (id will be retrieved by default) 1const student = await Student.findById(id).populate(&#x27;course&#x27;,&#x27;name description&#x27;) .exec(); populate() can also fetch multiple nested data with two-paragraph chaining, but this is not recommended. However, this is the only way to fetch multiple associated resources. Because a single populate() can only be selected from the same resource, even with multiple attributes. Scenarios for populate() When fetching all the data, generally only metadata is needed, so there is no need to populate (resource waste). Generally, populate() is done when fetching a specific document. If two resources are associated and you want to fetch them at the same time, you can call populate() in a chain. Decide which fields populate() selects in the front end Sometimes there are too many fields associated with the resource, and the required fields must be selected from the front end (API control). 1234567async function getStudentById(req, res)&#123; const &#123; id &#125; = req.params; const &#123; fields &#125; = req. query; const student = await Student.findById(id).select(&#x27;&#x27;).populate(&#x27;course&#x27;).exec(); //Get the student&#x27;s if(!student)&#123;return ...&#125;; res.json(student);&#125; ​ Remove related associations when deleting resources When mongoose finds that the associated resource does not exist, it will not report an error. But this results in a lot of invalid data being present. 123456789101112async function deleteStudentById(req, res)&#123; const &#123;id&#125; = req.params; const student = await Student.findByIdAndDelete(id).exec(); if(!student)&#123;return...&#125;; await Course.updateMany(&#123; students:student._id&#125;, &#123; //:?.? $pull:&#123; students:student._id &#125; &#125;).exec(); res.sendStatus(204);&#125; Both sides of a bidirectional association delete the association. The code logic is the same. In the one-to-one relationship, because it is not an array, $pull cannot be used, otherwise the error “MongoServerError: Cannot apply $pull to a non-array value” will appear. The $unset operator should be used instead, with the same syntax. 123456789101112async function deleteRootCategoryId(req, res) &#123; const &#123; id &#125; = req.params; const rootCategory = await RootCategory.findByIdAndDelete(id).exec(); if (!rootCategory) &#123;&#125; await SubCategory.updateMany(&#123; parentCategory: rootCategory._id &#125;, &#123; $unset: &#123; parentCategory: rootCategory._id &#125; &#125;).exec() res.sendStatus(204);&#125; Summary The associated code is divided into three parts: schema (two-way and two-way), controller (two-way one-way&#x2F;two-way), and router (two-way one-way). In the controller, there are three parts to be added and rewritten: Add an association function (two-way and one-way) Delete the associated function (two-way and one-way) The function to find a single resource plus populate() (both sides) Delete the function of a single resource plus delete the associated code (both sides)","categories":[{"name":"Database","slug":"Database","permalink":"https://redre4per.github.io/categories/Database/"},{"name":"MongoDB","slug":"Database/MongoDB","permalink":"https://redre4per.github.io/categories/Database/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://redre4per.github.io/tags/MongoDB/"}]},{"title":"Error handling","slug":"DataBase/MongoDB/6 Error handling","date":"2022-04-27T23:12:52.000Z","updated":"2022-11-12T00:00:30.899Z","comments":true,"path":"2022/04/28/DataBase/MongoDB/6 Error handling/","link":"","permalink":"https://redre4per.github.io/2022/04/28/DataBase/MongoDB/6%20Error%20handling/","excerpt":"","text":"Method 1: try catch wraps the async request 1234567891011async function addStudent(req, res)&#123; const &#123;firstName, lastName, email&#125; = req.body; const student = new Student(&#123; firstName, lastName, email&#125;); try&#123; await student.save(); &#125; catch (e)&#123; console.log(e); return res.send(e); &#125; res.status(201).json(student);&#125; Catch errors when writing async await. ​ Method 2: Use .catch to get the error of promise 123456789async function addStudent(req, res)&#123; const &#123;firstName, lastName, email&#125; = req.body; const student = new Student(&#123; firstName, lastName, email&#125;); student.save().then().catch(e =&gt; &#123; //promise.catch console.log(e); return res.send(e); &#125;) res.status(201).json(student);&#125; Catch errors when writing promises. ​ Method 3: Callback function 1234567891011async function addStudent(req, res)&#123; const &#123;firstName, lastName, email&#125; = req.body; const student = new Student(&#123; firstName, lastName, email&#125;); student.find(error, result) =&gt; &#123; //callback function, similar to promise style if(error)&#123; console.log(e); return res.send(e); &#125; &#125; res.status(201).json(student);&#125; It is used to catch errors when writing callback functions. ​ Method selection If you are writing a new project yourself, you can choose the writing method at will. It is recommended to use the async await writing method. If it is to take over the existing code, write it in the way of the company’s current code. Writing in actual development (try catch method extension) The try catch method wraps the await code. And try catch can expand the scope, that is, wrap the entire C&#x2F;R&#x2F;U&#x2F;D function of the route handler (such as addStudeny()), that is, catch the error of the route handler. Likewise, this error handling applies to all route handlers. In the following writing method, the purpose of the function is to wrap the function passed in as a parameter in a try catch, and register it on the path as a middleware after wrapping. 12345678910function tryCatch(routeHandler)&#123; //Definition, in the student folder in the controllers file return async (req, res, next) =&gt; &#123; //Return a middleware, because this middleware needs to be registered on the path. try&#123; await routeHandler(req, res, next); &#125; catch(e)&#123; next(e); //Pass the error object to the error handling middleware. &#125; &#125;&#125;tryCatch(addStudent); Common errors are usually passed to the error handling middleware with next(e). And more specific errors will be handled directly in the function. For example, method one is often mixed with this method. Common errors are passed into the error handling middleware in this method, and specific errors are handled in the function using the method of method 1. Fetch errors directly with the express-async-errors package It enters the express framework for try catch operation. Install: npm i express-async-errors --save This package is for express@4 version. In the express@5 version, the official has built this function. (@4.18 for p3) This package should be imported under the index.js file. 1234const express = require(&#x27;express&#x27;);require(&#x27;express-async-errors&#x27;); //Use the express-async-errors package immediately after using the express packageconst User = require(&#x27;./models/user&#x27;);... In addition, const a = require(&#39;a&#39;) is written because a is exported in the file. But it should be noted that whether the file is exported or not has no effect on the execution of the code inside the file, that is, when require(&#39;a&#39;), the code inside the a file has been executed once. And express-async-errors has made changes to the express object in the code, no need to export. The error returned at this time is an error interpretation of express, which is difficult to read and needs further processing. For handling captured errors, you can create an errorHandler.js file in the middleware folder (&#x4e;&#x6f;&#x64;&#101;&#46;&#106;&#x73;&#x40;&#52;&#46;&#x35;): 123456module.exports = (error, req, res, next) =&gt; &#123; console.log(error); return res.status(500).json(&#123; error:&#x27;Error! Please try later&#x27;, &#125;)&#125; ErrorHandler.js is referenced in index.js and registered on the app. (Written before connectToDB) 1app.use(errorHandler); At this time, an error is returned, which is status code 500, and the returned JSON content is customized. Therefore, how to handle errors is actually based on the logic in errorHandler.js. 500 is an under-the-radar error, and a series of if&#x2F;else or switch should actually be used to handle various errors. The logic in it is to detect the type of error and then handle it. like: 1234567891011module.exports = (error, req, res, next) =&gt; &#123; if(error.name === &#x27;validationError&#x27;)&#123; //Original method, because it is unknown whether there is a name attribute in error. //To find the error property by breakpoint or documentation. return res.status(400).json(error); //This is to pass the error object to the front end. But actually only the message is needed. &#125; //In fact, the development environment returns all the information, and the production environment only needs to return the message. console.log(error); return res.status(500).json(&#123; error:&#x27;Error! Please try later&#x27;, &#125;)&#125; Compatible with the production environment and the development environment: 1234567module.exports = (error, req, res, next) =&gt; &#123; if(error.name === &#x27;validationError&#x27;)&#123; if(process.env.NODE_ENV === &#x27;production&#x27;)&#123; return res.status(400).json(&#123; error: error.message&#125;); &#125; return res.status(400).json(error); &#125; A better way to detect: 1234567891011module.exports = (error, req, res, next) =&gt; &#123; if(error instanceof CustomError)&#123;&#125;&#125;next(new CustomError(&#x27;xxxxx&#x27;)); // throw errorclass CustomError extends Error &#123; constructor(message)&#123; super(message); &#125;&#125; ​ handling more bugs If there are too many errors, the errorHandler.js file will be too long. The file should be removed at this time. The structure should then be: 12345|-- middleware |-- error |-- index.js //Introduce all error handling files and export them uniformly |-- validationErrorHandler.js //If the error is a validation error, return it; if not, use `next()` to pass to the next file. |-- xxxxErrorHandler.js At this time, it should also be imported with app.use() in index.js in the root directory.","categories":[{"name":"Database","slug":"Database","permalink":"https://redre4per.github.io/categories/Database/"},{"name":"MongoDB","slug":"Database/MongoDB","permalink":"https://redre4per.github.io/categories/Database/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://redre4per.github.io/tags/MongoDB/"}]},{"title":"Project structure","slug":"Express/8 Project structure","date":"2022-04-16T06:23:58.000Z","updated":"2022-11-10T14:01:16.978Z","comments":true,"path":"2022/04/16/Express/8 Project structure/","link":"","permalink":"https://redre4per.github.io/2022/04/16/Express/8%20Project%20structure/","excerpt":"","text":"Create a project First create the src folder in the project folder, then create the entry file index.js in it, then run npm init -y . Then install express, dotenv, cors, morgan, Mongoose packages. npm i express dotenv cors morgan mongoose. morgan can show which requests are sent to the server. Project Structure (Orientation 1) 123456789101112131415161718192021--package.json--package-lock.json--src |-- index.js //Entry file (server.js, app.js) |-- routes |-- tasks.js //(task router) (or named task.routes.js) |-- users.js //(user router) (or named users.routes.js) |-- index.js //(Import all the routers above and make a unified export) |-- controllers // (logical processing part) |-- tasks.js //(task Controller) (or named tasks.controllers.js) |-- users.js //(user Controller) (or named users.controllers.js) |-- models |-- tasks.js //(task Controller) The format design of the task data in the database. Used for ORM (object relational mapping, used to interact with the database). |-- middleware |-- error-middleware |-- xxxErrorHandler.js |-- authGuard |-- cors |-- utils //(Helper function, shared function, db) There is a high probability. |-- db |-- config //Project configuration (environment variable processing), not necessarily. ​ Other project structures There are other splitting methods for this splitting direction, possibly merging routes and controllers, which is also very common. In the above split method, there is no logic in routes, it just points to controllers. Another way to split is to add a layer of services. The logic of services is separated from controllers. If it is removed, controllers will not be responsible for logic processing. Each additional layer of the project becomes more complex.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Express.js","slug":"Back-end/Express-js","permalink":"https://redre4per.github.io/categories/Back-end/Express-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"Express.js","slug":"Express-js","permalink":"https://redre4per.github.io/tags/Express-js/"}]},{"title":"Mongoose","slug":"DataBase/MongoDB/4 Mongoose","date":"2022-04-16T03:58:04.000Z","updated":"2022-11-12T00:00:32.345Z","comments":true,"path":"2022/04/16/DataBase/MongoDB/4 Mongoose/","link":"","permalink":"https://redre4per.github.io/2022/04/16/DataBase/MongoDB/4%20Mongoose/","excerpt":"","text":"Mongoose Introduction Mongoose is a package that uses promises and async&#x2F;await. Mongoose is an ORM (object relational mapper) or ODM (object data mapping), which is specific to Mongodb. It encapsulates functions such as CRUD, provides new interfaces, and is more convenient. There are similar packages for other databases like the sequelize package for databases like mySQL. In actual development, there is rarely direct interaction with the database, and the ORM library is used for CRUD. If you pursue the ultimate efficiency, you may write an ORM library by hand, because the popular ORM library is aimed at most users. Data is fetched from the database to the server, and it will go through the Mongoose layer in the middle. Mongoose will convert json raw data into Object in JS, so that we can operate Mongoose objects by operating on Object. There’s some performance loss here, and sometimes you don’t need to convert, you need to optimize yourself. ​ Keywords in Mongoose Schema, Model, Document are keywords in Mongoose. schema is the data design diagram, the fields that list the data, etc. Model (corresponding to collection in Mongodb) is to create a model through schema drawings. One use is to generate a document (create a model instance), which needs to be passed in the fields defined in the schema. Another use of Model is collection operations on data, you can add documents, search the entire collection, etc. document is slightly different from document in Mongodb, it is similar to document in Mongodb. It is a JS object and is created by Mongoose. Therefore, it is not only the data in bson format in the database, but also supports the API in Mongoose to process data more conveniently. 123const schema = new mongoose.Schema(&#123;name: String&#125;);const Model = mongoose.model(&#x27;Model&#x27;, schema);const document = new Model(&#123;name: &#x27;document&#x27;&#125;) ​ Install Mongoose npm i mongoose Because Mongoose is used to create a model for a resource, it should be placed in the models folder under src. ​ Processing of pictures in the database There are generally two ways to process images. Save the base64 image directly to the database. In this case, if the image is large, each read will be slower. Not recommended. The database will not store data directly, but first upload the image to the image bed (such as github, AWS S3), and the platform will return the url and then store it in the database.","categories":[{"name":"Database","slug":"Database","permalink":"https://redre4per.github.io/categories/Database/"},{"name":"MongoDB","slug":"Database/MongoDB","permalink":"https://redre4per.github.io/categories/Database/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://redre4per.github.io/tags/MongoDB/"}]},{"title":"Relationships","slug":"DataBase/MongoDB/3 Relationships","date":"2022-04-15T11:36:45.000Z","updated":"2022-11-12T00:00:34.274Z","comments":true,"path":"2022/04/15/DataBase/MongoDB/3 Relationships/","link":"","permalink":"https://redre4per.github.io/2022/04/15/DataBase/MongoDB/3%20Relationships/","excerpt":"","text":"Association (similar to sql) In sql, the association may be 1-to-many, and the many parts may be 0, 1, and Many. The data in Mongodb is stored in the form of an array, so it may be 0 data, regardless of whether it is 0 or not. The principals associated in Mangodb are documents in the collection. There are one-to-one, one-to-many, and many-to-many associations in MongoDB. Associations are further divided into embedded and referenced. Embedded: directly embed another document into the current document and become an Object of it. 123456_id: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;)name: &quot;derek&quot;address: Objectcity: &quot;sydney&quot;address: &quot;01234 Yesenia Loop&quot;postcode: 3456 The above is a one-to-one situation. In the one-to-many case, multiple additional documents form an array, each element of which is an object. 1234567891011_id: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;)name: &quot;derek&quot;address: Array 0: Objectcity: &quot;sydney&quot;address: &quot;01234 Yesenia Loop&quot;postcode: 3456 1: Objectcity: &quot;brisbane&quot;address: &quot;166 adelaide street&quot;postcode: 4000 The many-to-many case is more complicated than the reference form. Because when you need to modify the embedded Object, because of many-to-many, it corresponds to multiple documents, then you need to scan the entire collection. So in many-to-many, the reference form is generally used. Reference : The reference is in one document and stores the _id of another associated document. One-on-one time: Reference 123_id: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;)name: &quot;derek&quot;address: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxx111&quot;) In another collection 12345_id: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;)city: &quot;sydney&quot;address: &quot;01234 Yesenia Loop&quot;postcode: 3456student: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;) In a one-to-many case, the _ids of multiple other documents will form an array, each element being an _id. Reference 12345_id: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;)name: &quot;derek&quot;address: Array 0: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx1&quot;) 1: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx2&quot;) In another collection 1234567891011_id: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx1&quot;)city: &quot;sydney&quot;address: &quot;01234 Yesenia Loop&quot;postcode: 3456student: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;)------------------------------------------------_id: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx2&quot;)city: &quot;brisbane&quot;address: &quot;166 adelaide street&quot;postcode: 4000student: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;) There is no change in the many-to-many case, except that the other multiple documents also use an array to represent the associated documents. Reference 12345_id: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;)name: &quot;derek&quot;address: Array 0: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx1&quot;) 1: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx2&quot;) In another collection 123456789101112131415_id: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx1&quot;)city: &quot;sydney&quot;address: &quot;01234 Yesenia Loop&quot;postcode: 3456student: Array 0: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;) 1: ObjectId(&quot;yyyyyyyyyyyyyyyyyyyyyyyyy&quot;)---------------------------------------------_id: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx2&quot;)city: &quot;brisbane&quot;address: &quot;166 adelaide street&quot;postcode: 4000student: Array 0: ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;) 1: ObjectId(&quot;yyyyyyyyyyyyyyyyyyyyyyyyy&quot;) ​ Two-way binding and one-way binding in Reference If you use document1 (such as students), you only need to know document2 (such as address), and you don’t need to know which document1 (student) is in document2 (address) at all, just use a one-way association. But if you want to search document1’s information from document2, you need two-way binding. Normalization and de-Normalization De-Normalization is duplication, such as duplicating another document data in Embedded, and normalization is the opposite. In practice, it is common to copy a small piece of data in another document, such as city in address, without copying other details in address. The advantage of this is that there is no need to use the populate form to fetch data through the associated operation document (performance-intensive), and the query time is faster. But the disadvantage is that if the address is updated, the copied information needs to be updated. There is a trade-off, considering which operations users use read&#x2F;write more. one to millions relationship An extreme example of unilateral binding. There is a 16mb limit for a single document in Mongodb, some smaller in other databases. For example, there is one data file and one million sensor files. At this time, data cannot be stored in the sensor file because it takes up too much space. At this time, the sensor should be bound one-way with data. Embedded and referenced usage scenarios If you can do embedded, try to do it, especially in the case of one-to-one relationship. If it is one to several, you can consider embedded, but it depends on the scene. If you think the number of couples in one to couple will not expand to hundreds, you can use it. If it’s a pair of hundreds or more, consider using citations If it is a pair of millions, consider unilateral binding references If reading requirements are much greater than writing requirements, de-normalization should be considered to copy frequently read data to improve query efficiency. Index The purpose of index is to help sort and find faster. Two common types of indexes are sort ordering and unique uniqueness. By default, there is only _id index (guaranteed uniqueness) in the collection. Aggregation Aggregation pipeline is to modify or add to a certain raw data, similar to middleware, here called stage. Data can be filtered&#x2F;added and passed to subsequent stages. Aggregation operations can be implemented entirely on the server side, but the performance is much worse. Because databases are designed to manipulate data, and Node.js is not. Therefore, the operation of data should be done on the database side as much as possible. Also, all data is manipulated on the server side, a lot of data is transferred, and a lot of data is useless. The best way is to operate the data on the database side now, and then pass it to the server. Transaction Transactions are combined data operations, such as bank transfers, adding money and subtracting money to be combined in a transaction. It can guarantee that different data operations succeed or fail at the same time. The transaction function can be added later.","categories":[{"name":"Database","slug":"Database","permalink":"https://redre4per.github.io/categories/Database/"},{"name":"MongoDB","slug":"Database/MongoDB","permalink":"https://redre4per.github.io/categories/Database/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://redre4per.github.io/tags/MongoDB/"}]},{"title":"CORS","slug":"Express/7 CORS","date":"2022-04-14T13:39:21.000Z","updated":"2022-11-10T13:47:11.721Z","comments":true,"path":"2022/04/14/Express/7 CORS/","link":"","permalink":"https://redre4per.github.io/2022/04/14/Express/7%20CORS/","excerpt":"","text":"Interface cross domain problem There are two main solutions to solve the interface cross-domain problem: CORS (mainstream solution, recommended) JSONP (flawed solution, only supports GET requests) Use cors middleware to solve cross-domain problems cors is a third-party middleware for Express. Cross-domain problems can be easily solved by installing and configuring cors middleware. Steps for usage: Run npm install cors install middleware Use const cors = require(&#39;cors&#39;) import middleware Call app.use(cors()) before routing Configure middleware What is CORS CORS (Cross-Origin Resource Sharing) consists of a series of HTTP response headers that determine whether the browser prevents front-end JS code from obtaining resources across domains. By default, the browser’s same-origin security policy prevents web pages from obtaining resources across domains. However, if the interface server is configured with CORS-related HTTP response headers, the cross-domain access restriction on the browser side can be lifted. Precautions: CORS is mainly configured on the server side. The client browser can request the CORS-enabled interface without any additional configuration. CORS is compatible with browsers. Only browsers that support XMLHttpRequest Level2 can normally access the server-side interface with CORS enabled, such as IE10+, Chrome4+, FireFox3.5+. CORS related response headers Access-Control-Allow-Orign Access-Control-Allow-Orign: &lt;origin&gt;|* : where the origin parameter value specifies the out-of-domain URL that is allowed to access the resource. For example the following field value will allow only requests from http://itcast.cn: 1res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;http://itcast.cn&#x27;) If the specified value is the wildcard *, it means that requests from any domain are allowed: 1res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;) Access-Control-Allow-Headers By default, CORS only supports the client to send 9 request headers to the server (the client request header is not within these 9, the request fails): Accept, Accept-Language, Content-Language, DPR, Downlink, Save-Data, Viewport-Width, Width, Content-Type (values are limited to text&#x2F;plain, multipart&#x2F;form-data, application&#x2F;x-www-form -urlencoded one of the three) If the client sends additional request header information to the server, it needs to declare the additional request header on the server side through Access-Control-Allow-Headers, otherwise the request will fail. 1res.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;Content-Type, X-Custom-Header&#x27;) Access-Control-Allow-Methods By default, CORS only supports client-side GET, POST, and HEAD requests. If the client wants to request the server’s resources through PUT, DELETE, etc., it needs to specify the HTTP methods allowed by the request through Access-Control-Allow-Methods on the server side. . 1res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;POST, GET, DELETE, HEAD&#x27;) 1res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;*&#x27;) ​ Classification of CORS Requests When the client requests the CORS interface, according to the difference of request method and request header, the CORS request can be divided into two categories classes, which are: Simple request: Both conditions are met: The request method must be one of GET, POST, HEAD The HTTP header information must not contain custom headers, which need to be within the nine request headers in Section 4.7.4.2 Preflight request: As long as the request meets any of the following conditions, a preflight request must be made The request method is a request method other than GET, POST and HEAD The request header contains custom header fields The data in application&#x2F;json format is sent to the server Before the browser and the server formally communicate, the browser will send an OPTION request for preflight to know whether the server allows the actual request, so this OPTION request is called a preflight request. After the server successfully responds to the preflight request, it will send the real request with real data. The difference between a simple request and a preflight request: In a simple request, the client and the server only make one request, while the preflight request is twice (OPTION preflight request and real request).","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Express.js","slug":"Back-end/Express-js","permalink":"https://redre4per.github.io/categories/Back-end/Express-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"Express.js","slug":"Express-js","permalink":"https://redre4per.github.io/tags/Express-js/"}]},{"title":"Interface (Summary)","slug":"Express/6 Interface","date":"2022-04-14T11:47:07.000Z","updated":"2022-11-10T13:46:29.408Z","comments":true,"path":"2022/04/14/Express/6 Interface/","link":"","permalink":"https://redre4per.github.io/2022/04/14/Express/6%20Interface/","excerpt":"","text":"Create interface steps (summarize previous lessons) Create the basic server: app.js 123456const express = require(&#x27;express&#x27;)const app = express()//main codeapp.listen(80, function()&#123; console.log(&#x27;Express server running at http://127.0.0.1&#x27;)&#125;) Create an API routing module apiRouter.js routing module 1234const express = require(&#x27;express&#x27;)const apiRouter = express.Router()//main codemodule.exports = apiRouter app.js import and register routing module 12const apiRouter = require(&#x27;./apiRouter.js&#x27;)app.use(&#x27;/api&#x27;, apiRouter) ​ Write a GET interface 12345678apiRouter.get(&#x27;/get&#x27;, (req, res) =&gt; &#123; const query = req.query //req.query can access the parameters sent to the server in the form of query strings, see 4.1.8 for details. res.send(&#123; status: 0, //0 succeeds, 1 fails msg:&#x27;GET request succeed&#x27;, data:query &#125;)&#125;) ​ Write POST interface 12345678apiRouter.post(&#x27;/post&#x27;, (req, res) =&gt; &#123; //Get the URL-encoded data sent by the client to the server through the request body const body = req.body //req.body object, which can access the request body data, see 4.5.5 for details. res.send(&#123; status: 0, //0 succeeds, 1 fails msg:&#x27;POST request succeed&#x27;, data:body &#125;)&#125;) Note: If you want to get the request body data in URL-encoded format, you must configure the middleware: 1app.use(express.urlencoded(&#123;extended:false&#125;)) ​ Interface cross domain problem The above GET&#x2F;POST interface does not support cross-domain requests. (It appears that postman can request success, but the request in the html page cannot be successful.) ​","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Express.js","slug":"Back-end/Express-js","permalink":"https://redre4per.github.io/categories/Back-end/Express-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"Express.js","slug":"Express-js","permalink":"https://redre4per.github.io/tags/Express-js/"}]},{"title":"Middleware classification","slug":"Express/5 Middleware classification","date":"2022-04-13T13:18:48.000Z","updated":"2022-11-10T13:37:00.281Z","comments":true,"path":"2022/04/13/Express/5 Middleware classification/","link":"","permalink":"https://redre4per.github.io/2022/04/13/Express/5%20Middleware%20classification/","excerpt":"","text":"Classification of middleware Express officially divides common middleware usage into five categories: Application-level middleware Route-level middleware Error-level middleware Express built-in middleware Third-party middleware Application level middleware Via app.use() or app.get() or app.post() , Middleware bound to the app instance, called application-level middleware. (That is, the example in Section 4.4.) 123456app.use((req, res, next) =&gt; &#123; next()&#125;)app.get(&#x27;/&#x27;, mw1, (req, res) =&gt; &#123; res.send(&#x27;Home page.&#x27;)&#125;) ​ Route level middleware Middleware bound to an express.Router() instance is called a route-level middleware. Its usage is no different from application-level middleware. The difference is that the application-level middleware is bound to the app instance, and the route-level middleware is bound to the router instance: 123456789const app = express()const router = express.Router()router.use(function(req, res, next)&#123; //Route-level middleware console.log(&#x27;Time: &#x27;, Date.now()) next()&#125;)app.use(&#x27;/&#x27;, router) //register route and add prefix ​ Error level middleware The role of the error level middleware: It is specially used to capture the exception errors that occur in the entire project, thereby preventing the problem of the project from crashing abnormally. When an error occurs in the code, it can be directly caught by the error middleware (the code jumps to the error middleware), similar to catch(). If the error middleware is not written, the project will crash when an error occurs and cannot continue to run. In the function processing function of the error level middleware, must have 4 formal parameters, which are (err, req, res, next) from front to back. Error level middleware must be registered after all routes. 12345678910111213141516app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; //Route throw new Error(&#x27;Error in server!&#x27;) //Throw a custom error res.send(&#x27;Home page.&#x27;)&#125;)const middleware1 = (req, res) =&gt; &#123; //Route if token not exist &#123; next(new Error(&#x27;error&#x27;)) // use next() to throw an error return; &#125; next()&#125;)app.use(function(err, req, res, next)&#123; //Error level middleware console.log(&#x27;Error happened: &#x27; + err.message) //Print error message on the server res.send(&#x27;Error! &#x27; + err.message) //Response error message to client&#125;) There are generally multiple error middleware, and each error middleware is responsible for one type of error. When calling the next error middleware, the error needs to be passed on in the form of next() parameter. However, even with multiple error middleware, there is no guarantee that all errors are caught 100%. So check if the error was passed to the last error middleware (the last error middleware doesn’t handle errors, it’s the bottom line). If passed, it should return a 500 status code (bad choice, but only write a 500 status code), and log the error for later fixes. How to handle errors in the error handler, determine the statue code, and extract the information from the error object Errors are not written by themselves 12345const errorM1 = (error, req, res, next) =&gt; &#123; //error usually passes an object, although a string can be passed. if(error.type === &#x27;validationError&#x27;)&#123; res.status(400).json(&#123;error:error.message&#125;); &#125;&#125; Errors are self-written and detected with instanceof. This method can detect whether the former is an instance of the latter. If the former is inherited by the latter via new constructs or extends, it counts as an instance of the latter. 12345const errorM1 = (error, req, res, next) =&gt; &#123; if(error instanceof CustomError)&#123; res.status(400).json(&#123;error:error.message&#125;); &#125;&#125; Registration error middleware Registered globally in app.use(), before app.listen(). Express built-in middleware Since Express version 4.16.0, Express has built-in 3 commonly used middleware to improve development efficiency and experience: express.static The built-in middleware for fast hosting of static resources (detailed in Section 4.2), such as HTML files, images, CSS styles, etc., has no compatibility. express.json parses the request body data in JSON format (with compatibility, only available in 4.16.0+ version). The request body data can be generated in postman, select body-raw-rightmost drop-down menu and select JSON. Object in JSON format, attribute name must be added with &quot; &quot;. The req.body property can be used in the server to receive the request body data sent by the client. By default, req.body equals undefined if no middleware for parsing form data is configured. The parsed data will be mounted in req.body and can be accessed later. 1app.use(express.json()) //Global middleware. There is no need to add parameters/attributes in (), because it is a global analysis. express.urlencoded parses request body data in URL-encoded format (compatibility, only available in 4.16.0+ versions). Basically the same as express.json usage. Select body-(x-www-form-urlencoded) on postman. 1app.use(express.urlencoded(&#123; extended:false &#125;)) //Global middleware, fixed writing ​ Third-party middleware It is not an official built-in Express, but a middleware developed by a third party. Before express 4.16.0, the body-parser third-party middleware was often used to parse request body data. Third-party middleware needs to be downloaded and configured to be used. Steps for usage: Run npm install middleware package_name to install the middleware Use require to import middleware (requires path) Call app.use() to register and use middleware Custom middleware case Manually emulate a middleware like express.urlencoded to parse the form data POSTed to the server. step: Define middleware Listen to the data event of req (as long as the data event is triggered, it proves that data is sent to the server) In the middleware, you need to listen to the data event of the req object to get the data sent by the client to the server (use .on to listen). If the amount of data is relatively large and cannot be sent all at once, the client will cut the data and send it to the server in batches. Therefore, the data event may be triggered multiple times. Each time the data event is triggered, the obtained data is only a part of the complete data, and the received data needs to be spliced manually. 1234let str = &#x27;&#x27; //Used to store the request body data sent by the clientreq.on(&#x27;data&#x27;, (chunk) =&gt; &#123; //.on method binds events. str += chunk //splicing request body data&#125;) //Next() is not written here because it is not a separate middleware, but it is placed inside the same middleware with the end event below. Listen to the end event of req (end triggering proves that the data has been sent and the server has completely received the form data) 123req.on(&#x27;end&#x27;, () =&gt; &#123;console.log(str)&#125;) Use the querystring module to parse the request body data 12345const qs = require(&#x27;querystring&#x27;)req.on(&#x27;end&#x27;, () =&gt; &#123;const body = qs.parse(str) next()&#125;) Mount the parsed data object as req.body (because express uses req.body to receive the request body data from the client, here we need to replace the original data with data in a new format) The upstream middleware and downstream middleware and routes share the same req and res. Therefore, we can mount the parsed data as a custom attribute of req and name it req.body for downstream use. 123456const qs = require(&#x27;querystring&#x27;)req.on(&#x27;end&#x27;, () =&gt; &#123;const body = qs.parse(str) req.body = body next()&#125;) Encapsulate custom middleware into modules 1234//custom-body-parser.js moduleconst qs = require(&#x27;querystring&#x27;)function bodyParser(req, res, next)&#123;/* Omit other code, in fact, put the previous steps into a middleware */&#125;module.exports = bodyParser //encapsulated into a module 12const myBodyParser = require(&#x27;custom-body-parser&#x27;)app.use(myBodyParser) //call the module","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Express.js","slug":"Back-end/Express-js","permalink":"https://redre4per.github.io/categories/Back-end/Express-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"Express.js","slug":"Express-js","permalink":"https://redre4per.github.io/tags/Express-js/"}]},{"title":"Middleware","slug":"Express/4 Middleware","date":"2022-04-12T08:35:04.000Z","updated":"2022-11-10T13:20:58.112Z","comments":true,"path":"2022/04/12/Express/4 Middleware/","link":"","permalink":"https://redre4per.github.io/2022/04/12/Express/4%20Middleware/","excerpt":"","text":"The concept of middleware Middleware refers specifically to the intermediate processing links of business processes. The calling process of Express middleware is that when a request arrives at the Express server, multiple middleware can be called continuously, so as to perform Preprocessing. Format of Express Middleware The middleware of Express is essentially a function processing function (the formal parameters are different from ordinary functions, and there is more next). In the formal parameter list of the middleware function, must contain the next parameter. And the route handler only contains req and res. The next function is the key to realize multiple middleware continuous calls, it means that the flow relationship Pass to the next middleware or route. After the business processing of the current middleware is completed, must call the next function. 1234567const express = require(&#x27;express&#x27;)const app = express()app.get(&#x27;/&#x27;, (req, res, next) =&gt; &#123; //Middleware function next();&#125;)app.listen(80, () =&gt; &#123;console.log(&#x27;server running at http://127.0.0.1&#x27;)&#125;) Define a simplest middleware function 1234const mw = function(req, res, next)&#123; console.log(&#x27;This is easist Middleware function&#x27;); next();&#125; ​ Globally effective middleware any request initiated by the client, after reaching the server, will trigger the middleware, which is called the globally effective middleware. By calling app.use(middleware function), you can define a middleware that is globally effective: 123456const mw = function(req, res, next)&#123; console.log(&#x27;This is easist Middleware function&#x27;); next();&#125;app.use(mw) //Register as globally effective middleware Other routes can be written as usual. In this way, after the server receives the request, it will call the middleware function mw first, and then continue to match the calling route. A simplified form of the global middleware (replace the function with an anonymous function): 1234app.use(function(req, res, next)&#123; console.log(&#x27;This is easist Middleware function&#x27;); next();&#125;) ​ The role of middleware in development Between multiple middleware, share the same req and res. Based on this feature, we can uniformly add custom properties or methods to the req or res object in the middleware of upstream for the downstream of is used by middleware or routing. For example, add req.a = 10 on middleware 1 and res.c = 30 on middleware 2. In this way, in the final route, the property value can be obtained by accessing req.a and res.c. For example, we want to get the time when the server received the request. If you don’t use middleware, you need to write a time acquisition function in each route. If you use middleware, you only need to get the function at the time when the middleware is written, then assign the function value to req.time , and then the route can get the value from req.time . Define multiple global middleware Multiple global middleware can be defined consecutively using app.use(). After the client request arrives at the server, will call in the order defined by the middleware. E.g: 1234567891011app.use(function(req, res, next)&#123; //The first global middleware console.log(&#x27;call 1st global middleware&#x27;); next();&#125;)app.use(function(req, res, next)&#123; //The second global middleware console.log(&#x27;call 2nd global middleware&#x27;); next();&#125;)app.get(&#x27;/user&#x27;, (req, res) =&gt; &#123; //Requesting this route will trigger the above two middleware in turn res.send(&#x27;Home page.&#x27;)&#125;) ​ Locally effective middleware Do not use the middleware defined by app.use(), which is called a locally effective middleware, such as: 12345678910const mw1 = function(req, res, next)&#123; console.log(&quot;This is middleware 1&quot;) next()&#125;app.get(&#x27;/&#x27;, mw1, function(req, res)&#123; //mw1 middleware only takes effect in the current route. That is, the middleware that takes effect locally res.send(&#x27;Home page.&#x27;)&#125;)app.get(&#x27;/user&#x27;, function(req, res)&#123; //mw1 middleware will not affect the following routes. res.send(&#x27;User page.&#x27;)&#125;) ​ Define multiple local middleware These two methods are equivalent in the code. 12app.get(&#x27;/&#x27;, mw1, mw2, function(req, res)&#123; res.send(&#x27;Home page.&#x27;) &#125;)app.get(&#x27;/&#x27;, [mw1, mw2], function(req, res)&#123; res.send(&#x27;Home page.&#x27;) &#125;) ​ Precautions Be sure to register middleware before routing. Because it is matched from top to bottom, the route will no longer match after the response. The request sent by the client can be processed by calling multiple middleware continuously. The next function must be called after the middleware is executed. If not called, the request cannot continue processing backwards. In order to prevent code logic confusion, do not write code after calling the next function. When multiple middlewares are called continuously, the req and res objects are shared among multiple middlewares.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Express.js","slug":"Back-end/Express-js","permalink":"https://redre4per.github.io/categories/Back-end/Express-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"Express.js","slug":"Express-js","permalink":"https://redre4per.github.io/tags/Express-js/"}]},{"title":"Route","slug":"Express/3 Route","date":"2022-04-10T22:25:38.000Z","updated":"2022-11-10T13:19:00.566Z","comments":true,"path":"2022/04/11/Express/3 Route/","link":"","permalink":"https://redre4per.github.io/2022/04/11/Express/3%20Route/","excerpt":"","text":"Route Concept Routing is a mapping relationship. In Express, routing refers to the mapping between client requests and server processing functions. The route in Express consists of three parts, which are request type, requested URL address, and processing function. The format is as follows: 1app.METHOD(PATH, HANDLER) For example, a simple route: 123456app.get(&#x27;/&#x27;, function(req, res)&#123; res.send(&#x27;Hello World!&#x27;)&#125;)app.post(&#x27;/&#x27;, function(req, res)&#123; res.send(&#x27;Got a POST request&#x27;)&#125;) Route matching process Whenever a request arrives at the server, needs to be matched by the route first, and only after the match is successful, the corresponding processing function will be called. When matching, it will be matched in the order of routing. If the request type and request URL match successfully at the same time, then Express will Transfer this request to the corresponding function for processing. The matching is performed according to the defined sequence. When the matching is successful, the following routes will not be matched again (that is, the preceding routes have higher priority). If the match is successful, the corresponding function will be called, and if the match is unsuccessful, the match will continue. For routes registered by methods such as app.get(), the path needs to be completely matched, and the request method must be completely matched to take effect. But app.use() is special, because express uses regular expressions to match (that is, the path of app.use() parameter 1 can be written as positive side expression, usually not necessary). In regular expressions * means match everything. and app.use() adds a * after the incoming string parameter, so as long as the path at the beginning of the incoming string is considered a successful match, it does not need to be completely match. We also use app.use(express.json()) when registering global routes, that is, the first parameter is not written. In fact, the first parameter here is * (app.use() added for the path itself), but it is omitted, and the result is that all paths can be matched. Simple usage of route The easiest way to use a route in Express is to mount the route to the app, such as: 123456const express = require(&#x27;express&#x27;)const app = express()app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; res.send(&#x27;Hello World!&#x27;) &#125;)app.post(&#x27;/&#x27;, (req, res) =&gt; &#123; res.send(&#x27;Got a POST request&#x27;) &#125;)app.listen(80, () =&gt; &#123;console.log(&#x27;server running at http://127.0.0.1&#x27;)&#125;) ​ Modularization of route In order to facilitate the modular management of routes, Express does not recommend mounting routes directly to the app, but recommends extracting routes into separate modules. Proceed as follows: Create a .js file corresponding to the routing module Call the express.Router() function to create a route instance object (in the route module file) 12const express = require(&#x27;express&#x27;)const router = express.Router() Mount the specific route to the routing instance object (in the routing module file) 12router.get(&#x27;/user/list&#x27;, (req, res) =&gt; &#123; res.send(&#x27;Get user list.&#x27;) &#125;)router.post(&#x27;/user/add&#x27;, (req, res) =&gt; &#123; res.send(&#x27;Add new user.&#x27;) &#125;) Use module.exports to share routing objects outward (in routing module file) 1module.exports=router Register the routing module with the app.use() function (in the main file) 12const userRouter = require(&#x27;./router/user.js&#x27;) //Import routing moduleapp.use(userRouter) //register route Note: The purpose of the app.use() function is to register the global middleware.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Express.js","slug":"Back-end/Express-js","permalink":"https://redre4per.github.io/categories/Back-end/Express-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"Express.js","slug":"Express-js","permalink":"https://redre4per.github.io/tags/Express-js/"}]},{"title":"MongoDB structure, terminal, CRUD","slug":"DataBase/MongoDB/2 MongoDB terminal CRUD","date":"2022-04-10T02:05:31.000Z","updated":"2022-11-12T00:00:35.666Z","comments":true,"path":"2022/04/10/DataBase/MongoDB/2 MongoDB terminal CRUD/","link":"","permalink":"https://redre4per.github.io/2022/04/10/DataBase/MongoDB/2%20MongoDB%20terminal%20CRUD/","excerpt":"","text":"Mongodb structure Databases Server: After installing mongodb, when the mongodb program is started, the databases server is started. Databases: There are multiple databases in the databases server. Collections: There are multiple collections in each database. For example, in a school system, teachers and students are separate collections. Documents: There are multiple documents in each collection, similar to json (ie object) format. For example &#123;_id: ObjectId(&#39;xxx1&#39;), name: &#39;Tom&#39;, grade: 9&#125; is a document. Fields: In the json-like format file of Document, each key is a field. There are multiple clients that can access the database mongo shell: command line program mongodb compass: graphical interface, all operations are realized by clicking, similar to the github desktop version. script: code, such as JS type of data Data types are similar to JS. Common data such as: _id: int32 (The default is ObjectId, which contains some random numbers and machine physical information to ensure non-repetition) Name: Text (string) Hobbies: array (array of string) Address: object (embeded document) Wishes: array (array of documents) Boolean Number (can be subdivided into int32 (default), int64, float) Date (ISODate (default), timestamp) Mongodb command line basic operations, add, delete, modify and check show dbs: Display database information, databases in database server. Default admin, config and local. show collections: Display all collection names in the current database. use databaseName: create a new database (when the database name does not exist), or switch to a database (when the database name exists). Add a single new collection and documents (additional): 1db.collection.insertOne() The db object refers to the currently used database, such as the school database. The collection name is to create a new collection collection (if the collection name does not exist), or use an existing collection collection in the database (if the collection name exists). insertOne() is to add document, the parameter is document (object, ie json). like: 1db.students.insertOne(&#123;&quot;name&quot;:&quot;mason&quot;&#125;) Return log information: 1234&#123; &quot;acknowledged&quot; : true, #Indicates that the server has received the request &quot;insertedId&quot; : ObjectId(&quot;6291fd3083ebd0086fc7152a&quot;) #Mongodb automatically creates an ID&#125; You can also add multiple documents at a time, that is, pass an array with multiple documents in the array: 1db.students.insertOne([&#123;&quot;name&quot;:&quot;Raymond&quot;&#125;,&#123;&quot;name&quot;:&quot;Siri&quot;&#125;]) Multiple _ids will be generated corresponding to multiple documents. Find the data in the current collection (find multiple) (check), and return the result 1db.collection.find() #such as db.students.find() 1&#123; &quot;_id&quot; : ObjectId(&quot;6291fe3f83ebd0086fc7152b&quot;), &quot;name&quot; : &quot;Derek&quot; &#125; #Return result Find data in the current collection (find one, and be the first data in the current collection) 1db.collection.findOne() Find the specified condition data, the condition is that the value of a field is xxx. Note that the key here does not have &quot; &quot; . 1db.collection.findOne(&#123;name:&quot;max&quot;&#125;) find() actually has a second parameter, which is the display condition (which fileds are displayed in the returned result). The field value to be displayed in the display condition is 1, and the default is 0. But _id defaults to impressions, i.e. the value is 1. 1db.students.find(&#123;&#125;, &#123;name:1, _id:0&#125;) Update data (change single) (change). Receive two parameters, parameter 1 is how to filter the data (find the first matching document), parameter 2 is what to update the found document. The operator operator is used when updating, which is called update operator: $set:&#123;&#125; . 1db.collection.updateOne(&#123;name:&quot;Derek&quot;&#125;,&#123;$set:&#123;&quot;name&quot;:&quot;James&quot;&#125;&#125;) It is also possible to add new fields: 1db.collection.updateOne(&#123;name:&quot;James&quot;&#125;,&#123;$set:&#123;&quot;Hobbies&quot;:[&quot;football&quot;,&quot;gaming&quot;]&#125;&#125;) Update data (change multiple) to match all eligible documents. 1db.collection.updateMany(&#123;name:&quot;James&quot;&#125;,&#123;$set:&#123;&quot;Hobbies&quot;:[&quot;football&quot;,&quot;gaming&quot;]&#125;&#125;) There is also a db.collection.replaceOne() method for complete replacement. Delete a document. Filter first, then delete the target document. The syntax is the same as search, means the key does not have &quot; &quot; . 1db.collection.deleteOne() 1db.students.deleteOne(&#123;name:&quot;Derek&quot;&#125;) Delete multiple documents. Note that deleteMany(&#123;&#125;) operation is very dangerous, which means that all documents can be matched and all documents in the current collection will be deleted. This command is not used during development. 1db.collection.deleteMany() Note that if you delete all documents in the current collection, the collection still exists; to delete the current collection, the command is db.collectionname.drop(). Information including indexes will also be deleted. Delete a document. Filter first, then delete the target document. The syntax is the same as search, means the key does not have &quot; &quot; . 1db.collection.deleteOne() 1db.students.deleteOne(&#123;name:&quot;Derek&quot;&#125;) Delete multiple documents. Note that deleteMany(&#123;&#125;) operation is very dangerous, which means that all documents can be matched and all documents in the current collection will be deleted. This command is not used during development. 1db.collection.deleteMany() Note that if you delete all documents in the current collection, the collection still exists; to delete the current collection, the command is db.collection.drop(). Information including indexes will also be deleted. MongoDB command line related tips The tab key can be filled with the collection name, that is, just write a collection name at the beginning. The logic is the same as the Node.js path. If the data brackets in the inserted document are missing (a bracket is not closed), the returned result will be ... . The solution is to type both open and closed when parentheses are entered, and then return the input content. You can also pass in an empty document: &#123;&#125; . Still unique because of the _id. You can also specify _id when adding a document, such as: 1db.students.insertOne(&#123;&quot;_id&quot;:&quot;6291fe3f83ebd0086fc7152b&quot;,&quot;name&quot;:&quot;mason&quot;&#125;) This works fine. But compared to the automatically generated id, the specified _id is not wrapped in ObjectId(), means the type is different. The _id specified by yourself is of type string, and the automatically generated _id is of type ObjectId. There will be a third-party package to help us type conversion during development, so don’t care. operator operator operator will start with $. Official Detailed Documentation update operator Update operator. $set query operator query operator. $exists, the syntax is { field: { $exists: } } . When boolean is true, $exists matches documents that contain fields, including documents whose field value is null; when boolean is false, $exists returns documents that do not contain the corresponding field. projection operator display operator (for fetching data)","categories":[{"name":"Database","slug":"Database","permalink":"https://redre4per.github.io/categories/Database/"},{"name":"MongoDB","slug":"Database/MongoDB","permalink":"https://redre4per.github.io/categories/Database/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://redre4per.github.io/tags/MongoDB/"}]},{"title":"Host static resources","slug":"Express/2 Host static resources","date":"2022-04-09T05:56:21.000Z","updated":"2022-11-12T00:01:22.298Z","comments":true,"path":"2022/04/09/Express/2 Host static resources/","link":"","permalink":"https://redre4per.github.io/2022/04/09/Express/2%20Host%20static%20resources/","excerpt":"","text":"express.static() express.static() can be very convenient to create a static resource server. It can specify a directory to be hosted as a static resource folder, and can access all files under the directory folder. For example, the images, CSS files, and JS files in the public directory can be opened to the outside world through the following code. 1app.use(express.static(&#x27;./public&#x27;)) //Write the folder path, such as ./clock. If not, write the absolute path. Once configured, you can access all files in the public directory: http://127.0.0.1/images/bg.jpg http://127.0.0.1/css/style.css http://127.0.0.1/js/login.js Note: Express looks for files in the specified static directory, and provides access paths to resources. However, the name of the directory where static files are stored (eg public) will not appear in the URL. Hosting multiple static resource directories To host multiple static resource directories, call express.static() multiple times. When accessing static resource files, the express.static() function will look for the required files according to the order in which the directories are added (for example, both folders have index.html, which is written in front. After the first folder finds the file will not look back). 12app.use(express.static(&#x27;./public&#x27;))app.use(express.static(&#x27;./files&#x27;)) Mounted path prefix If you want to mount the path prefix before the hosted static resource access path, you can use the following methods. 1app.use(&#x27;/public&#x27;, express.static(&#x27;public&#x27;)) Once configured, you can access files in the public directory through addresses with a &#x2F;public prefix: http://127.0.0.1/public/images/bg.jpg http://127.0.0.1/public/css/style.css http://127.0.0.1/public/js/login.js","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Express.js","slug":"Back-end/Express-js","permalink":"https://redre4per.github.io/categories/Back-end/Express-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"Express.js","slug":"Express-js","permalink":"https://redre4per.github.io/tags/Express-js/"}]},{"title":"npm and package","slug":"Express/1 Express basics","date":"2022-04-08T09:04:42.000Z","updated":"2022-11-12T00:54:44.859Z","comments":true,"path":"2022/04/08/Express/1 Express basics/","link":"","permalink":"https://redre4per.github.io/2022/04/08/Express/1%20Express%20basics/","excerpt":"","text":"Introduction to Express Express is a fast, open and minimal web development framework based on the Node.js platform. Express is similar to the built-in http module of Node.js, and is specially used to create web servers. The essence of Express: it is a third-party package on npm that provides a convenient way to quickly create a web server. If you don’t use Express, you need to use the native http module. But the http built-in module is very complicated to use, and the development efficiency is low; Express is further encapsulated based on the built-in http module, which can greatly improve the development efficiency (similar to the relationship between Web API and jQuery). What Express can do For front-end programmers, two common servers are: Web site server: a server dedicated to providing external Web page resources. API interface server: a server dedicated to providing API interfaces to the outside world. Express can create both types of servers quickly and easily. Install Express Terminal command: npm i express@4.17.1 Create a web server 123456const express = require(&#x27;express&#x27;)const app = express()app.listen(80, () =&gt; &#123; console.log(&#x27;express server running at http://127.0.0.1&#x27;)&#125;) ​ Listening for GET&#x2F;POST requests Through the app.get() app.post() methods, you can listen to the client’s GET request. 12app.get(&#x27;Request URL&#x27;, function(req, res)&#123;&#125;)app.post(&#x27;Request URL&#x27;, function(req, res)&#123;&#125;) ​ Respond content to client The res.send() method can send the processed content to the client. (res.send() default status code is 200) 123456app.get(&#x27;/user&#x27;, (req, res) =&gt; &#123; res.send(&#123;name:&#x27;zs&#x27;, age:20, gender:&#x27;male&#x27;&#125;)&#125;)app.post(&#x27;/user&#x27;, (req, res) =&gt; &#123; res.send(&#x27;request succeed&#x27;)&#125;) res.json() method is the same as res.send() method. The difference is that res.send() has a check to check if the incoming object is in string or json format or something else. If it is a json object, it will be returned in json format. This is equivalent to res.send() with the res.json() method built-in. Writing the res.json() method is equivalent to being more explicit, making sure to transfer the object back in json format. When writing, generally choose the res.json() method. If you want to return only the response status code, you can use res.sendStatus(), such as: 1res.sendStatus(204) Just set the status code without returning: 1res.status(201) //will return a response object 1res.status(201).json(&#123;&#125;) //Return the corresponding data at the same time ​ Return question The return in app.get(&#39;/&#39;, (req, res) =&gt; &#123; return &#125;) is a matter of personal code style. In most cases, adding or not adding return is the same. But there is a situation where return must be added, that is, if logic judgments such as if are involved in the callback function to generate branches. In branches, return must be added to each branch to ensure that the code in other branches that follow will not be executed. In addition, the following two return methods are also different: 12res.send(&#x27;Hello world&#x27;);return; 1return res.send(&#x27;Hello world&#x27;); From the results of running the code, there is no difference between the two writing methods. But if TS type checking is involved, it will result in different types being returned: the first writing method returns undefined, and the second returns the respond type. How to get data from req body fetch data req.body can retrieve the data in the request body sent by the client. Used for POST, PUT, PATCH requests. 12const &#123;name&#125; = req.body;res.send(&#123;name&#125;) //This is ES6 abbreviation, it should be res.send(&#123;name: name&#125;) query param to get data req.query can retrieve the parameters sent by the client to the server from the URL in the form of query string. Defaults to an empty object, used for GET requests. 12345app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; //The client uses ?name=tom&amp;age=20 to send parameters in the form of query strings console.log(req.query.name) //Can be accessed with the properties in req.query console.log(req.query.age) res.send(req.query)&#125;) route param (/:id ) to get data (get dynamic parameters in the URL) The req.params object can be accessed in the URL through the dynamic parameters matched by : . The string after : can be written arbitrarily, as long as it is reasonable and legal, and the final result returned by the req.params object is &#123;&quot;:the latter string&quot;:&quot;dynamic parameters requested by the client&quot;&#125; . For example /my/article/:id , where id is not a static value, but a dynamic parameter (dynamically matched parameter value). req.params defaults to an empty object. route param can be used for GET, POST, PUT, DELETE four operations, but in most cases it is id. 1234app.get(&#x27;/user/:id&#x27;, (req, res) =&gt; &#123; //The client request is http://127.0.0.1/1, and the id is 1. console.log(req.params) res.send(req.params) //The returned result is &#123;&quot;id&quot;:&quot;1&quot;&#125;&#125;) There can also be multiple dynamic parameters, such as 1app.get(&#x27;/user/:id/:name&#x27;, (req, res) =&gt; &#123;&#125; Server-side requests should be http://127.0.0.1/1/Tom .","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Express.js","slug":"Back-end/Express-js","permalink":"https://redre4per.github.io/categories/Back-end/Express-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"Express.js","slug":"Express-js","permalink":"https://redre4per.github.io/tags/Express-js/"}]},{"title":"Introduction to MongoDB","slug":"DataBase/MongoDB/1 MongoDB basic","date":"2022-04-08T05:03:11.000Z","updated":"2022-11-12T00:00:36.866Z","comments":true,"path":"2022/04/08/DataBase/MongoDB/1 MongoDB basic/","link":"","permalink":"https://redre4per.github.io/2022/04/08/DataBase/MongoDB/1%20MongoDB%20basic/","excerpt":"","text":"Install You need to download the package. After decompression and installation, you need to create a \\data\\db file in the root directory of the C drive to store the data: cd C:\\md &quot;\\data\\db&quot; . The way to start Mongodb is to enter the command line in the folder C:\\Program Files\\MongoDB\\Server\\5.0\\ bin, and then enter the command: 1mongod --dbpath c:\\data\\db After the server starts, you can find Listening on address: 127.0.0.1, port: 27017 (default port number) in the pop-up information. At this point, enter the following command to connect to the database. The interface at this time is the mongo shell, which is based on the JS engine. The cls command clears the screen. 1C:\\mongodb\\bin\\mongo.exe Another startup method is the configuration file, which is used during deployment. SQL and non-SQL Another understanding of non-SQL (or no SQL) is not only SQL. It can not only do the functions of relational databases, but also functions that relational databases cannot. There are four main categories of non-SQL: document-oriented: data is stored in the form of documents, such as mongodb, dynamodb, firebase key-value: cache database, such as redis graph-oriented: a database (graph theory) based on graphs, such as neo4j column-family: for big data, such as cassandra Mongodb introduction Mongo comes from humongous (huge) and is used to process huge data. Documents are stored in a json-like (key-value pair) form, which is strictly called BSON (binary JSON). It has some types that json does not support, such as _id: ObjectId(&#39;xxx&#39;) does not exist in json, it is a type created by mongodb. 1234&#123; _id: ObjectId(&#x27;xxx&#x27;), //A unique identifier used to represent data. name: &#x27;yyy&#x27;&#125; Flexibility or schemaless Schema is the design diagram of the data, which defines which properties and fields the data has. Schema is not a strictly prescribed design diagram, so data can be stored without schema. For example, collection (collection, corresponding to table in sql), contains multiple data of the same type (document), but there is no hard requirement, and the data can also be of different types. The only thing to make sure is that the _id (data identifier) cannot be repeated, like: 1234567891011121314[ &#123; _id: ObjectId(&#x27;xxx1&#x27;), name: &#x27;yyy&#x27;&#125;, &#123; _id: ObjectId(&#x27;xxx2&#x27;), name: &#x27;yyy&#x27;&#125;, &#123; _id: ObjectId(&#x27;xxx3&#x27;), username: &#x27;yyy&#x27; //Different data types can also be received.&#125;] However, we will avoid doing this during development, and still ensure that the data has a fixed structure for easy traversal.","categories":[{"name":"Database","slug":"Database","permalink":"https://redre4per.github.io/categories/Database/"},{"name":"MongoDB","slug":"Database/MongoDB","permalink":"https://redre4per.github.io/categories/Database/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://redre4per.github.io/tags/MongoDB/"}]},{"title":"Publish package","slug":"NodeJS/14 publish package","date":"2022-04-06T12:58:51.000Z","updated":"2022-11-10T12:39:34.930Z","comments":true,"path":"2022/04/06/NodeJS/14 publish package/","link":"","permalink":"https://redre4per.github.io/2022/04/06/NodeJS/14%20publish%20package/","excerpt":"","text":"Initialize the basic structure of the package The folder my-package of the new key package, as the root directory of the package In the my-package folder, new key the following three files: package.json package management configuration file The entry file of the index.js package README.md package description file Initialize package.json 123456789&#123; &#x27;name&#x27;:&#x27;my-package&#x27;, //name attribute and package folder name can be different. But the package name is ultimately determined by the name attribute. //The package name is unique. You should go to npm to retrieve the package name before naming it. &#x27;version&#x27;:&#x27;1.0.0&#x27;, //Default initial version number &#x27;main&#x27;:&#x27;index.js&#x27;, //When the outside world imports a folder through require(), it will be automatically searched through the main attribute &#x27;description&#x27;:&#x27;Time and HTMLEscape formatting function&#x27;, //Users can see it in npm search &#x27;keywords&#x27;:[&#x27;my-package&#x27;, &#x27;dateFormat&#x27;, &#x27;escape&#x27;], //Search keywords &#x27;license&#x27;:&#x27;ISC&#x27; //Open source protocol, the default ISC protocol.&#125; ​ Develop features in your own package: escape HTML, restore HTML Used to escape user input. If the user input has html related characters, it will cause a display error. 12345678910function htmlEscape(htmlStr)&#123; return htmlStr.replace(/&lt;|&gt;|*|&amp;/g, (match) =&gt; &#123; //Regular, g is a global match switch(match)&#123; case &#x27;&lt;&#x27;: return &#x27;&amp;lt;&#x27; case &#x27;&gt;&#x27;: return &#x27;&amp;gt;&#x27; case &#x27;*&#x27;: return &#x27;&amp;quot;&#x27; case &#x27;&amp;&#x27;: return &#x27;&amp;amp;&#x27; &#125; &#125;)&#125; 12345678910function htmlUnescape(str)&#123; return htmlStr.replace(/&amp;lt;|&amp;gt;|&amp;quot;|&amp;amp;/g, (match) =&gt; &#123; switch(match)&#123; case &#x27;&amp;lt;&#x27;: return &#x27;&lt;&#x27; case &#x27;&amp;gt;&#x27;: return &#x27;&gt;&#x27; case &#x27;&amp;quot;&#x27;: return &#x27;*&#x27; case &#x27;&amp;amp;&#x27;: return &#x27;&amp;&#x27; &#125; &#125;)&#125; There is also a formatted time function in the example, which is very simple not to record. Function modular split in the package Split the corresponding functions into src -&gt; function1.js. For example, split the function of formatting time into src-&gt;dataFormat.js, and split the function of processing HTML strings into src-&gt;htmlEscape.js. In index.js, import two modules to get the methods that need to be shared externally. In index.js, use module.exports to share the corresponding method. Because some modules have multiple functions, the spread operator ...function1 should be used directly to expose them all (even if there is only one function in the module). Write a README document Written in markdown format. There is no mandatory requirement for the content, as long as the description of the function, usage, and precautions of the clear package can be written. For example, the README document includes: Installation method Import method Format time function Escape HTML function Restore HTML function Open Source Protocol When writing, you can paste the code, start with a newline ```js, and end with ``` after a newline. The title should start with ##. Open Source Protocol ISC. Release Package Register an npm account (on the npm official website) Log in to your npm account (in the terminal) and execute npm login . Fill in the account password and email according to the prompts. Note that before running the command, you must first switch the download server address to the official server of npm (the official server in AU), otherwise it will cause the release of the package to fail. Run the npm publish command (move to the root directory of the package to publish, no need to write the package name in the command) to publish the package to npm. Package names must not be repeated. Log in to npm and click on yourself -&gt; package to view the package. Remove published package Run the npm unpublish package name --force command to delete it. But note: The npm unpublished command can only delete packages published within 72 hours. After exceeding it can never be deleted. Packages deleted by npm unpublished cannot be published repeatedly within 24 hours. Be careful when publishing packages, try not to publish meaningless packages on npm.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"npm","slug":"npm","permalink":"https://redre4per.github.io/tags/npm/"}]},{"title":"Package structure","slug":"NodeJS/13 package structure","date":"2022-04-06T05:12:37.000Z","updated":"2022-11-10T12:38:17.345Z","comments":true,"path":"2022/04/06/NodeJS/13 package structure/","link":"","permalink":"https://redre4per.github.io/2022/04/06/NodeJS/13%20package%20structure/","excerpt":"","text":"Classification of packages Project package: The packages installed in the node_modules directory of the project are all project packages. Project packages can also be subdivided into two categories: Development dependency packages: The packages recorded in the devDependencies node will only be used during development. Core dependency package: The package recorded in the dependencies node will be used during development and after the project is launched. Global package: When executing the npm install command, if the -g parameter is provided, the package will be installed as a global package. Global packages are installed by default in the C:\\Users\\User Directory\\AppDate\\roaming\\npm\\node_modules directory. Installation command: npm i package name -g; uninstall command: npm uninstall package name -g Only tool-like packages are necessary for global installation because they provide useful terminal commands. To determine whether a package needs to be installed globally before it can be used, you can refer to the official instructions for use. i5ting_toc i5ting_toc is a small tool that can convert md documents into html pages, using steps: 12npm install -g i5ting_toci5ting_toc -f path to md file to convert -o Canonical package structure A standard package, the composition structure must meet 3 requirements: Packages must exist as separate directories The package management configuration file package.json must be included in the top-level directory of the package Package.json must contain three properties: name (package name), version (version number) and main (package entry). When the outside world imports a package through require(), it imports the file pointed to by the main attribute.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"npm","slug":"npm","permalink":"https://redre4per.github.io/tags/npm/"}]},{"title":"npm and package","slug":"NodeJS/12 npm and package","date":"2022-04-04T11:06:37.000Z","updated":"2022-11-10T12:37:42.309Z","comments":true,"path":"2022/04/04/NodeJS/12 npm and package/","link":"","permalink":"https://redre4per.github.io/2022/04/04/NodeJS/12%20npm%20and%20package/","excerpt":"","text":"Package Third-party modules in Node.js are also called packages (just by a different name). Packages are encapsulated based on built-in modules, providing a more advanced and convenient API, which greatly improves development efficiency. Source of packages: Packages are developed by third-party individuals or teams and are free for everyone to use. Packages in Node.js are free and open source. The download site for packages is npm, which is the largest package sharing platform in the world. The server address of npm is http://registry.npmjs.org/ , which cannot be opened directly but can be downloaded using tools. The name of this package management tool is Node Package Manager, or npm package management tool for short. This package management tool is installed on the user’s computer along with the Node.js installation package. You can run the npm -v command in the terminal to check the version number. Install the package in the project npm install the full name of the package: Install the package (latest version) in the project. When executed, the package name and version number will be recorded in package.json. npm i package full name : Installed package, shorthand. For the usage of the package, you can go to npmjs to search for the package name and find Documentation, which is the documentation. If you want to find a package, generally do not search directly on npm, but Google search package name + npm. After finding it, click in to see if the README is detailed, which represents the user’s experience. Then go to the code repository on GitHub to see how many stars (&lt;1000 means not popular), and issues. Looking at issues can see whether developers reply and provide solutions, which is very important for niche packages. Also look at Pull requests to see when was the last merge. An active package may have a merge every one or two months. If it has not been updated for a long time (and there is no special statement in the README), it means it is not active. Try not to select this package. In addition, it is best to create a new project and try the package before installing the package to verify the results. @ symbol: install the specified version of the package. For example npm i moment@2.22.2 . If you have already installed other versions of the package and want to reinstall it, you do not need to uninstall the original version package, but directly execute the new command. Semantic version specification for packages: the first digit is the major version, the second digit is the feature version, and the third digit is the bugfix version. The rule of version number promotion is that as long as the previous version number increases, the latter version number will be zeroed. After initial packaging: node_modules and package-lock.json After the first package, there is an additional folder called node_modules and a configuration file of package-lock.json under the project folder. node_modules folder is used to store all packages that have been installed into the project. When require() imports a third-party package, it looks for and loads the package from this directory. package-lock.json configuration file is used to record the download information of each package in the node_modules directory, such as package Name, version number, download address. This file can record the version number of each package when you install the package (such as installing express), and lock it. Reinstalling the package in the future, and the package-lock.json file exists, will be installed according to the version in package-lock.json. Note: Do not manually modify any code in node_modules and package-lock.json, the npm package management tool will automatically maintain it. If you want to manually change the version, just use @ to follow the corresponding version package. If the package-lock.json file is deleted, the original file cannot be restored. You can only use npm install to regenerate the package-lock.json of the current package version. Package management configuration file: package.json npm stipulates that in the project root directory, a package management configuration file called package.json must be provided to record configuration information related to the project: Project’s name, version number, description, etc. Which packages are used in the project which packages will only be used during development Which packages are needed for development and deployment The problem of multi-person collaboration The third-party package is too large. For example, the entire project volume is 30.4M, the third-party package is 28.8M, and the project source code volume is 1.6M. This makes it difficult to share project source code among team members. Solution: We only upload the source code (1.6M) when we share, and remove node-modules (the removal method is to write node_modules&#x2F; in the .gitIgnore file), others from the Internet Download third-party packages. But how do we let others know which third-party packages we use? Record the packages in the project: The package.json configuration file is used to record which packages are installed by the project. After removing node-modules in this way, the project source code can be shared among team members. Note: During project development, be sure to add the node_modules folder to the .gitignore ignore file. Quickly create package.json npm init -y Create a new package.json file in the directory where the command is executed. After creating a new project folder, the first thing to do is to execute this command first, and it only needs to be executed once during project development. Note that the above command can only be successfully run in the English directory, so Chinese and spaces should not appear in the project folder. npm install full name of package The package name and version number will be recorded in package.json when the installation command is executed. Without npm init, there is no package.json file, but there are still node-modules and package-lock.json files. This results in failure to log installed packages. package.json and package-lock.json If there is no package-lock.json, npm will install according to the package version in package.json; if there is package-lock.json, it will be installed according to the version of package-lock.json. Package-lock.json file change problem After manual modification of package-lock.json, if a new package is installed without saving, it will cause an error to be reported because it cannot be saved. The solution is to simply close the file window (without saving it) and reopen it. The new package installed after opening will exist, and manual changes will be rolled back, just rewrite. Another solution is to force-save (with the current version) and reinstall the new package. dependencies node The dependencies node is created in the package.json file after running the npm install package_full_name command. It is used to record which packages are installed using the npm install package_full_name command. Install all packages at once When we get a project with node_modules removed, we need to download all the packages to the project before we can run the project, otherwise the following error will be reported: 1Error: Cannot find module &#x27;moment&#x27; You can run npm install (shortened to npm i) to install all dependencies at once. Uninstall package, update package npm uninstall package full name This command can uninstall the specified package. There is no shorthand for this command. After successful uninstallation with this command, the uninstalled package will be removed from dependencies in package.json. npm outdated can count the version of the package you use and the latest version of the package. Not commonly used, you can look at it before updating. npm update updates the package based on the Wanted version. uncommonly used. devDependencies node If some packages are only used during the development phase of the project and will not be used after the project is launched, it is recommended to record these packages in the devDependencies node. Correspondingly, if some packages need to be used after development and project launch, it is recommended to record these packages in the dependencies node. The npm install packagename --save-dev command can log packages to the devDependencies node. is abbreviated as npm i package name -D . npx Packages that previously needed to be installed globally, such as nodemon and creat-react-app, need to be installed globally: npm -i -g package_name . But many times we don’t want the package to be installed globally, you can use npx instead. npx will follow the package, then cache it, and delete it after a period of time. This way the package will not be resident in the computer. (nor in package.json) Benefit: No need to occupy memory space, and no need to manually update, always the latest version. Global installation and computer replacement problems Global installation is generally used when you want to use the package from the command line. Global installation will not be recorded in the dependency, so it cannot be installed automatically when changing computers. Global installs are best replaced with npx. Script usage in npm scripts is an object in package.json. Equivalent to a shortcut, that is, to create a new name for the command line command. 123&quot;script&quot;: &#123; &quot;start&quot;: &quot;nodemon index.js&quot; //&quot;short name&quot;: &quot;long command&quot;&#125;, To run a custom command line command, the standard format is npm run custom command.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"npm","slug":"npm","permalink":"https://redre4per.github.io/tags/npm/"}]},{"title":"Loading mechanism of module","slug":"NodeJS/11 Loading mechanism of module","date":"2022-04-02T12:36:57.000Z","updated":"2022-11-10T11:36:00.215Z","comments":true,"path":"2022/04/02/NodeJS/11 Loading mechanism of module/","link":"","permalink":"https://redre4per.github.io/2022/04/02/NodeJS/11%20Loading%20mechanism%20of%20module/","excerpt":"","text":"Prioritize loading from cache Modules are cached after the first load. This means that multiple calls to require() will not cause the module’s code to be executed multiple times. Whether it is a built-in module, a user-defined module, or a third-party module, they will be loaded from the cache first, thereby improving the loading efficiency of the module. Loading mechanism of built-in modules Built-in modules are modules officially provided by Node.js, and built-in modules have the highest loading priority. For example, if a third-party module and a built-in module have duplicate module names, require(&#39;module name&#39;) always returns the built-in module, even if there is a third-party module package with the same name in the node_modules directory. Custom module loading mechanism When loading a custom module with require(), you must specify a path identifier starting with ./ or ../. When loading a custom module, if no path identifier is specified, node will load it as a built-in module or a third-party module, resulting in a failure to load. Also, when importing a custom module using require(), if the file extension is omitted, Node.js will in order to try to load the following files separately: Load by exact filename Completing .js extension loading Completing .json extension loading Completing .node extension loading Failed to load, the terminal reports an error Loading mechanism of third-party modules If the module identifier passed to require() is not a built-in module and does not start with ./ or ../, Node.js will start from the current module’s parent directory, trying to start from the &#x2F;node_modules file folder to load third-party modules. If the corresponding third-party module is not found, it will be moved to the next parent directory and loaded until the root directory of the file system. Directories as modules When passing a directory as a module identifier to require() for loading, there are three loading methods: Find a file called package.json in the loaded directory, and look for the main property, which serves as the entry for require() loading. If there is no package.json file in the directory, or the main entry does not exist or cannot be resolved, Node.js will try to load the index.js file in the directory. If the above two steps fail, Node.js will report an error: Error: Cannot find module &#39;xxx&#39; .","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"}]},{"title":"Share members in module","slug":"NodeJS/10 Share member in module","date":"2022-04-02T08:07:47.000Z","updated":"2022-11-10T11:36:26.699Z","comments":true,"path":"2022/04/02/NodeJS/10 Share member in module/","link":"","permalink":"https://redre4per.github.io/2022/04/02/NodeJS/10%20Share%20member%20in%20module/","excerpt":"","text":"module object In each .js custom module there is a module object, which stores information about the current module. After printing there is: 1234567891011121314151617Module &#123; id: &#x27;.&#x27;, path: &#x27;D:\\\\Front-end\\\\Nodejs&#x27;, exports: &#123;&#125;, #Important attributes, members can be shared externally through exports, the default value is an empty object. filename: &#x27;D:\\\\Front-end\\\\Nodejs\\\\prac1.js&#x27;, loaded: false, children: [ Module &#123; id: &#x27;D:\\\\Front-end\\\\Nodejs\\\\prac1a.js&#x27;, ... #here omitted &#125;], paths: [ &#x27;D:\\\\Front-end\\\\Nodejs\\\\node_modules&#x27;, &#x27;D:\\\\Front-end\\\\node_modules&#x27;, &#x27;D:\\\\node_modules&#x27; ]&#125; module.exports object In a custom module, you can use the module.exports object to share the members of the module for external use. The default value is &#123;&#125;. Outside When importing a custom module with the require() method, what you get is the object pointed to by module.exports. If the custom module does not export any objects, the result of printing require(&#39;./js1&#39;) from the outside world is &#123;&#125;, which is the default value of exports. Ways to share members: 1234module.exports.username = &#x27;Derek&#x27; //Mount properties to the module.exports objectmodule.exports.sayHello = function()&#123; //mounting method console.log(&#x27;Hello!&#x27;)&#125; Note that the shared members here exist as attributes of module.exports. If you define a variable&#x2F;function first, and then share the variable&#x2F;function name, it cannot be shared. Note: When using the require() method to import a module, the result of the import is always based on the object pointed to by module.exports. That is to say, if you define some properties of module.exports first, and then assign a new object to module.exports, the result of the export is a new object (because the new object is new address); whereas if you first assign a new object to module.exports and then add some properties, it will export the new object with the added properties. exports object Since module.exports is complicated to write, in order to simplify the code, Node.js provides the exports object. By default, exports and module.exports point to the same object. The default final shared result is still based on the object pointed to by module.exports. Mistakes in using module.exports and exports: When you use .attribute = to attach objects, the two are common; but when you use .exports = &#123;&#125; to directly assign objects, exports are created by yourself, which is directly related to module.exports The given objects are not the same. If you use .exports = &#123;&#125; to directly assign the object, and then want to use module.exports.attribute = to add attributes, then you should use module.exports = exports to point to exports The object is assigned to module.exports. To prevent confusion, it is recommended not to use both module.exports and exports in the same module.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"}]},{"title":"Modularization","slug":"NodeJS/09 Modularization","date":"2022-03-31T14:29:34.000Z","updated":"2022-11-10T11:36:17.812Z","comments":true,"path":"2022/04/01/NodeJS/09 Modularization/","link":"","permalink":"https://redre4per.github.io/2022/04/01/NodeJS/09%20Modularization/","excerpt":"","text":"Modular Concept Modularization refers to the process of dividing the system into several modules layer by layer from top to bottom when solving a complex problem. For the entire system, modules are units that can be combined, disassembled and replaced. In programming, modularization is complying with fixed rules, splitting a large file into multiple small modules that are independent and interdependent. The benefits of code modular splitting are: Improve code reusability Improve the maintainability of the code On-demand loading can be achieved modularity specification is the rules that need to be followed when the code is modularized and combined. For example, what syntax is used to reference the module, and what syntax is used in the module exposed members. Classification of modules in Node.js Node.js divides modules into three categories according to their different sources: Built-in modules (built-in modules are officially provided by Node.js, such as fs, path, http, etc.) Custom module (every .js file created by the user is a custom module. A relative path needs to be added when loading) Third-party modules (unofficial, need to be downloaded before use) Load Module The three modules above can be loaded using the require() method. Using the require() method will execute the code in the loaded module. 123const fs = require(&#x27;fs&#x27;) //direct loadingconst custom = require(&#x27;./custom.js&#x27;) //different from loading other modules, custom modules need to write relative pathsconst moment = require(&#x27;moment&#x27;) //Unlike built-in modules, third-party modules need to be downloaded in advance Note that the .js suffix can be omitted when loading custom modules using the require() method. Module scope in Node.js Similar to the function scope, members such as variables, methods defined in a custom module can only be accessed within the current module. This module-level access restriction is called a module scope. 123456//js1const username = &#x27;Derek&#x27;function sayHello()&#123; console.log(&#x27;Hello, I am &#x27; + username)&#125;sayHello() 12const js1 = require(&#x27;./js1&#x27;)console.log(js1) //In this case, Derek can be accessed normally, because functions and variables are in the same file. But note here that if sayHello() is written in the second file instead of js1, then an error sayHello() will be reported as undefined. The benefit of module scope is to prevent global variable pollution. The introduction of .js files in native JS does not have this mechanism, that is, variables in the imported files can be directly accessed (not accessible in strict mode). Modular Specifications in Node.js Node.js follows the CommonJS modularity specification. CommonJS specifies the characteristics of modules and how modules depend on each other: Inside each module, the module variable represents the current module. The module variable is an object whose exports property (ie module.exports) is the external interface. Loading a module is actually loading the module.exports attribute of the module. The require() method is used to load modules.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"}]},{"title":"Http module","slug":"NodeJS/08 Http module","date":"2022-03-31T10:36:05.000Z","updated":"2022-11-10T10:50:45.093Z","comments":true,"path":"2022/03/31/NodeJS/08 Http module/","link":"","permalink":"https://redre4per.github.io/2022/03/31/NodeJS/08%20Http%20module/","excerpt":"","text":"http module The http module is officially provided by Node.js and is used to create a web server module. Through the http.createServer() method, you can easily turn an ordinary computer into a Web server to provide Web resource services to the outside world. The difference between a server and an ordinary computer is that web server software such as IIS and Apache are installed on the server. In Node.js, we don’t need to use third-party web server software like IIS and Apache. Because you can use the http module to write server software and provide web services to the outside world. import http module 1const http = require(&#x27;http&#x27;) ​ Server related concepts IP address: It can be obtained by ping the domain name in the terminal. Enter 127.0.0.1 in the browser to access your computer as a server. Domain name and domain name server: The domain name (Domain Name) is a string corresponding to the IP address one-to-one, and this correspondence is stored in the domain name server (DNS, Domain name server). Port number: There may be multiple web services in one computer, each web service corresponds to a unique port number. The client’s network request will be handed over to the corresponding web service through the port number for processing. In practice, port 80 in url can be omitted. ​ Create web server step Import the http module 1const http = require(&#x27;http&#x27;) Create a web server instance You can quickly create a web server instance by calling the http.createServer() method. 1const server = http.createServer() Bind the request event to the server to monitor client requests. Bind the request event to the server using the .on() method of the server instance. Whenever a client sends a request to the server, the request event is fired and the event handler is called. 123server.on(&#x27;request&#x27;, (req,res)=&gt;&#123; console.log(&#x27;client visit our web server.&#x27;)&#125;) Start the server The current web server instance can be started by calling the .listen() method of the server instance. The first parameter is the port number, and parameter 2 (callback function) will be called after the startup is successful. 123server.listen(80, ()=&gt;&#123; console.log(&#x27;http server running at http://127.0.0.1&#x27;)&#125;) Stop the server with CTRL+C. Same as scaffolding. After the server modifies the code, the server must be restarted for the code to take effect. ​ req request object As long as the server receives the client’s request, it will call the server.on() bound request event handler for the server. If you want to access client-related data or properties in the event handler, you can use the req request object: req.url : The url address requested by the client (not the client address, but the target address you want to request. The address is not the complete address, but starts from the part after the port number.) req.method : the client’s method request type (GET, POST, etc.) res response object In the server’s request event handler, If you want to access server-related data or properties, you can use the res response object. For example, after the client accesses the server, if it wants to display the server content on the client’s web page, it needs to use the res response object. The res response object is the second parameter in the callback function. If you want to use res instead of req, you also need to complete req. The res.end() parameter is a string, which is sent to the client. Solve the problem of Chinese garbled characters When calling the res.end() method to send Chinese content to the client, there will be garbled characters. At this time, you need to manually set the encoding format. 1res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;) Both parameters are fixed notation. Respond to different content according to different urls step: Get the url address of the request Set the default corresponding content to 404 Not found Determine whether the user request is / or /index.html home page Determine whether the user request is the /about.html page (If Chinese is involved,) set the Content-Type response header to prevent Chinese garbled characters Response content to client using res.end() Code: 123456789101112131415161718const http = require(&#x27;http&#x27;)const server = http.createServer()server.on(&#x27;request&#x27;, function(req, res)&#123; const url = req.url let content = &#x27;&lt;h1&gt; 404 Not Found! &lt;/h1&gt;&#x27; if (url === &#x27;/&#x27; || url === &#x27;/index.html&#x27;)&#123; content = &#x27;&lt;h1&gt; main page &lt;h1&gt;&#x27; &#125;else if (url === &#x27;/about.html&#x27;)&#123; content = &#x27;&lt;h1&gt; about page &lt;h1&gt;&#x27; &#125; res.setHeader(&#x27;Content-type&#x27;, &#x27;text/html; charset=utf-8&#x27;) res.end(content)&#125;)server.listen(80, ()=&gt;&#123; console.log(&#x27;server running at http://127.0.0.1&#x27;)&#125;)","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"}]},{"title":"Split file example, Regex","slug":"NodeJS/07 Divide file example, Regex","date":"2022-03-30T22:52:54.000Z","updated":"2022-11-10T10:48:42.620Z","comments":true,"path":"2022/03/31/NodeJS/07 Divide file example, Regex/","link":"","permalink":"https://redre4per.github.io/2022/03/31/NodeJS/07%20Divide%20file%20example,%20Regex/","excerpt":"","text":"Case Requirements The file that needs to be split is an index.html file with HTML, style, and JS code mixed together. The requirement is to split this mixed file into three files, index.html, index.css, and index.js, and put these three files in the same clock folder. Case steps Import the required fs and path modules and create regular expressions. Regular expressions are used to split &lt;style&gt; and &lt;script&gt; code in mixed files. 12const regStyle = /&lt;style&gt;[\\s\\S]*&lt;\\/style&gt;/const regScript = /&lt;script&gt;[\\s\\S]*&lt;\\/script&gt;/ Note here that [\\s\\S] matches everything. \\s matches all whitespace, including newlines, \\S is not whitespace, excluding newlines. &lt;\\/style&gt; is to avoid the effect of escape characters. Use the fs module to read the html mixed file that needs to be processed. Customize the method of splitting css code 123456789function resolveCSS(htmlStr)&#123; const r1 = regStyle.exec(htmlStr) //Extract the style tag and the code in the tag in the mixed page string const newCSS = r1[0].replace(&#x27;&lt;style&gt;&#x27;, &#x27;&#x27;).replace(&#x27;&lt;/style&gt;&#x27;, &#x27;&#x27;) //Remove tags fs.writeFile(path.join(__dirname, &#x27;./clock/index.css&#x27;), newCSS, err=&gt;&#123; if(err) return console.log(err.message) console.log(&#x27;write in CSS style succeed!&#x27;) &#125;)&#125; The exec() method is used to retrieve a match of a regular expression in a string. The parameter is a string, and an array is returned, which stores the matching results. If no match is found, the return value is null. The 0th element of this array is the text that matches the regular expression. The 1st element is the text (if any) that matches the 1st subexpression of the RegExpObject, and the 2nd element is the text that matches the 2nd subexpression of the RegExpObject ( if any), and so on. RegExpObject has multiple subterms because it can be written in the form const regex1 = RegExp(&#39;foo*&#39;, &#39;g&#39;). Customize the method of splitting JS code (same as above) Customize the method of splitting html code 12345678910function resolveHTML(htmlStr)&#123; const newHTML = htmlStr .replace(regStyle, &#x27;&lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;/&gt;&#x27;) .replace(regScript, &#x27;&lt;link src=&quot;./index.js&quot;&gt;&lt;/script&gt;&#x27;) fs.writeFile(path.join(__dirname, &#x27;./clock/index.html&#x27;), newHTML, err=&gt;&#123; if(err) return console.log(err.message) console.log(&#x27;write in HTML page succeed!&#x27;) &#125;)&#125; ​ Precautions fs.writeFile() can only be used to create a file, not a path. That is to say, the case is to manually create the clock folder first. If it is not created, writing to the file will fail. Repeatedly calling fs.writeFile() to write to the same file, the newly written content will overwrite the previous old content.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"}]},{"title":"Path route module","slug":"NodeJS/06 Path route module","date":"2022-03-29T01:16:59.000Z","updated":"2022-11-10T10:47:22.665Z","comments":true,"path":"2022/03/29/NodeJS/06 Path route module/","link":"","permalink":"https://redre4per.github.io/2022/03/29/NodeJS/06%20Path%20route%20module/","excerpt":"","text":"path path module The path module is officially provided by Node.js and is used to process paths. It has methods for dealing with paths, such as path.join() to join paths, path.basename() to parse filenames, etc. import path module 1const path = require(&#x27;path&#x27;) Path splicing: path.join() The path.join() method can join multiple path fragments into a complete path string. 1path.join([...paths]) The parameter …paths is of type string and is a sequence of path fragments. The return value is the assembled path string. But in path fragments, be aware that ../ will cause the previous layer of the path to be canceled. Whereas ./ does not negate the previous path. If you need to offset the upper two layers of paths, you should use ../../ . 12const pathStr = path.join(&#x27;/a&#x27;, &#x27;/b/c&#x27;, &#x27;../&#x27;, &#x27;./d&#x27;, &#x27;e&#x27;) //result is \\a\\b\\d\\econst pathStr2 = path.join(__dirname, &#x27;./files/1.txt&#x27;) //The complete absolute path can be spliced out. In the future, operations involving path splicing should be handled with the path.join() method, and do not use + for string splicing. The reason is that if you thank a . such as ./ , the path will be wrong after splicing with a plus sign. But path.join() will take care of the extra . . 1fs.readFile(path.join(__dirname, &#x27;/files/1.txt&#x27;), &#x27;utf8&#x27;, function()&#123;&#125;) Get the filename in the path: path.basename() The path.basename() method can get the last part of the path, which is usually used to get the filename in the path. 1path.basename(path[, ext]) Parameter 1: required parameter, path string. Parameter 2: Optional parameter, indicating the file extension. If the second parameter is not passed in, the returned result is the file name with the extension, such as index.html. Add the second parameter passed in, such as &#39;.html&#39;, and the returned result is the file name without extension, such as index. 12path.basename(filePath1) //The result is index.htmlpath.basename(filePath1, &#x27;.html&#x27;) //The result is index Get the file extension in the path: path.extname() The path.extname() method can get the extension part of the path. The return value is an extension starting with .. 1path.extname(path)","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"}]},{"title":"Dynamic route combine","slug":"NodeJS/05 Dynamic route combine","date":"2022-03-28T06:57:01.000Z","updated":"2022-11-10T10:47:09.529Z","comments":true,"path":"2022/03/28/NodeJS/05 Dynamic route combine/","link":"","permalink":"https://redre4per.github.io/2022/03/28/NodeJS/05%20Dynamic%20route%20combine/","excerpt":"","text":"The reason for the problem with the path When using the fs module to operate files, if the provided operation path is relative path starting with ./ or ../, the problem of dynamic path splicing error is prone to occur. . The reason is that when the code is running, will dynamically splicing out the full path of the operated file based on the directory where the node command is executed. means the actual path is the current directory + relative path. If the directory when executing the node command is a folder of JS files, there will be no error. But if the directory has been moved to another location, it is not possible to find the JS file by completing the path after the node command (and before the JS file). That is to say, the completed paths are all invalid. 12cd../ #movement pathnode .\\code\\prac1.js #Complete the path after the node command, and the result will fail. Solve dynamic splicing problem with absolute path Using an absolute path as the first parameter in fs.readFile() will solve the problem. Absolute paths start from a drive letter. In VScode, you can right-click the file and copy the path to get the absolute path, such as D:\\Front-end\\Nodejs\\files\\article1.txt . But in JS \\ is an escape character. So you need to change \\ to \\\\ to get the real path, such as D:\\\\Front-end\\\\Nodejs\\\\files\\\\article1.txt . The disadvantage of this method is that it is not portable and not conducive to maintenance. __dirname solves the problem of dynamic splicing __dirname (double underscore prefix) indicates the directory where the current question is located. The value represented by __dirname does not change with the directory in which the node command is executed. Use __dirname to concatenate the relative path of the file (remove the .) to solve. 1fs.readFile(__dirname + &#x27;/files/article1.txt&#x27;, &#x27;utf8&#x27;, function()&#123;&#125;) Note here that the relative path . of the same level should be removed, because . itself is a shorthand for path. When using the fs module, you must use the __dirname writing method. For a better writing method, see the path module section.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"}]},{"title":"fs module, read","slug":"NodeJS/04 fs module, write","date":"2022-03-27T10:07:52.000Z","updated":"2022-11-10T10:15:31.068Z","comments":true,"path":"2022/03/27/NodeJS/04 fs module, write/","link":"","permalink":"https://redre4per.github.io/2022/03/27/NodeJS/04%20fs%20module,%20write/","excerpt":"","text":"**Write content to the specified file: fs.writeFile() ** 1fs.writeFile(path, data[, options], callback) Parameter 1: Required parameter, string, indicating the path of the file. Parameter 2: Required parameter, indicating the content to be written. Parameter 3: An optional parameter, indicating what encoding format to read the file in. The default is utf8. Parameter 4: Required parameter. After the file is read, the read result will be obtained through the callback function. Called whether the write succeeds or fails. For example: in utf8 encoding format, read the contents of the specified file, and print the values of err and dataStr: 1234const fs = require(&#x27;fs&#x27;)fs.writeFile(&#x27;./files/12.txt&#x27;, &#x27;added information&#x27;, &#x27;utf8&#x27;, function(err)&#123; console.log(err)&#125;) If the writing is successful, the err value is null (so do not write err.message directly here, because the callback function will be executed regardless of success or failure, and there is no message on success). If the read fails, the err value is an error object. Determine whether the file is written successfully According to whether err can be converted to true: if(err)&#123;return...&#125; If err can be turned to true, it means that the err object is not null and the writing fails. fs.writeFile() writing mechanism fs.writeFile() writes to replace the file contents, not append to the original contents. When no file is specified, a new file is created and then the contents are written. But if no directory is specified, an error will be reported. Append content to the specified file appendFile() 1fs.appendFile(filepath, data[, options], callback_function); Parameter 1: Required parameter, string, indicating the path of the file. Parameter 2: Required parameter, indicating the content to be written. Parameter 3: An optional parameter, indicating what encoding format to read the file in. The default is utf8. Parameter 4: Required parameter. After the file is read, the read result will be obtained through the callback function. Called whether the write succeeds or fails. Basically the same as fs.writeFile(). Appends do not automatically wrap or whitespace. Append content to the specified file synchronously appendFileSync() 1fs.appendFileSync(filepath, data[, options]); Parameter 1: Required parameter, string, indicating the path of the file. Parameter 2: Required parameter, indicating the content to be written. Parameter 3: An optional parameter, indicating what encoding format to read the file in. The default is utf8.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"}]},{"title":"fs module, read","slug":"NodeJS/03 fs module, read","date":"2022-03-26T22:31:08.000Z","updated":"2022-11-10T11:40:57.822Z","comments":true,"path":"2022/03/27/NodeJS/03 fs module, read/","link":"","permalink":"https://redre4per.github.io/2022/03/27/NodeJS/03%20fs%20module,%20read/","excerpt":"","text":"fs filesystem module The fs module is a module for manipulating files and has a series of methods and properties. Such as fs.readFile() fs.writeFile(). Import fs module Before using the fs module to manipulate files, you need to import it: 1const fs = require(&#x27;fs&#x27;) The require() method takes a string to write to a module. The fs module is available in the node installation package. **Read the contents of the specified file: fs.readFile() ** 1fs.readFile(path[, options], callback) Parameter 1: Required parameter, string, indicating the path of the file. Parameter 2: An optional parameter, indicating what encoding format to read the file in. The default is utf8. Parameter 3: Required parameter. After the file is read, the read result will be obtained through the callback function. For example: in utf8 encoding format, read the contents of the specified file, and print the values of err and dataStr: 123456const fs = require(&#x27;fs&#x27;)fs.readFile(&#x27;./files/11.txt&#x27;, &#x27;utf8&#x27;, function(err, dataStr)&#123; console.log(err) console.log(&#x27;-----&#x27;) console.log(dataStr)&#125;) If the read was successful, the err value is null. If the read fails, dataStr is undefined and err is an error object. Determine whether the file is read successfully It can be determined whether the err object is null. if(err === null)&#123;&#125; or if (err)&#123;return...&#125; . The two spellings are logically opposite. Note that when an error is thrown, err is the error object, and err.message is the error message based on the err code.","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"}]},{"title":"Installation","slug":"NodeJS/02 Installation","date":"2022-03-26T10:26:32.000Z","updated":"2022-11-10T10:11:36.369Z","comments":true,"path":"2022/03/26/NodeJS/02 Installation/","link":"","permalink":"https://redre4per.github.io/2022/03/26/NodeJS/02%20Installation/","excerpt":"","text":"Installation should select LTS version Node.js The official website has two installed versions, LTS and Current. LTS is the long-term stable version. For the pursuit of stability and enterprise-level projects, it is recommended to install the LTS version. Current is the early adopter version of new features. For users who want to try new features, it is recommended to install the Current version. However, there may be hidden bugs or security holes in the Current version, so it is not recommended to use Node.js in the Current version in enterprise-level projects. After downloading, select all to install by default. View the version number of installed Node.js Open a terminal and type node -v to see the version number. Execute Javascript code in Node.js environment Open Terminal Switch to the path of the js file to be executed. You can use cd to switch to the target path, or open the target folder and enter cmd, or open the target folder and then hold shift and right-click the blank area to open powershell. Enter node js filename. Note that the file name should be written with a .js suffix. (There is a shortcut key tab in the terminal to quickly complete the file path. For example, there is a js file in the directory: prac1.js. Just enter node p and press tab to complete the path and filename.) nodemon Usefulness: When writing a Node.js project, if the code is modified, it needs to be manually closed frequently and then restarted, which is very cumbersome. The nodemon tool can monitor changes in project files. When the code is modified, nodemon will automatically restart the project for us, which greatly facilitates development and testing. Install (globally): npm install -g nodemon Startup file: nodemon js file path ​","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"}]},{"title":"Introduction","slug":"NodeJS/01 Basic","date":"2022-03-26T07:04:08.000Z","updated":"2022-11-10T10:10:47.698Z","comments":true,"path":"2022/03/26/NodeJS/01 Basic/","link":"","permalink":"https://redre4per.github.io/2022/03/26/NodeJS/01%20Basic/","excerpt":"","text":"Javascript related Components of JS in the Browser JS core syntax: variable&#x2F;data type, loop&#x2F;branch&#x2F;judgment, function&#x2F;scope&#x2F;this, etc… WebAPI: DOM manipulation, BOM manipulation, Ajax manipulation, etc… How JS is executed in the browser Browsers have Javascript parsing engines. Different browsers use different engines, among which Chrome’s V8 parsing engine has the best performance. Why JS can manipulate DOM and BOM Each browser has built-in API functions such as DOM and BOM, so the JS in the browser can call them. The JavaScript runtime environment in the browser The runtime environment refers to the necessary environment for the code to function properly. The browser is the operating environment. Take Chrome as an example: To execute JS code normally, it requires V8 engine, built-in API (DOM, BOM, XMLhttp, JS built-in objects, Canvas, etc.). The JS code to be executed calls the built-in API, and then handed over to the V8 engine to run. Therefore, you cannot call built-in APIs such as DOM without the browser environment. Can JS be used for back-end development? Back-end development languages: Java, Python, PHP. The running environment of JS for back-end development is Node.js. ie Node.js is a backend runtime environment. Introduction to Node.js Node.js is a Javascript runtime environment based on the Chrome V8 engine. Node.js operating environment: V8 engine, built-in API (fs, path, http, JS built-in objects, querystring, etc.). So in-browser APIs like DOM, BOM, and Ajax cannot be called from Node.js. Node.js only provides basic functions and APIs, but there are many powerful tools and frameworks based on Node.js: Express framework, quickly build web applications Electron framework for building cross-platform desktop applications restify framework, quickly build API interface projects Read, write and operate databases, create practical command-line tools to assist front-end development, etc… Node.js Learning Pathway JS learning path in the browser: JS basic syntax, browser built-in API (DOM, BOM, etc..), third-party libraries (jQuery, etc.). Node.js learning path: JS basic syntax (same as browser), Node.js built-in API modules (fs, path, http, etc.), third-party API modules (express, mysql, etc.). nodemon Usefulness: When writing a Node.js project, if the code is modified, it needs to be manually closed frequently and then restarted, which is very cumbersome. The nodemon tool can monitor changes in project files. When the code is modified, nodemon will automatically restart the project for us, which greatly facilitates development and testing. Install (globally): npm install -g nodemon Startup file: nodemon js file path The reason for wanting to install a package globally is usually that we want to run the package directly from the command line, like nodemon and create-react-app. If .ps1 is not digitally signed. The script will not execute on the system. pops up, enter the command first. 1Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass ​","categories":[{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"}]},{"title":"Flex","slug":"CSS/A01 Flex","date":"2022-02-27T03:19:01.000Z","updated":"2022-11-12T05:28:42.875Z","comments":true,"path":"2022/02/27/CSS/A01 Flex/","link":"","permalink":"https://redre4per.github.io/2022/02/27/CSS/A01%20Flex/","excerpt":"","text":"flex layout features Traditional layout: good compatibility, cumbersome layout, limited, cannot be well laid out on the mobile side. flex is a one-dimensional layout. Flex flexible layout: easy to operate, simple layout, easy to use on mobile, poor browser support on PC, not supported&#x2F;partially supported below IE11. Recommendation: Use traditional layout for PC side page layout, and flex layout for mobile terminal&#x2F;PC side without considering compatibility issues. Flex layout principle flex is the abbreviation of flexible box, flexible layout, used to provide maximum flexibility for the box model, any container can specify flex layout. An element that uses flex layout is called flex container; all its child elements automatically become container members, called flex item. After the parent element sets the flex layout, the float, clear and vertical-align properties of the child element will be invalid. (floats are out. And flex can center elements vertically, so vertical-align doesn’t work). Summary: It is to control the position and arrangement of the child boxes by adding the flex property display:flex; to the parent box. Note the difference with display:block. display : Property Value Description Tailwind flex flex layout flex Common attributes of flex layout parents flex-direction: Set the direction of the main axis (not important) Main and Cross axes: rows and columns, x-axis and y-axis. The default main axis is horizontal to the right and the cross axis is vertical downward. The main axis and the side axis will change, depending on who is set as the main axis in flex-direction, and the rest is the side axis. And our child elements are arranged according to the main axis. For example: display:flex; flex-direction: row; Property Value Description Tailwind row default, left to right row-reverse right to left column top to bottom flex-col column-reverse bottom to top justify-content: Set the arrangement of sub-elements on the main axis The justify-content attribute defines the alignment of the flex item on the main axis, and the main axis must be determined before use. Property Value Description Tailwind flex-start default, start at head, left to right if main axis is x-axis flex-end align from the end center align at the center of the main axis (horizontally if the main axis is the x-axis) space-around Divide the remaining space equally (without borders) space-between First paste the two sides, and then divide the remaining space equally (important) justify-between flex-wrap: Set whether the child element wraps By default, items are arranged on a single line (axis). The flex-wrap attribute defines that the default is not to wrap in the flex layout. If the cumulative width of the child elements exceeds the container, the width of the child elements will be automatically reduced and placed in the parent element. If you don’t want to shrink the child elements automatically, but want the extra child elements to wrap automatically, you can use flex-wrap: wrap property. Property Value Description Tailwind nowrap default, no newline wrap line break wrap-reverse Lines are wrapped and children are reversed diagonally. align-items: Set the arrangement of sub-elements on the side axis (single line) If you just want to lay out elements on a single axis, the previous flex-direction is enough. But if you want elements to be laid out on the main axis + side axis at the same time (such as centering the main axis + centering the side axis), you need align-items. Property Value Description Tailwind flex-start top to bottom flex-end bottom to top center squeeze together and center (vertically center) items-center stretch default? Stretch to the height of the parent element (When using it, do not give height to the child element) baseline the baseline to align the content with align-content: Set the arrangement of sub-elements on the side axis (multiple lines) Used for requirements that cannot be implemented in the layout align-items. align-items can only be aligned on the top&#x2F;bottom&#x2F;center, without space-around in justify-content, etc. align-content sets the arrangement of sub-items on the side axis, and can only be used when the sub-item appears in a new line (multiple lines), and it has no effect under a single line. Property Value Description Tailwind flex-start start alignment at the head of the cross axis flex-end start alignment at the end of the cross axis center display in the middle of the side axis space-around Children divide the remaining space equally on the cross axis space-between The child items are distributed at both ends on the side axis, and then divide the remaining space equally stretch Default value, set the height of the child element to equal the height of the parent element The difference between align-content and align-items align-items is suitable for single-line cases, only top alignment, bottom alignment, centering and stretching. align-content is suitable for newlines (multiple lines), and a single line is invalid. You can set attribute values such as top alignment, bottom alignment, centering, stretching, and evenly distributing the remaining space. flex-flow: Composite attribute, equivalent to setting flex-direction and flex-wrap at the same time Shorthand for setting the main axis direction flex-direction and whether to wrap flex-wrap. 1flex-flow: row wrap; gap: margin between child elements. The difference with margin is that all items can inherit gap directly, instead of writing margin for each item. Property Value Description Tailwind gap spacing between child elements gap-[]&#x2F;-8 Common properties of flex layout children Number of flex sub-items The flex attribute defines the allocation of remaining space to sub-items, and uses flex to indicate how many number of copies. For example, to make a navigation bar with search, the left and right small buttons are fixed, and the middle search bar is adaptive. E.g: 1234567891011121314section &#123; /*parent element*/ display:flex&#125;section div:nth-child(1) &#123; /*fixed size, no need to write flex*/ width:100px; height: 150px;&#125;section div:nth-child(3) &#123; /*fixed size, no need to write flex*/ width:100px; height: 150px;&#125;section div:nth-child(2) &#123; /*1 point is all free space, adaptive*/ flex:1&#125; The three child elements in the parent element bisect the width, such as 123456p &#123; display:flex; width:60%; height:150px;&#125;p span &#123;flex:1&#125; /* Don&#x27;t give the width and height, directly divide it into 3 equal parts, one for each. No width is given, the sum of their widths is the width of the parent element */ do not evenly distribute element widths, such as 123456p &#123; display:flex; width:60%; height:150px;&#125;p span:nth-child(2) &#123;flex:2&#125; /*The child element number 2 occupies two shares, here is 50%, and the other two boxes take one share, each 25%*/ align-self controls the arrangement of sub-items on the side axis The align-self property allows a single item to have a different alignment than other items, overriding the align-items property. The default value is auto, which indicates that the align-items property of the parent element is inherited. If there is no parent element, it is equivalent to stretch. 123section div:nth-child(1) &#123; align-self:flex-end; /*A single child element has a different layout from other child elements*/&#125; The order attribute defines the order of the child items (before and after) The smaller the value, the higher the ranking, the default is 0. Note, not the same as z-index. 123section div:nth-child(2) &#123; order:-1; /*sort by number size*/&#125; flex-basis, flex-grow, flex-shrink It means that the child element stretches proportionally when the width of the parent element is sufficient; or when the width of the parent element is insufficient, Compression ratio. flex-grow: sub-element stretching ratio allocation, the default value is 0, and cannot be negative. If the value is 1, it is fixed and cannot be enlarged. flex-shrink: Sub-element compression ratio allocation, the default value is 1, which cannot be negative. If the value is 0, it is fixed and cannot be reduced any more. flex-basis: The basic size of the child element, the default value is auto. It is not a fixed execution value, but a recommended value, the benchmark value; the real value is determined by grow and shrink. If flex-basis: 0px , the fixed size cannot be scaled. 12345678910.red&#123; flex-grow: 1; flex-shrink: 1; flex-basis: 100px;&#125;.blue&#123; flex-grow: 2; flex-shrink: 2; flex-basis: 100px;&#125; Detailed Tutorials and Exercises Detailed tutorial: https://css-tricks.com/snippets/css/a-guide-to-flexbox/ Exercise 1: https://flexboxfroggy.com/#zh-cn Exercise 2: http://www.flexboxdefense.com/ Exercise 3: http://tom.infinityfreeapp.com/html/shapes.html","categories":[{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"https://redre4per.github.io/categories/HTML-CSS/"},{"name":"CSS","slug":"HTML-CSS/CSS","permalink":"https://redre4per.github.io/categories/HTML-CSS/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://redre4per.github.io/tags/CSS/"}]},{"title":"CSS skills 2","slug":"CSS/02 CSS skills 2","date":"2022-02-19T21:14:32.000Z","updated":"2022-11-12T05:05:11.424Z","comments":true,"path":"2022/02/20/CSS/02 CSS skills 2/","link":"","permalink":"https://redre4per.github.io/2022/02/20/CSS/02%20CSS%20skills%202/","excerpt":"","text":"Variable Variables are defined with --, referenced with var(--varName), and can be accessed by JS. 123:root &#123; //declare in the top root of css--variables and assign values --logo-size:60px;&#125; 1width:var(--logo-size) / 2; //reference variable .active processing in css Use .active in html to manipulate elements, such as adding a .active class to an element (the element can have multiple classes). At the same time, there may be multiple .active to operate on multiple elements. In order to avoid multiple names, you can use .toggle.active &#123;&#125; in css (no spaces in the two selectors, parallel relationship) to select a specific .active. Dynamic effects of interactive elements a button element, the button is stretched when the mouse is moved in: 1a &#123;transition:0.2s;&#125; //The extension has an animation process 1a:hover &#123;letter-spacing: 6px;&#125; // lengthen when the mouse moves in a element button, the button jumps when the mouse moves in: 1.social li a &#123;transition:0.5s;&#125; 123.social li a:hover&#123; transform:translateY(-10px); //The default direction of the Y axis is downward, and a negative value is required for upward jump.&#125; The upper page shrinks to reveal the hidden lower page: 1.showcase &#123;transition:0.5s ease-in-out;&#125; //ease-in-out is soft scaling. ​ Remove the default style of li In ul or ol, set list-style: none;. ​ Uncover the hidden bottom page Hidden pages generally only take up part of the viewport, so they need width. Note that this width will be used many times later, so it is best to set it to the variable --menu: 300px. 1234.showcase.active &#123; //The original upper page is opened from the right and moved to the left. right:var(--menu-width); width: calc(100%-var(--menu-width)); //Calculation when the unit is not uniform. If not changed, it will cause the page to exceed the left border.&#125; The text in the hidden interface still needs to use absolute positioning, and in order to match the div width of the text with the hidden interface, you should use 1.menu &#123;width: var(--menu-width);&#125; JS for Toggle Button Import the JS file: at the bottom of the body, &lt;script src=&#39;&#39;/&gt;. Both buttons and elements that need to change (such as the parent page) require DOM manipulation. Toggle the active class: menuToggle.classList.toggle(&#39;active&#39;). pseudo-element Used before&#x2F;after an element requires content and color attributes. 1234.home&gt;.text&gt;h3::after &#123; content: &quot;abc&quot;; color: #c66;&#125; Decorative pseudo-element: 123456.ribbon::after &#123; content: &quot;Look at this orange box.&quot;; background-color: #FFBA10; border-color: black; border-style: dotted;&#125; background-color and background background can not be set to color, but set to gradient color. Shadow effect Use box-shadow. Its first value is the deflection axis of x, the second value is the deflection axis of y, the third value is the degree of blurring (the higher the shadow, the more blurred, 0-100), the fourth value is the color, which can be Use rgba. E.g: 1box-shadow: 25px 25px 75px rgba(0,0,0,0.25); Note that this effect is a one-sided shadow on the x-axis and y-axis, and only two sides can be considered at the same time. The four sides should use two layers of box-shadow. If you think one layer of shadow is too thin, you can also add multiple layers of shadow. Instead of writing another box-shadow, change the comma after rgba to continue writing the next layer of shadow. 1box-shadow: 25px 25px 1px rgba(0,0,0,0.25), 10px 10px 70px rgba(0,0,0,0.25); Built-in shadow properties: inset. Its first and second values can be negative (positive for upper left, negative for lower right). It casts a shadow within the element’s bounds. The purpose of the built-in shadow is to cooperate with the external shadow to make bump effect. 1box-shadow:inset -5px -5px 15px rgba(0,0,0,1); 1234box-shadow: 25px 25px 1px rgba(0,0,0,0.25),10px 10px 70px rgba(0,0,0,0.25),inset -5px -5px 15px rgba(0,0,0,1),inset 5px 5px 15px rgba(0,0,0,0.5); //Inner and outer shadows to generate a three-dimensional effect.","categories":[{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"https://redre4per.github.io/categories/HTML-CSS/"},{"name":"CSS","slug":"HTML-CSS/CSS","permalink":"https://redre4per.github.io/categories/HTML-CSS/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://redre4per.github.io/tags/CSS/"}]},{"title":"CSS skills 1","slug":"CSS/01 CSS skills 1","date":"2022-02-17T16:06:13.000Z","updated":"2022-11-12T04:55:06.671Z","comments":true,"path":"2022/02/18/CSS/01 CSS skills 1/","link":"","permalink":"https://redre4per.github.io/2022/02/18/CSS/01%20CSS%20skills%201/","excerpt":"","text":"Web site folder directory design index.html src &gt; style.css src &gt; script.js src &gt; assets &gt; video &gt;videos &amp;&amp; src &gt; assets &gt; images &gt; svgs Resource Site Videos and pictures: https://www.pexels.com/ svg icon: https://remixicon.com/ https://fontawesome.com/ https://svgsilh.com/ icon download and use Web Design Ideas A layered approach can be adopted: the hidden menu is placed on the bottom layer, the background image&#x2F;video is placed on the upper layer, the filter is placed on the upper layer, and finally the real HTML body is placed on the top layer. Note here that layering only needs to be implemented with z-index, there is no need to have html layers, and there is no need to put pictures&#x2F;videos in css and use bg to do it. Uncover the hidden layer: The upper element of z-index (the entire upper page) can be positioned absolutely, and the edge to be opened after setting, such as right:0;. In this way, you can set right:Npx when you want to open it later. Fixed-height web pages: For single-page web pages that do not scroll, the height should be set to min-height: 100vh. vh is the viewing height. Code abbreviation and naming Create a label with a class name: section.showcase will create &lt;section class=&#39;showcase&#39;&gt;&lt;/section&gt;. The first line at the top of the website can be called header or nav. Each slightly larger element inside can be given a class name. Multi-line label generation: (li&gt;a&gt;img)*3. This abbreviated structure can be used to jump to the input of the structure with the tab key. Random paragraphs: Lorem * n Multiply as many paragraphs as you want. video Video settings: mute mute; autoplay autoplay; loop playback loop. Video as background: 12345678position: absolute; //It must be absolute, because the background occupies the entire webpage.top:0;left:0; //fix absolute positionwidth: 100%;height:100%; //Video resolution may be different from web page, that is, there are upper and lower black bordersobject-fit:cover; //Solutions with different resolutions. You can remove black borders and change the background video according to the width and height of the webpage.opacity:0.8; //Make the video transparent, and the upper text can be displayed.z-index:0; //The video is at the bottom. It is not necessary to write this setting. Filter: You can directly give the video a div of the same level as html, class&#x3D;’overlay’. Then overlay on top of the video. 1234567position: absolute;top:0;left:0;width: 100%;height:100%; //The previous setting is consistent with the videobackground-color:var(--overlay-color) //Theme color, it is best to set it in a variable form. But the default is opaque.mix-blend-mode:overlay; //The theme color, video, and background color of the text layer will be superimposed. 1background-color: rgba(255,255,255,0.5) //Another way of processing filter color. It is not suitable for dealing with the theme color, and the color will be blurred. button Generally, buttons are not made with button, but with a tag. The a tag is also transparent (that is, blocks can be placed in the inline), so you can set a div inside the a tag. If there is no specific link button, href&#x3D;’#’, click to refresh the current page. Using the a tag as a button needs to ensure that the text cannot be reduced too small, nor can it wrap. So set it to display:inline-block;. The characteristic of the inline part here is that multiple a will flow to the next line when the window is reduced; and the characteristic of the block part is that the text inside a will not become smaller or wrap due to extrusion. That is, it looks like inline on the outside, but it is a block inside. Note that if the img icon is set inside the a tag, it also needs to be set as an inline-block element. The underline also needs to be removed when the a tag is used as a button: text-decoration: none;. Space between each letter in the text: letter-spacing: 2px;. The button should appear larger: padding: 10px 30px;. Changes on mouseover: cursor: pointer. text group Generally, a website will have text groups with different font styles stacked together. In practice, you can use a div.text to wrap these text groups, and then subdivide them with tags such as h2, h3, and p. The advantage of this is that div.text can be used as a whole element and laid out together with the header&#x2F;nav and footer of the website. Case problem: It should be changed in css with text-transform: uppercase; instead of uppercase directly in html, because it may be fixed in the future. The text in the p paragraph may need to be limited, that is, it can be reduced but not too long. max-width:Npx; svg with switchable icons svg image When using it, download it first, and then use the img tag directly in html. Switchable icons such as menu and close are usually not added in html. That is, the fixed icon is written into html, and the variable icon is written into css. When writing, use background: url(). The switching function can use .active, just write the link and configuration item of another icon. At this time, because the icon becomes the background, it will repeat and not be centered. So use: 123background-repeat: no-repeat; //no repeatbackground-size: 30px; //svg The size of the vector image can be changed at will, and the size of the downloaded vector image varies greatly.background-position: center; //center The svg icon has a special black and white discoloration, use filter:invert(1); to invert the color of black and white. Temporarily hide an element display: none in css. Or comment out the html code directly. Change css font In the google fonts site, search for Poppins in the upper right corner. You can select all fonts and load them all in Poppins. After that, directly import Poppins’ link: @import .... This just imports css, but it doesn’t work yet. You should * &#123;box-sizing: border-box;&#125; before changing the font. This is because if width:100px, border:3px, the overall length is 106px. After setting box-sizing, the overall length is still 100px, that is, the border will not exceed the width. 12345* &#123;box-sizing: border-box; margin: 0; padding: 0; font-family:&#x27;Poppins&#x27;, sans-serif; //Find fonts from left to right. There may be no network in front of it, so it can&#x27;t be used.&#125; The reason why it is not written in the body here is that the elements in the body are inherited, while * directly selects all elements. If the margin of a certain layer under the body is changed, then its lower layer will inherit the new margin, resulting in uncertainty. Change the font in a sub-element: font-size attributes generally use rem units, such as 5rem; but line-height should not use rem, but em, such as 1em. Because rem runs according to the default font size of the browser, and after changing font-size in a sub-element (such as responsive), the em below it will go according to the size of font-size. If it is set to rem, it will cause a height limit error. 123font-size: 5rem;font-weight: 800;line-height: 1em; One way to do this is to set :root&#123;font-size:62.5%;&#125;. In this way, the default 16px is changed to 10px, 1rem&#x3D;10px, which is convenient for calculation. For example, the width of 80px can be directly written as 8rem. At the same time, you can directly change the font-size when you need to change the size. This approach is standard in large projects.","categories":[{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"https://redre4per.github.io/categories/HTML-CSS/"},{"name":"CSS","slug":"HTML-CSS/CSS","permalink":"https://redre4per.github.io/categories/HTML-CSS/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://redre4per.github.io/tags/CSS/"}]},{"title":"Axios instance, Interceptor, Cancel request","slug":"Axios/5 Axios instance, interceptor, cancel","date":"2022-01-28T08:04:52.000Z","updated":"2022-11-12T00:31:12.061Z","comments":true,"path":"2022/01/28/Axios/5 Axios instance, interceptor, cancel/","link":"","permalink":"https://redre4per.github.io/2022/01/28/Axios/5%20Axios%20instance,%20interceptor,%20cancel/","excerpt":"","text":"Axios creates an instance object to send a request Usefulness: The interface data for many projects does not come from a single server. When using the Axios object to send requests to different servers, if the default configuration (protocol, domain name, port, etc.) is made, it can only meet the needs of the first server, and the second server cannot set the default configuration. And Axios can solve this problem by creating instance objects. Different servers use different Axios instance objects, and then set different default configurations. Instance objects created by Axios function almost exactly like Axios objects. 12345678910const axios1 = axios.create(&#123; //Axios creates an instance object baseURL:&#x27;http://localhost:3000&#x27;, timeout: 2000&#125;);axios1(&#123; url:&#x27;/posts&#x27;,&#125;).then(response =&gt; &#123; console.log(response);&#125;) Instance objects created by Axios can also send requests with encapsulated methods, such as get( ), post( ), request( ), etc. 123Axios1.get(&#x27;/posts&#x27;).then(response =&gt; &#123; console.log(response);&#125;) ​ Axios Interceptor Interceptors are some functions, which are divided into request interceptor interceptors.request and response interceptor interceptors.response. Request Interceptor can use some functions to process and detect the parameters and content of the request, and then send or cancel, similar to a checkpoint. Response Interceptor can preprocess the result before processing it. For example, remind&#x2F;record the failure result, format and process the data result, if there is no problem after processing, it will be handed over to its own callback function for processing, and if there is a problem, the interceptor will handle it by itself. It is also a similar level. Request Interceptor and Response Interceptor .use( ) has two callbacks for success and failure, the principle is implemented by then( ). 1234567axios.interceptors.request.use(function(config)&#123; //Set request interceptor console.log(&#x27;request interceptor, success&#x27;); return config;&#125;, function(error)&#123; console.log(&#x27;request interceptor, failed&#x27;); return Promise. reject(error);&#125;) 1234567axios.interceptors.response.use(function(response)&#123; //Set response interceptor console.log(&#x27;response interceptor, success&#x27;); return response;&#125;, function(error)&#123; console.log(&#x27;Response interceptor, failed&#x27;); return Promise. reject(error);&#125;) 12345678axios(&#123; //send request method:&#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27;&#125;).then(response =&gt; &#123; console.log(&#x27;custom success result&#x27;);&#125;).catch(reason =&gt; &#123; console.log(&#x27;Custom failure callback&#x27;);&#125;) The result of this code running is ‘request interceptor success’, ‘response interceptor success’, ‘custom success result’. The sequence is to take the successful callback of the request interceptor first, then the successful callback of the response interceptor, and then the successful callback of axios. If the request interceptor returns a failure, that is, return Promise.reject() or throw &#39;there is a problem with the parameter&#39; (Promise syntax), then you cannot go through the successful callback of the response interceptor, and you will go directly to the response The callback of the interceptor failure, and the custom success callback cannot be executed, only the failure callback (such as catch). Execution order of multiple request&#x2F;response interceptors If the same axios object has multiple request interceptors and response interceptors, such as: 12345678910111213141516171819202122axios.interceptors.request.use(function(config)&#123; console.log(&#x27;request interceptor, success -1&#x27;); return config;&#125;);axios.interceptors.request.use(function(config)&#123; console.log(&#x27;request interceptor, success -2&#x27;); return config;&#125;);axios.interceptors.response.use(function(response)&#123; console.log(&#x27;Response interceptor, success -1&#x27;); return response;&#125;);axios.interceptors.response.use(function(response)&#123; console.log(&#x27;Response interceptor, success -2&#x27;); return response;&#125;);axios(&#123; //send request method:&#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27;&#125;).then(response =&gt; &#123; console.log(&#x27;custom success result&#x27;);&#125;) The result is ‘request number 2’, ‘request number 1’, ‘response number 1’, ‘response number 2’, ‘custom success result’. That is, the request interceptor is executed first, and the response interceptor is executed first. config parameter and response parameter config is the configuration object, use config.params = &#123;a:100&#125;; config.timeout = 2000; to configure. 12345axios.interceptors.request.use(function(config)&#123; config.params = &#123;a:100&#125;; config.timeout = 2000; return config;&#125;); response is the response result object, which is actually the response result created by Axios by default (axios.3.6). If you don’t want to process the whole object, but only a part of it, you can return response.data, so that only a specific part is processed. In the following code, the returned result only has the data attribute in the response object, and nothing else. 123456789axios.interceptors.response.use(function(response)&#123; return response.data; //Preprocess the returned result in advance&#125;);axios(&#123; method:&#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27;&#125;).then(response =&gt; &#123; console.log(response); //The response here only returns the response.data part of the response result object.&#125;) ​ Axios cancel request cancelToken: new CancelToken(function (cancel) &#123;&#125;), is an Axios parameter. It takes a function as an argument, and the function has a formal parameter (c) . Setting up a cancellation request requires three steps: Add configuration object properties. cancelToken: new CancelToken(function (cancel) &#123;&#125;) usually takes c as a parameter. Declare a global variable let cancel = null; to save the function returned by c later. Assign c to the global variable cancel. cancel = c; Bind the cancel( ) function in another event to trigger the axios cancellation request of the first event. 123456789101112131415let cancel = null; //Part 2: Declare global variablesbtns[0].onclick = function()&#123; axios(&#123; method:&#x27;GET&#x27;, url:&#x27;http://localhost:3000/posts&#x27;, cancelToken: new axios.CancelToken(function(c)&#123; //Step 1: Add properties of the configuration object cancel = c; //Step 3: Assign c to the global variable cancel. &#125;); &#125;);&#125;btns[1].onclick = function()&#123; cancel(); //Bind the cancel() function in the second event.&#125; In order to verify the effect, you can add a delay to the server response. In json-server, the way to add delay is to add -d code when starting the server: json-server --watch db.json -d 2000 The cancel request is often used for anti-shake, that is, when sending a request, first determine whether the previous request is still continuing, and if it continues, cancel it. 123456789101112131415let cancel = null; //Part 2: Declare global variablesbtns[0].onclick = function()&#123; if(cancel !== null)&#123;cancel();&#125;; //Judge the value of cancel, if it is not null, it means that the last request is not over and needs to be canceled axios(&#123; method:&#x27;GET&#x27;, url:&#x27;http://localhost:3000/posts&#x27;, cancelToken: new axios.CancelToken(function(c)&#123; cancel = c; &#125;); &#125;).then(response =&gt; &#123; console. log(response); cancel = null; //Initialize the cancel value &#125;)&#125;","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"Axios","slug":"Front-end/Axios","permalink":"https://redre4per.github.io/categories/Front-end/Axios/"}],"tags":[{"name":"Axios","slug":"Axios","permalink":"https://redre4per.github.io/tags/Axios/"}]},{"title":"Axios parameters","slug":"Axios/3 Axios parameters","date":"2022-01-27T02:29:06.000Z","updated":"2022-11-12T00:22:31.547Z","comments":true,"path":"2022/01/27/Axios/3 Axios parameters/","link":"","permalink":"https://redre4per.github.io/2022/01/27/Axios/3%20Axios%20parameters/","excerpt":"","text":"Request Configuration These configuration objects can be used not only in axios( ), but also in .request( ), .post( ) and other request methods. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&#123; // server url address url: &#x27;/user&#x27;, // request method method: &#x27;get&#x27;, // default is get // Set the basic structure of url, such as http, localhost, 3000, etc. After setting the baseURL, you only need to write the follow-up path. baseURL: &#x27;https://some-domain.com/api/&#x27;, // Process the request data and send it to the server after processing. That is, preprocessing request parameters. transformRequest: [function (data, headers) &#123; // Do whatever you want to transform the data return data; &#125;], // That is to preprocess the response result. transformResponse: [function (data) &#123; // Do whatever you want to transform the data return data; &#125;], // Configure request header information. When performing identity verification on some projects, a special identifier is required to be added to the request header information to determine whether the request meets the conditions. headers: &#123;&#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;&#125;, // Set the url parameter. What is configured is an object, and various parameters are written. More readable than writing in url. params: &#123; ID: 12345 &#125;, // Parameter serialization configuration item, not commonly used. Serialize request parameters and convert them to strings. (The server side requires this configuration when the data format is different) paramsSerializer: function (params) &#123; return Qs. stringify(params, &#123;arrayFormat: &#x27;brackets&#x27;&#125;) &#125;, // Request body settings (object form). Axios will convert it into a json format string and pass it on. Select the format according to the project requirements. data: &#123; firstName: &#x27;Fred&#x27; &#125;, // Request body settings (string format). axios will pass it straight through. Select the format according to the project requirements. data: &#x27;Country=Brasil&amp;City=Belo Horizonte&#x27;, // overtime time. If this time elapses after sending the request, the request will be cancelled. timeout: 1000, // default is `0` (no timeout) // Settings for carrying cookies when cross-domain requests are made. withCredentials: false, // default // Request adapter settings. One is Ajax in the browser, and the other is sending http in Node.js. adapter: function (config) &#123; /* ... */ &#125;, // Basic validation of the request, not commonly used auth: &#123; username: &#x27;janedoe&#x27;, password: &#x27;s00pers3cret&#x27; &#125;, // Response result format setting responseType: &#x27;json&#x27;, // default // Response result encoding, charset setting. responseEncoding: &#x27;utf8&#x27;, // default // Cross-origin request identifier. Set the name of the cookie. xsrfCookieName: &#x27;XSRF-TOKEN&#x27;, // default // Cross-origin request identifier. Set the request header information. xsrfHeaderName: &#x27;X-XSRF-TOKEN&#x27;, // default /* The above two are a security setting. It is a protective effect to ensure that the request comes from your own client instead of an unknown page. because the server is returning the result A unique identifier will be returned, and the identifier must be sent the next time the request is sent, and the server will respond after verification. But some web pages will add some links Then, send a request to the server. If these two unique identifiers are not added, the request for the web page link may affect the results returned by the server. joined these two After the logo, only the client sends the logo, and other web pages have no logo, so cross-site attacks can be avoided. */ // callback when uploading onUploadProgress: function (progressEvent) &#123; &#125;, // Callback when downloading onDownloadProgress: function (progressEvent) &#123; &#125;, // http response body maximum size maxContentLength: 2000, // The maximum content of the request body maxBodyLength: 2000, // Set the success condition of the response result. No need to change, unless you set the success/failure rules yourself. validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // default &#125;, // Maximum number of jumps. The server request sent may have a jump. Generally, it is only used in Node.js, and Ajax is not used. maxRedirects: 5, // default // Set the socket file location, the function is to send a request to the docker.sock process, that is, data forwarding. There is a priority relationship with the proxy. if set // socket, proxy is also set, socket is used first. socketPath: null, // default // Client information setting, setting whether to keep the connection, not commonly used. httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // Set the proxy. It is often used in node.js, such as switching the client address in a crawler request. proxy: &#123; protocol: &#x27;https&#x27;, host: &#x27;127.0.0.1&#x27;, port: 9000, auth: &#123; username: &#x27;mikeymike&#x27;, password: &#x27;rapunz3l&#x27; &#125; &#125;, // ajax request unset cancelToken: new CancelToken(function (cancel) &#123; &#125;), // an alternative way to cancel Axios requests using AbortController signal: new AbortController(). signal, // Decompress the response result, only for node.js. decompress: true // default // `insecureHTTPParser` boolean. // Indicates where to use an insecure HTTP parser that accepts invalid HTTP headers. // This may allow interoperability with non-conformant HTTP implementations. // Using the insecure parser should be avoided. // see options https://nodejs.org/dist/latest-v12.x/docs/api/http.html#http_http_request_url_options_callback // see also https://nodejs.org/en/blog/vulnerability/february-2020-security-releases/#strict-http-header-parsing-none insecureHTTPParser: undefined // default // transitional options for backward compatibility that may be removed in the newer versions transitional: &#123; // silent JSON parsing mode // `true` - ignore JSON parsing errors and set response.data to null if parsing failed (old behavior) // `false` - throw SyntaxError if JSON parsing failed (Note: responseType must be set to &#x27;json&#x27;) silentJSONParsing: true, // default value for the current Axios version // try to parse the response string as JSON even if `responseType` is not &#x27;json&#x27; forcedJSONParsing: true, // throw ETIMEDOUT error instead of generic ECONNABORTED on request timeouts clarifyTimeoutError: false, &#125;&#125; Axios default configuration Practical trick, you can set the repeated configuration in the default configuration to simplify the code. axios.default.[config] Axios parameters (that is, configuration objects) can be configured by default. When the default configuration is not done, the code is as follows, and the method and url must be set every time an axios request is sent. 12345678btns[0].onclick = function()&#123; axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts&#x27; &#125;).then(response =&gt; &#123; console. log(response); &#125;);&#125; After doing the default configuration, 12345678910axios.default.method = &#x27;GET&#x27;;axios.default.baseURL = &#x27;http://localhost:3000&#x27;;btns[0].onclick = function()&#123; axios(&#123; url: &#x27;posts&#x27; &#125;).then(response =&gt; &#123; console. log(response); &#125;);&#125;","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"Axios","slug":"Front-end/Axios","permalink":"https://redre4per.github.io/categories/Front-end/Axios/"}],"tags":[{"name":"Axios","slug":"Axios","permalink":"https://redre4per.github.io/tags/Axios/"}]},{"title":"Axios basics","slug":"Axios/2 Axios basics","date":"2022-01-26T08:16:29.000Z","updated":"2022-11-12T00:15:15.705Z","comments":true,"path":"2022/01/26/Axios/2 Axios basics/","link":"","permalink":"https://redre4per.github.io/2022/01/26/Axios/2%20Axios%20basics/","excerpt":"","text":"Axios Introduction Both React and Vue use Axios to send data requests. Axios can run in the browser and send Ajax requests to the server. Axios can also run in node.js, making http requests to the server side. Axios Features For browser&#x2F;node.js, send Ajax&#x2F;http request to the server. Use the Promise API. Request&#x2F;response interceptor. Do preparation work before the request, and do preprocessing when the result is returned. Help us convert the request and response data. Cancel the request. Automatically convert the result into json data. Block XSRF cross-site attacks to protect clients. Install Axios npm install axios or yarn add axios in the project Tag import &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; Basic use The Axios parameter receives an object, and configuration items are written here. Axios returns a Promise object, so use then( ) to specify the success callback to get the result. After each request is sent, you can view the request header information through Network. GET request (query) 12345678btns[0].onclick = function()&#123; axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts/2&#x27; //The json-server document has a corresponding writing method for the request &#125;).then(response =&gt; &#123; console. log(response); &#125;);&#125; POST request (add a new article) 123456789101112btns[1].onclick = function()&#123; axios(&#123; method: &#x27;POST&#x27;, url:&#x27;http://localhost:3000/posts&#x27;, data: &#123; title:&#x27;new article&#x27;, author:&#x27;Tom&#x27; &#125; &#125;).then(response =&gt; &#123; console. log(response); &#125;);&#125; After the request, the sent data can be found in the db.json file. Because no id is specified, it is added sequentially in posts. In addition, the Payload next to Network-Headers can see the data sent. PUT request (modify data) 123456789101112btns[2].onclick = function()&#123; axios(&#123; method: &#x27;PUT&#x27;, url:&#x27;http://localhost:3000/posts/3&#x27;, //The id should be specified here instead of in data. data: &#123; title:&#x27;second new article&#x27;, author:&#x27;Jonny&#x27; &#125; &#125;).then(response =&gt; &#123; console. log(response); &#125;);&#125; DELETE request (delete data) 12345678btns[3].onclick = function()&#123; axios(&#123; method: &#x27;DELETE&#x27;, url:&#x27;http://localhost:3000/posts/5&#x27; //DELETE request only needs id, no request body. &#125;).then(response =&gt; &#123; console. log(response); &#125;);&#125; Axios other methods to send requests Compared with the previous section, the request method in this section is only different in writing. 12345678axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.options(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]]) Config are other configuration items, such as request headers and request bodies. For example .request() 12345678btns[0].onclick = function()&#123; axios.request(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:3000/posts/2&#x27; &#125;).then(response =&gt; &#123; console.log(response); &#125;);&#125; .post() 12345678910btns[1].onclick = function()&#123; axios.post( //There is no &#123; url=&#x27;http://localhost:3000/posts&#x27;, //here is url= &#123; title:&#x27;new article by .post()&#x27;, author:&#x27;Tomas&#x27; &#125;).then(response =&gt; &#123; console.log(response); &#125;);&#125; Axios response structure The object returned by the Axios request, the result of then(response). config is a configuration object, including request type, request url, request body, etc. data is the response body (the result returned by the server). It is an object, because Axios automatically parses the json returned by the server for easy processing. headers is the response header information. request is a native Ajax request object (XMLHttpRequest() instance object). Because Axios uses Ajax to send requests. status is the response status code, and statusText is the response string.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"Axios","slug":"Front-end/Axios","permalink":"https://redre4per.github.io/categories/Front-end/Axios/"}],"tags":[{"name":"Axios","slug":"Axios","permalink":"https://redre4per.github.io/tags/Axios/"}]},{"title":"Http basics","slug":"Axios/1 Http basics","date":"2022-01-25T03:39:33.000Z","updated":"2022-11-12T00:04:37.416Z","comments":true,"path":"2022/01/25/Axios/1 Http basics/","link":"","permalink":"https://redre4per.github.io/2022/01/25/Axios/1%20Http%20basics/","excerpt":"","text":"Http basics The client sends a request (request message) to the server, and the request content includes request line, request header, and request body. The server responds to the data returned by the client, and the http response (response message) includes status line, response header, and entity content. The specific content of the request can be viewed in inspect-network. The first item under All-Name (the URL item) is sent to the request. There are General, Response Headers and Request Headers in the Headers after clicking, These are the information organized by the browser. Request message: Request line method url GET&#x2F;produc_detail?id&#x3D;2 POST&#x2F;login Multiple request headers Host: www.google.com Cookie[^1]: SEARCH_SAMESITE&#x3D;CgQIl5QB; HSID&#x3D;Acx6gym1ffa3ppTqI; SSID&#x3D;ABqoRPct1dz_XB-1y; … Content-Type: apllication&#x2F;x-www-form-urlencoded or application&#x2F;json Content-type is the request body content type. Request body The request body does not necessarily have. A GET request has no request body, a POST request [^2] has no request body without parameters, and a POST request has a request body with parameters. username&#x3D;tom&amp;pwd&#x3D;123 This is Content-Type: apllication&#x2F;x-www-form-urlencoded format. {“username”: “tom”, “pwd”: “123”} This is Content-Type: application&#x2F;json format. Response message: Response status line status Status code, such as 200, 201, 401, 404, 500. (one-to-one correspondence with the status text example) statusText Status text such as OK, Created, Unauthorized, Not Found, Internal Server Error Multiple response headers Content-Type: text&#x2F;html; (text in html format, text&#x2F;json in JSON format) charest&#x3D;utf-8 (encoding) Set-Cookie: BD_CK_SAM&#x3D;1; path&#x3D;&#x2F; The server returns the cookie data, corresponding to the cookie in the request header. Response body html text&#x2F;json text&#x2F;js&#x2F;css&#x2F;image.. Different types of requests and their functions The same server address sends different types of requests, and the server does different things. GET: read data from the server POST: add new data to the server PATCH: Add new data to the server (partial update) PUT: Update the existing data on the server side (overall update) (in practice, it is often mixed with POST) DELETE: Delete server-side data Ajax request There are two ways to send Ajax requests: XHR objects, and the catch() function. Classification of API The API here refers to the interface for front-end and back-end interaction. REST API: restful (another name) Send a request for CRUD (CRUD: the English abbreviation of CRUD, create&#x2F;read&#x2F;update&#x2F;delete) which operation is determined by the request method is actually a different type of request in section Axios.1.2. If the server supports different request types corresponding to different operations, it is restful; otherwise, it is restless. The same request path can perform multiple operations The request method will use GET&#x2F;POST&#x2F;PUT&#x2F;DELETE Non-REST API: restless (alias) The request method does not determine the requested CRUD operation A request path corresponds to only one operation Generally only GET&#x2F;POST (GET for query, POST for addition, deletion and modification) Appendix [^1]: If it is unsuccessful, it is a problem with the installation of json-server There are 3 ways to solve the installation problem. The first is to add npx before the code, the second is to open a cmd in the current directory and type the code, and the third is to modify permissions through PowerShell in administrator mode [About execution policy](https://docs.microsoft. com&#x2F;en-us&#x2F;powershell&#x2F;module&#x2F;microsoft.powershell.core&#x2F;about&#x2F;about_execution_policies?view&#x3D;powershell-7.2). Admin Mode PowerShell: Press Win + R. Type powershell and press Ctrl+Shift+Enter. Click OK to start PowerShell with administrator privileges. PowerShell By default, *.ps1 script files are not allowed to be executed. Running the ps1 file gives the following error: File C:\\Temp\\Test.ps1 cannot be loaded because the execution of scripts is disabled on this system. Please see “get-help about_signing” for more details. The following command can resolve the above error PS C:\\Windows\\system32&gt; Set-ExecutionPolicy RemoteSigned [^2]: db.json code 123456789&#123; &quot;posts&quot;: [ //posts, not POST requests &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; &#125; ], &quot;comments&quot;: [ &#123; &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 &#125; ], &quot;profile&quot;: &#123; &quot;name&quot;: &quot;typicode&quot; &#125;&#125;","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"Axios","slug":"Front-end/Axios","permalink":"https://redre4per.github.io/categories/Front-end/Axios/"}],"tags":[{"name":"Axios","slug":"Axios","permalink":"https://redre4per.github.io/tags/Axios/"}]},{"title":"props in route@5","slug":"React/E05 props in route","date":"2021-12-31T07:29:52.000Z","updated":"2022-11-12T04:35:42.010Z","comments":true,"path":"2021/12/31/React/E05 props in route/","link":"","permalink":"https://redre4per.github.io/2021/12/31/React/E05%20props%20in%20route/","excerpt":"","text":"Pass the params parameter There are three ways to carry parameters in ajax: query, params, body. The body parameter has two encoding forms: urlencoded and json. There is also a params form in routing components, that is, parameters are placed directly in the path. The parameter is placed directly in the path of the navigation link, and the params parameter is passed to the routing component. Data that cannot be placed can be placed in the state of the sub-route. The path of the routed component is also declared to receive, and is declared using the express syntax in Node.js. When is received, the passed parameters can be found in props.match.params (in React 5.3.1). props is the history object. Parent component (carrying parameters, declared to receive) 12345678state = &#123;msgArr:[&#123;id:&#x27;01&#x27;, title:&#x27;message1&#x27;&#125;, &#123;id:&#x27;02&#x27;, title:&#x27;message2&#x27;&#125;, &#123;id:&#x27;03&#x27;, title:&#x27;message3&#x27;&#125;]&#125;;const &#123;msgArr&#125; = &#123;this.state&#125;;msgArr.map(msgObj =&gt; &#123;return(&lt;Link to=&#123;`/home/message/detail/$&#123;msgObj.id&#125;/$&#123;msgObj.title&#125;`&#125;&gt;&#123;msgObj.title&#125;&lt;/Link&gt; )&#125;); //carry parameters&lt;Route path=&#x27;/home/message/detail/:id/:title&#x27; component=&#123;Detail&#125;/&gt; //node writing, declare to receive Routing component (receiving parameters) 1234567891011121314const DetailData = [&#123;id:&#x27;01&#x27;, content:&#x27;Hello, Australia&#x27;&#125;, &#123;id:&#x27;02&#x27;, content:&#x27;Hello, Tasmania&#x27;&#125;, &#123;id:&#x27;03&#x27;, content:&#x27;Hello, Hobart&#x27;&#125;]const &#123;id,title&#125; = this.props.match.params; //Receive parametersconst findResult = DetailData.find(detailObj =&gt; &#123; return detailObj === id&#125;)return( &lt;ul&gt; &lt;li&gt;ID:&#123;id&#125;&lt;/li&gt; &lt;li&gt;Title:&#123;title&#125;&lt;/li&gt; &lt;li&gt;Content:&#123;findResult.content&#125;&lt;/li&gt; &lt;/ul&gt;) Summarize Route link (with parameters): &lt;Link to=&#39;/demo/test/tom/18&#39;&gt;Details&lt;/Link&gt; Register route (declare parameters): &lt;Route path=&#39;/demo/test/:name/:age&#39; component=&#123;test&#125;/&gt; Receive parameters: const &#123;id,title&#125; = this.props.match.params Pass the search parameter Similar to the routing component passing params parameters, it is the same as the query syntax in ajax, namely ?id=01&amp;title=xx1 (urlencoded encoding form, namely key=value&amp;key=value, but there is an extra ?). The search parameter does not need to be declared in the routing component path to receive. When received, the passed parameters can be found in props.match.location.search (in React 5.3.1). The format of the parameter here is search:&quot;?id=01&amp;title=xx1&quot;, that is, a string format rather than an object format. This string can be processed into an object format by itself, or processed by the querystring library (qs library). The querystring library (qs library) has two utility methods. qs.stringify(obj) converts the object into urlencoded encoding form, and qs.parse(urlencoded) converts the urlencoded encoding into an object. Note here that the search parameter has one more ? than urlencoded. Parent component (carrying parameters, declaring receiving), Note that the search parameter does not need to declare receiving, just register the route normally. 1234msgArr.map(msgObj =&gt; &#123;return(&lt;Link to=&#123;`/home/message/detail/?id=$&#123;msgObj.id&#125;&amp;title=$&#123;msgObj.title&#125;`&#125;&gt;&#123;msgObj.title&#125;&lt;/Link&gt; //carry parameters )&#125;);&lt;Route path=&#x27;/home/message/detail&#x27; component=&#123;Detail&#125;/&gt; //declare receiving Subcomponent (receives parameters) 123const &#123;search&#125; = this. props. location;const &#123;id,title&#125; = qs.parse(search.slice(1)); //urlencoded to object, and remove redundant?//Others are the same as the params method Summarize routing link (carrying parameters): &lt;Link to=&#39;/demo/test?name=tom&amp;age=18&#39;&gt;details&lt;/Link&gt; Register route (declare parameters): &lt;Route path=&#39;/demo/test&#39; component=&#123;test&#125;/&gt; Receiving parameters: this.props.location.search Remarks: The obtained search is a urlencoded encoded string, which needs to be parsed with the help of querystring. One more? Need to remove. Pass the state parameter The state here is a unique property of the routing component, not the state of the component. Both the params and search delivery methods will display the passed data in the address bar, but the state method will not. Passing the state parameter requires writing the to= in the navigation link as an object (&#123;&#123;&#125;&#125;). The state parameter does not need to be declared received in the route component path. When received, the passed parameters can be found in props.match.location.state and are in object format. Parent component (carrying parameters, declaring to receive), Note that the state parameter does not need to be declared to receive, just register the route normally. 12&lt;Link to=&#123;&#123;pathname:&#x27;/home/message/detail&#x27;,state:&#123;id:msgObj.id, title:msgObj.title&#125;&#125;&#125;&gt;&#123;msgObj.title&#125;&lt;/Link&gt; //carrying parameters&lt;Route path=&#x27;/home/message/detail&#x27; component=&#123;Detail&#125;/&gt; //declare receiving Subcomponent (receives parameters) 12345const &#123;id,title&#125; = this.props.location.state;const findResult = DetailData.find(detailObj =&gt; &#123; return detailObj === id&#125;) //No change, just for follow-up comparison.//Others are the same as the params method There is a problem here, that is, the params and search methods both have parameters in the address bar, and the address bar still has parameters after refreshing, so the subcomponent data will not be lost. However, there are no parameters in the address bar of the state method, and there are no parameters in the address bar after refreshing, and the subcomponent data is not lost. The principle implemented here is that when using BrowserRouter, it has been operating the history in the browser and maintaining history.XXX. And location is an attribute in history (React 5.3.1 is shorthand, if not shorthand, there is location in history). At this time, if the browser cache is cleared (clear history), and then refresh, the page cannot be rendered and an error (undefined error) is reported. Therefore, adding a ||&#123;&#125; to the child component will not report an error. 12345const &#123;id,title&#125; = this.props.location.state||&#123;&#125;;const findResult = DetailData.find(detailObj =&gt; &#123; return detailObj === id&#125;)||&#123;&#125;//Others are the same as the params method After the change, the refresh will not report an error, but it will display empty data. Summarize Route link (with parameters): &lt;Link to=&#123;&#123;pathname:'/demo/test',state:&#123;name:'tom, age:18'&#125;&#125;&#125; &gt;Details&lt;/Link&gt; Register route (declare parameters): &lt;Route path=&#39;/demo/test/:name/:age&#39; component=&#123;test&#125;/&gt; Receive parameters: this.props.location.state Note: Refresh can also keep parameters.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Nested route@5","slug":"React/E04 Nested route","date":"2021-12-28T21:59:03.000Z","updated":"2022-11-12T04:31:15.485Z","comments":true,"path":"2021/12/29/React/E04 Nested route/","link":"","permalink":"https://redre4per.github.io/2021/12/29/React/E04%20Nested%20route/","excerpt":"","text":"Secondary route writing method (in the @6 version there is no such problem) File location: The component folder is created under the first-level routing folder. Navigation link location: in the routing component of the first-level routing. The path should be a path with a first-level route, such as &lt;MyNavLink to=&quot;/home/news&quot;&gt; 1&lt;MyNavLink to=&quot;/home/news&quot;&gt;News&lt;/MyNavLink&gt; Registered routing location: same as above. The path should also have a first-level routing path. 1&lt;Route path=&quot;/home/news&quot; component=&#123;News&#125;/&gt; If it is a multi-level routing, the path of each previous level must be written. Nested route matching mechanism The matching order of routes is from the first registration to the last registration, and is matched layer by layer according to the routing registration order. The first-level route must be registered first, because it is registered when the page is opened. Matching process: When the navigation link with the path /home/news starts to match, the first level of path=&quot;/home&quot; is matched, and the match is successful due to fuzzy matching, so the home component is presented; then It matches the path=&quot;/home/news&quot; of the second layer, matches the news component under the home component, and then renders the news component in the home component. If strict matching exact is turned on for the first-level route, then the sub-reasons below it are invalid. Because the addresses of sub-routes are all /home/..., and the first-level matching of this address cannot be successfully matched.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Advanced usage of route@5","slug":"React/E03 Advanced usage of route","date":"2021-12-28T05:22:30.000Z","updated":"2022-11-12T04:30:30.483Z","comments":true,"path":"2021/12/28/React/E03 Advanced usage of route/","link":"","permalink":"https://redre4per.github.io/2021/12/28/React/E03%20Advanced%20usage%20of%20route/","excerpt":"","text":"Routing components and general components General components are placed in the src-components tag, but routing components are not in compliance with the specification. When standardizing development, routing components should be placed in src-pages. The general component writing method is &lt;Header/&gt;, and the routing component writing method is &lt;Route path=&#39;/demo&#39; component=&#123;Demo&#125;/&gt;. The general component props is &#123;&#125; if it is not passed; the routing component also has props &#123;history:&#123;&#125;, location:&#123;&#125;, match:&#123;&#125;&#125; fixed three properties. The encoding needs to be used in the three attributes are: history: go: f go(n) goBack: f goBack() goForward: f goForward() push: f push(path, state) replace: f replace(path, state) location: pathname: “&#x2F;about” search: “ “ state: undefined match: params: &#123;&#125; path: “&#x2F;about” url: “&#x2F;about” NavLink If the route link is highlighted, or a dynamic class name needs to be appended when clicking, you cannot use &lt;Link&gt; , use &lt;NavLink&gt; . The mechanism of NavLink is to append a class name to the element currently being clicked, and the class name is active. (The mechanism of Bootstrap is that whoever is active will be highlighted. This matches NavLink exactly.) But sometimes you don’t use Bootstrap, or you don’t want to use the active category. This requires the use of an attribute of NavLink: activeClassName&#x3D;” “, which can specify the highlighted class name. When using this property, add !important to the style to increase the weight (to exceed the Bootstrap default weight) (there is a bug here). wrapped NavLink component If it is not encapsulated, the code repetition is too high (the repeated content is activeClassName and className). Encapsulated as &lt;MyNavLink&gt; (generic component). 1234567import &#123; NavLink &#125; from &#x27;react-router-dom&#x27;export default class MyNavLink extends Component &#123; render() &#123; return ( &lt;NavLink activeClassName=&quot;test&quot; className=&quot;item&quot; &#123;...this.props&#125;/&gt;)&#125;&#125; 1&lt;MyNavLink to=&quot;/home&quot;&gt;Home&lt;/MyNavLink&gt;&lt;br/&gt; //Use the same as NavLink, repeat the code to write to MyNavLink Note here the delivery method of tag body content (Home in the example). The content of the component tag body is a special tag property: props.children. In a tag, instead of writing the content in the content of the tag body, write the content directly with children&#x3D;” “ in the tag, and the content can also be displayed. 1&lt;p children=&quot;label body content&quot;/&gt; //This will display the label content normally. In the example code block, use &#123;...this.props&#125; to write props.children into the tag together, that is, to display the content normally. Use of Switch If a path corresponds to two components, both components will be rendered, but this is not normal code. The routing mechanism is that after the path matches the component, it will continue to match, which leads to low efficiency. The @5 version uses &lt;Switch&gt;&lt;/Switch&gt; to wrap the routing component to solve this problem. Once the path is matched to the component, it will not continue to match. (Use Switch when more than one route is registered) 1234&lt;Switch&gt; &lt;Route path=&quot;/about&quot; component=&#123;About&#125;&gt; &lt;Route path=&quot;/home&quot; component=&#123;Home&#125;&gt;&lt;/Switch&gt; Solve the problem of missing styles Trigger condition for style loss: The navigation link uses multiple &#x2F; (non-nested routes) such as &#x2F;a&#x2F;b and uses bootstrap. After the page is rendered, the style may be lost. (The new version should have been fixed) You can hold down SHIFT and refresh every time you refresh, and force the refresh without leaving the cache. Reason analysis: In the network, look for the bootstrap.css file, the status is 200 (success), and the style is not lost here. Click here to find the bootstrap.css address http://localhost:3000/css/bootstrap.css . This is the address of bootstrap.css in the scaffolding. (where http://localhost:3000 is the scaffolding built-in server (created by devServer in webpack), and public is the root path of http://localhost:3000.) The validity of the bootstrap.css address can be verified directly in the browser Look at this address, or the response next to the header in the network. But when the &#x2F;a&#x2F;b structure is used, the bootstrap.css file, the status is 304. After clicking it, I found that the address is http://localhost:3000/a/css/bootstrap.css , that is, &#x2F;a in the &#x2F;a&#x2F;b structure is considered to be part of the root path, so the address of the css file is wrong. At this time, the response returned is index.html. This is because there is a mechanism in the scaffolding, that is, if a non-existing resource is requested with an address, the scaffolding will render the index.html in public. The error reported here is Resource interpreted as Stylesheet but transferred with MIME type text&#x2F;html: “http://localhost:3000...&quot; There are three solutions: In the public index.html, change the css import path from href=&#39;./css/bootstrap.css&#39; to href=&#39;/css/bootstrap.css&#39; (remove .). The principle here is to change the relative path of ./ to the absolute path of /. / means to go directly to http://localhost:3000 to request content. This is generally used. In index.html, the css import path is changed to href=&#39;%PUBLIC_URL%/css/bootstrap.css&#39; . %PUBLIC_URL% represents the absolute path to the public file. This scenario is limited to React scaffolding. In index.js under src, BrowerRouter is changed to HashRouter. After the change, the root path becomes http://localhost:3000/#/ . # are considered front-end resources and are not brought to the server, such as http://localhost:3000/#/a/b . routing fuzzy matching and strict matching Fuzzy matching: to=&quot;/home/a/b&quot; in the &lt;Link&gt; class tag provides many paths, but &lt;Route&gt; requires fewer paths for path=&quot;/home&quot;, you can match to. When matching, it matches in the order of /home /a /b, and /home matches path=&quot;/home&quot; in the &lt;Route&gt; tag, and the match is successful. However, if the order is wrong, such as /a /home /b, the match cannot be successful, because if /a does not match, it will be considered a match failure. Exact match: The paths must match exactly. &lt;Route exact=&#123;true&#125; path=&quot;/about&quot; component=&#123;about&#125;/&gt;. That is, exact=&#123;true&#125; is added to the &lt;Route&gt; tag. Shorthand can directly write exact, omitting =&#123;true&#125;. In actual work, try not to use strict matching, which will cause serious problems. The principle of use is that if you can not enable strict matching, you will not enable it. If there is a problem with fuzzy matching, then enable strict matching. Redirect implements preselection In the previous way of writing, no routing components are displayed after opening the page, and the page needs to be clicked on the navigation link. But we want to have a default routing component. Implementing default routing requires Redirect redirection. (Deprecated in @6, changed to Navigate) Note that http://localhost:3000 (same as http://localhost:3000/ ) is for route matching. / is an empty string, matching no components. &lt;Redirect to=&quot;/about&quot;/&gt; should be placed at the bottom of the routing component, as a catch-all item (similar to the else in if) to redirect addresses that do not match the routing component to a routing component. 123456import &#123;Redirect&#125; from &#x27;react-router-dom&#x27;;&lt;Switch&gt; &lt;Route path=&quot;/about&quot; component=&#123;about&#125;/&gt; &lt;Route path=&quot;/about&quot; component=&#123;about&#125;/&gt; &lt;Redirect to=&quot;/about&quot;/&gt;&lt;/Switch&gt;","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Basic usage of route@5","slug":"React/E02 Basic usage of route","date":"2021-12-26T03:58:20.000Z","updated":"2022-11-12T04:20:08.054Z","comments":true,"path":"2021/12/26/React/E02 Basic usage of route/","link":"","permalink":"https://redre4per.github.io/2021/12/26/React/E02%20Basic%20usage%20of%20route/","excerpt":"","text":"React-router understanding A plugin library for react. (react-xxx are basically plug-in libraries) The library we installed here is not react-router. react-router has three libraries for three platforms. Three libraries: web: Web page development (actually learning this). The library name is react-router-dom native: used by react native. anywhere: can be used anywhere It is specially used to implement a SPA application. React-based projects will basically use this library. React Router three different libraries on npm The core library of react-router routing provides many: components, hooks react-router-dom contains all content of react-router, and adds some components dedicated to DOM, such as &lt;BrowserRouter&gt;. react-router-native contains all content of react-router, and adds some APIs dedicated to ReactNative, such as &lt;NativeRouter&gt;. Install react-router-dom npm i react-router-dom@5 or &#96;yarn add react-router-dom@5 Basic use of routing The front-end routing implementation is divided into two steps: 1. Clicking on the navigation link causes the path to change; 2. The path change is detected by the router, and the components are matched and displayed. The content of the routing component display area is variable, but other areas are fixed. Therefore, compared to pages that do not use routing, routing-related codes will only be written in the navigation area and routing component display area. The code for fixed display in other areas is written as usual. Import library 1import &#123;&#125; from &#x27;react-router-dom&#x27; //Using `&#123;&#125;` is because many built-in components and built-in APIs need to be exposed, which one to use. Navigation links In native html, &lt;a&gt; is used to jump to different pages, and in React, routing links &lt;Link&gt; are used to switch components. 123import &#123;Link&#125; from &#x27;react-router-dom&#x27;; //Introduce Link&lt;Link className=&quot;list-group-item&quot; to=&quot;/about&quot;&gt;About&lt;/Link&gt;&lt;Link className=&quot;list-group-item&quot; to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;Link&gt; is used instead of &lt;a&gt;. Here there is no href, and to=&quot; &quot; is used instead. Note that about in to=&quot;/about&quot; is best lowercase, because it does not recognize case. Also don’t write to=&quot;./about&quot;, because there is never . in the web path. But directly writing the code in the above code block will report an error: Error: Invariant failed: You should not use &lt;Link&gt; outside a &lt;Router&gt;. Because routing links and routes are managed by the router, that is, a &lt;Router&gt; should be wrapped outside &lt;Link&gt;. And, When using &lt;Router&gt; to wrap &lt;Link&gt;, specify the Router type: &lt;BrowserRouter&gt; &#x2F; &lt;HashRouter&gt; . Otherwise, an error will be reported: TypeError: Cannot read property ‘location’ of undefined. routing component 123456import &#123;Link,Route&#125; from &#x27;react-router-dom&#x27;; //First import the registered routeimport Home from &#x27;./components/Home&#x27;; // does not conform to the specification, see React.5.3.1 for detailsimport About from &#x27;./components/About&#x27;;&lt;Route path=&quot;/home&quot; component=&#123;Home&#125;/&gt;&lt;Route path=&quot;/about&quot; component=&#123;about&#125;/&gt; First, import the registered routing tag &lt;Route/&gt;. &lt;Route/&gt; is self-closing and has attributes path and component&#x2F;element. Note that component is lowercase (some compilers will suggest uppercase). The routing component should also be wrapped with &lt;BrowserRouter&gt; &#x2F; &lt;HashRouter&gt; , otherwise an error will be reported, which is the same as the navigation link. Router management (package &lt;BrowserRouter&gt; &#x2F; &lt;HashRouter&gt;) The entire application must be managed by a router, that is, packaged in the same &lt;BrowserRouter&gt; &#x2F; &lt;HashRouter&gt;, otherwise the routing components cannot be switched. For simplicity, directly wrap the router management package outside the &lt;App/&gt; root component under the index.js file. 1234567import &#123;BrowserRouter&#125; from &#x27;react-router-dom&#x27;;ReactDOM. render( &lt;BrowserRouter&gt; &lt;App/&gt; &lt;/BrowserRouter&gt;, document. getElementById(&#x27;root&#x27;)) ​ Summary Define the navigation area and display area in the interface. Change the a label of the navigation area to the Link label 1&lt;Link to=&quot;/xxxx&quot;&gt;Demo&lt;/Link&gt; Write the Route label in the display area for route matching 1&lt;Route path=&quot;/xxxx&quot; component=&#123;Demo&#125;/&gt; The outermost part of &lt;App/&gt; wraps a &lt;BrowserRouter&gt; &#x2F; &lt;HashRouter&gt; ​","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"SPA, route","slug":"React/E01 SPA, route","date":"2021-12-24T11:13:38.000Z","updated":"2022-11-12T04:15:01.491Z","comments":true,"path":"2021/12/24/React/E01 SPA, route/","link":"","permalink":"https://redre4per.github.io/2021/12/24/React/E01%20SPA,%20route/","excerpt":"","text":"SPA Definition Single page web application (single page web application, SPA). The entire application has only one complete page. (Single page with multiple components) That is, there is only the page localhost:3000&#x2F;index.html (scaffolding root directory). index.html is automatically omitted, which is localhost:3000. There will be no such pages as localhost:3000&#x2F;about.html, localhost:3000&#x2F;home.html. Clicking the link on the page will not refresh the page, but only partial update of the page. Data must be obtained through ajax requests and displayed asynchronously on the front end. Routing understanding When opening the page, the page is an address localhost:3000. When you click the link in the navigation area (routing link), it will not cause the page to jump, but change the address to localhost:3000&#x2F;home, localhost:3000&#x2F;about, etc. Front-end router will specifically monitor changes in browser paths, and display home, about and other components on the page after detection. &#x2F;home, &#x2F;about, etc. are paths, not urls. A route is a mapping relationship (key: value), the key is the path, and the value is component or function (backend). Routing classification Backend routing (Node.js): Understand: value is a function, which is used to process the request submitted by the client. Register the route: router.get(path, function(req, res)) Working process: When the node receives a request, it finds a matching route according to the request path, calls the function in the route to process the request, and returns the response data. Front-end routing: Browser-side routing, the value is component, which is used to display page content. Register the route: &lt;Route path=&quot;/test&quot; component=&#123;test&#125;&gt; Working process: When the browser’s path changes to &#x2F;test, the current routing component will become the Test component. Front-end routing principle (how to implement routing detection) Front-end routing works by the history on the BOM (browser object). window is the BOM object, and document is the DOM object. Output window.history to get History {Length:1, scrollRestoration: “auto”, state:null} object. Programmers often do not directly manipulate history because the native API is not easy to use. Therefore, it is necessary to use the history.js library to operate. Change browser path 123456789101112131415161718192021222324&lt;a onclick=&quot;return push(&#x27;/test1&#x27;)&quot;&gt;push button&lt;/a&gt; &lt;!--Adding return will prohibit a tag herf jumping--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https:.../history.js&quot;&gt;&lt;/script&gt; &lt;!--Import library--&gt;&lt;script type=&quot;text/javascript&quot;&gt; let history = History.createBrowserHistory() //Create a history object function push(path)&#123; //Push a piece of data into the history, the data is the path/test1 history.push(path) return false &#125; function replace(path)&#123; //The current history is replaced with the path path. history.replace(path) &#125; function forward()&#123; // Equivalent to the browser&#x27;s forward button, just written by yourself. history.goForward() &#125; function back()&#123; // Equivalent to the browser&#x27;s back button, just written by yourself. history.goForward() &#125; &lt;/script&gt; After this code runs, the web page will not jump or refresh, but the current page path will become &#x2F;test1. At the same time, a historical record is formed, which can be regressed. (React is required for path matching components, because only React has components.) Detect browser path changes 123history.listen((location) =&gt; &#123; //The listen method listens to the path location. Called when the path changes. console.log(&#x27;The request routing path has changed&#x27;, location)&#125;) The browser’s history structure The browser’s history is a stack structure. The record at the top of the stack is the webpage currently being viewed. When the website is opened, at the bottom of the stack there is the path xxxx.history.html of the website’s home page. When pushing, a xxxxp&#x2F;test1 is added above the history record just now. If you continue to push, add an xxxxp&#x2F;test2 to the top of the stack. When the point goes back, the top of the stack xxxxp&#x2F;test2 is popped, and the web page returns to xxxxp&#x2F;test1. Click back again, the top of the stack xxxxp&#x2F;test1 is popped, and return to xxxx.history.html. When going forward, xxxxp&#x2F;test1 goes back to the top of the stack, and then clicks xxxxp&#x2F;test2 to go back to the top of the stack. During the replace operation, the current location (that is, the record on the top of the stack) is replaced by xxxxr&#x2F;test3. That is, the data in the stack from the bottom of the stack to the top of the stack is xxxx.history.html, xxxxp&#x2F;test1, xxxxr&#x2F;test3, that is, the xxxxp&#x2F;test2 records disappear. Back at this point, it will return to xxxxp&#x2F;test1. Two working modes of History Method 1 (that is, the one used above), directly uses the API on the history launched by H5. Some older browsers do not support it. 1let history = History. createBrowserHistory() Method 2, instead of using the H5 API, the hash value (anchor) is used. 1let history = History. createHashHistory() When using method 2, the browser address will have one more #, such as localhost:3000.html**#&#x2F;. After the push and replace operations, the address will become localhost:3000.html#**&#x2F;test1, still with #. Much like an anchor jump, i.e. does not cause a page refresh and leaves a history. There is no need to write the anchor point by yourself with the hash method, and the other codes are exactly the same as the first method. The disadvantage of the hash method is that there is a # (ugly) in the address, and the advantage is that it has excellent compatibility. #The following things belong to the foreground resources and will not be sent to the server.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Fetch","slug":"React/D04 Fetch","date":"2021-12-23T12:46:54.000Z","updated":"2022-11-12T04:14:18.930Z","comments":true,"path":"2021/12/23/React/D04 Fetch/","link":"","permalink":"https://redre4per.github.io/2021/12/23/React/D04%20Fetch/","excerpt":"","text":"Send request method classification xhr class: ajax (native xhr, troublesome), jQuery (third party, may generate callback hell), axios (third party) fetch: (built-in non-third-party, promise style) Features of fetch XMLHttpRequest does not conform to the separation of concerns (separation of concerns, that is, to split a complex thing). Official document fetch() splits the request sent by xhr into two steps. The first step is to contact the server, and the second step is to return data from the server. Fetch usage Full writing Simple usage (not optimized) 123456789101112//The first step: verify whether the server is in an active state and can establish a connection.fetch(url, options).then(function(response) &#123; // Contacting the server was successful. response returns a server status object, which contains the header. (but no data is returned) return response.json //Return data, go to the next then() processing&#125;, function(error) &#123; // Failed to contact the server. The failure condition is very special: if the requested data server does not have it, the server will not be contacted to fail (but there will be 404 in the header); //If the entire browser is offline, the contact server failure will only be displayed return new Promise(()=&gt;&#123;&#125;); //Interrupt the Promise chain&#125;).then( response =&gt; &#123;console.log(&#x27;Get data successfully&#x27;, response)&#125;, error =&gt; &#123;console.log(&#x27;Failed to get data&#x27;, error)&#125;) There is a json method (response.json) on the prototype object of the response response object, the return value is a promise instance, and the data is in this instance object. If the contact with the server is successful, the data acquisition is successful, the status of the instance is successful, and the successful data is saved in it; If the contact with the server is successful, Failed to obtain data, the status of the instance is failure, and the reason for the failure is stored in it. To get this data, it is best to use chained calls and process it in the next then(). return new Promise(); is used to break the Promise chain. If you don’t write this code, there will be no return value when contacting the server fails, that is, it will return undefined by default, and then process it according to success; if this code is written to return an error, it will go to the next error branch in the promise chain, affecting the efficiency, it is better to interrupt. Code can be optimized with catch to handle errors uniformly. (preliminary optimization) 1234567fetch(url, options).then(function(response) &#123; return response.json&#125;).then( response =&gt; &#123;console.log(&#x27;Get data successfully&#x27;, response)&#125;,).catch( error =&gt; &#123;console.log(error);&#125;) Use await async to optimize fetch code .then() can specify a success callback and a failure callback. But when .then() does not specify a failure callback (like the previous code), there is no need to write .then(), and it is more appropriate to use await async. await cannot be used directly, you need to add async to the function closest to await: 12345search = async() =&gt; &#123; const response = await fetch(url, options) //wait for the successful result of fetch&#x27;s promise instance: responseconst data = await response.json() //The second step is to get the dataconsole. log(data);&#125; await can only wait for a successful result, If you want to catch an exception, use try&#123;&#125; catch()&#123;&#125;. Code that might produce errors is written inside try&#123;&#125;: 123456789search = async() =&gt; &#123; try &#123; const response = await fetch(url, options)const data = await response.json()console. log(data); &#125; catch(error)&#123; console.log(&#x27;request error&#x27;, error) &#125;&#125; fetch use case A case retrofit for React.4.2 with fetch. (when not using await async) 12345678910fetch(`/api1/search/users2?q=$&#123;keyWord&#125;`).then( response =&gt; &#123; console.log(&#x27;Contact the server successfully&#x27;); return response.json();&#125;).then(response =&gt; &#123; console.log(&#x27;Get data successfully&#x27;, response);PubSub. publish(&#x27;My message&#x27;, &#123;isLoading: false, user: data. items&#125;)&#125;,).catch(error =&gt; &#123; PubSub. publish(&#x27;My message&#x27;, &#123;isLoading: false, err: error. message&#125;)&#125;) When using await async 12345678910search = async() =&gt; &#123; try &#123; const response = await fetch(`/api1/search/users2?q=$&#123;keyWord&#125;`)const data = await response.json()PubSub. publish(&#x27;My message&#x27;, &#123;isLoading: false, user: data. items&#125;) &#125; catch(error)&#123; console.log(&#x27;request error&#x27;, error); PubSub. publish(&#x27;My message&#x27;, &#123;isLoading: false, err: error. message&#125;) &#125;&#125;","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"PubSub","slug":"React/D03 PubSub","date":"2021-12-21T11:02:37.000Z","updated":"2022-11-12T03:35:19.720Z","comments":true,"path":"2021/12/21/React/D03 PubSub/","link":"","permalink":"https://redre4per.github.io/2021/12/21/React/D03%20PubSub/","excerpt":"","text":"Passing values (communication) between sibling components Passing values between parent and child components: With the help of props, the child passes a function to the parent with props, and the child component calls the function and passes parameters. Passing values between sibling components: message subscription and publishing mechanism. PubSub is not only suitable for passing values between sibling components, but also for passing values between any components, especially for passing messages in multi-level hierarchical components, because it doesn’t matter where the components are. Message Subscription and Publishing Tool library: PubSubJS (PubSub is the abbreviation of Publish and Subscribe) Download: npm install pubsub-js --save Steps for usage: Introduce import PubSub from &#39;pubsub-js&#39; (the repository name of a technology is different from the npm name, because of the npm specification) Subscribe PubSub.subscribe&#123;&#39;delete&#39;, function(data)&#123;&#125;&#125;; Publish a message PubSub.publish(&#39;delete&#39;, data) PubSub use Subscribe messages in components that need to receive data 1234var mySubscriber = function(msg, data)&#123; //Parameter 1 is the message name (useless, available _, placeholder), and parameter 2 is the data. console.log(msg, data)&#125;var token = PubSub.subscribe(&quot;My Topic&quot;, mySubscriber); //Parameter 1 is the message name, and parameter 2 is the callback function that will be called when someone publishes a message. Assigned to token is used when unsubscribing later. mySubscriber is usually written directly in the PubSub.subscribe method, and is usually subscribed after the component is mounted. After the code is simplified: 12345componentDidMount()&#123; let token = PubSub.subscribe(&quot;My Topic 1&quot;, (_, data) =&gt; &#123; console.log(data); &#125;)&#125; Cancel subscription: usually before the component is unloaded. 123componentWillUnmount()&#123; PubSub.unsubscribe(token)&#125; Post a message in the component that generates the data 1PubSub.publish(&quot;My Topic&quot;, &#x27;hello world!&#x27;); //Parameter 1 is the message name, parameter 2 is the sent data, usually &#123;&#125;","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Github searching case study","slug":"React/D02 Github searching case","date":"2021-12-20T22:12:15.000Z","updated":"2022-11-12T03:30:32.851Z","comments":true,"path":"2021/12/21/React/D02 Github searching case/","link":"","permalink":"https://redre4per.github.io/2021/12/21/React/D02%20Github%20searching%20case/","excerpt":"","text":"Case introduction In this case, there is a search bar above and a display bar below. After searching, the user’s avatar and username will be displayed. Click on the avatar to enter the user’s homepage. Before searching, the display area should display Waiting for Search; Loading should be displayed during the search, the user avatar should be displayed when the search is successful, and the error reason should be displayed when the search fails. ideas In terms of subcomponents, this case should be divided into two components: the upper search component and the lower display component. The display of the picture and the realization of clicking the picture to enter the link: these two functions have nothing to do with JS, and should use the syntax of html, as follows 123&lt;a ref=&quot;userlink&quot; href=&#123;user.html_url&#125; target=&quot;_blank&quot;&gt;&lt;img src=&#123;user.avatar_url&#125; alt=&quot;user_Avatar_picture&quot; style=&#123;&#123; width: &#x27;100px&#x27; &#125;&#125; /&gt;&lt;/a&gt; Implementation (using props to pass value) App.js components 1234567891011121314151617export default class App extends Component &#123; state = &#123; users: [], //Pay attention to an empty array here, otherwise the value will be empty when there is no search, and the rendering will go wrong. isInitial: true, isLoading: false, err: &#x27;&#x27; //Pay attention here to initialize a null character &#x27;&#x27;, in the Boolean judgment, the null character is false. &#125; getData = (stateObj) =&gt; &#123; this.setState(stateObj) //Here is to receive multiple properties of state. The parameters of the callback are all &#123;key:value&#125; &#125; //form, so it can directly satisfy the setState syntax setState(&#123;&#125;). render() &#123; return (&lt;div&gt; &lt;Search getData=&#123;this. getData&#125; /&gt; &lt;List &#123;...this.state&#125; /&gt; &#123;/*Here is to use object destructuring assignment to pass all the properties in the state, */&#125; &lt;/div&gt; ) &#123;/*But notice that there is no XXX=&#123;&#125;. */&#125; &#125;&#125; Search.jsx component 1234567891011121314151617181920export default class List extends Component &#123; sendRequest = () =&gt; &#123; this.props.getData(&#123; isInitial: false, isLoading: true, users: [] &#125;) axios.get(`https://api.github.com/search/usersq=$&#123;this.input1Node.value&#125;` ).then(response =&gt; &#123; this.props.getData(&#123; isLoading: false, users: response.data.items &#125;) &#125;, reason =&gt; &#123; this. props. getData(&#123; isLoading: false, err: reason. message &#125;) &#125;) //Note here that err can only be reason.message, not reason. Because reason is an object, an error will be reported. &#125; //In addition, call getData() and add &#123;key:value&#125; to say that because the result is directly used for setState(), this can be written directly//Merge into the state, which meets the syntax requirements. render() &#123; return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&#123;c =&gt; this.input1Node = c&#125; /&gt; &lt;button onClick=&#123;this.sendRequest&#125;&gt;click to search&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; List.jsx component 1234567891011121314151617export default class List extends Component &#123; render() &#123; return (&lt;div&gt;&#123;this.props.isInitial? &lt;div&gt;Please input text&lt;/div&gt; : //ternary operator instead of if this.props.isLoading? &lt;div&gt;...Loading&lt;/div&gt; : this.props.err? &lt;div&gt;&#123;this.props.err&#125;&lt;/div&gt; : this.props.users.map((user) =&gt; &#123; return &lt;div key=&#123;user.id&#125;&gt; &lt;div&gt;&#123;user.login&#125;&lt;/div&gt; &lt;a ref=&quot;userlink&quot; href=&#123;user.html_url&#125; target=&quot;_blank&quot;&gt; &lt;img src=&#123;user.avatar_url&#125; alt=&quot;avatar&quot; style=&#123;&#123; width: &#x27;100px&#x27; &#125;&#125; /&gt; &lt;/a&gt; &lt;/div&gt;&#125;) &#125; &lt;/div&gt;) &#125;&#125; pay attention Use a callback function to get all the data of setState from the value passed from the child to the parent 1getData = (stateObj) =&gt; &#123;this.setState(stateObj)&#125; 1this.props.getData(&#123; isLoading: false, users: response.data.items &#125;) The principle is to use the syntax of setState(&#123;key: value&#125;) to directly wrap the value passed by the function into &#123;key: value&#125; format and pass it to setState(). I used setState(&#123;...stateObj&#125;) successfully when I coded it myself before, but this is redundant code. Just like […arr], the object is unpacked and repackaged into an object. Pass props in batches, and pass the properties in the state as props, apply 1&lt;List&#123;...this.state&#125;/&gt; Note that the normal way to pass in a single props is users=&#123;this.state.users&#125; , and there is no user= for batch pass in. Ternary operator instead of if In JSX, &#123;&#125; can only be a statement and not if, so use the ternary operator instead. condition? a: replaces the if statement. : is equivalent to else() in the original if statement. Axios returns error.message instead of error If you use error, it will always report an error: Objects are not valid as a React child. This error means that in JSX &#123;&#125; must be string or array, but not object . The error returned by Axios is an object that cannot be rendered to the page through JSX (but can be displayed in the Console), so only error.message can be used. message Do not misspell massage.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Ajax & CORS in React","slug":"React/D01 Ajax and CORS in React","date":"2021-12-19T09:13:37.000Z","updated":"2022-11-12T03:24:16.336Z","comments":true,"path":"2021/12/19/React/D01 Ajax and CORS in React/","link":"","permalink":"https://redre4per.github.io/2021/12/19/React/D01%20Ajax%20and%20CORS%20in%20React/","excerpt":"","text":"Ajax requests in React React needs to integrate a third-party ajax library or package it yourself. Generally use axios. Reason for Proxy cross domain If the proxy is not configured, cross-domain issues will occur (No ‘Access-Control-Allow-Origin’ header…). The reason for the cross-domain is that the address of the Client is http://localhost:3000 and the address of the server is http://localhost:5000 , so the ajax request is not allowed. In addition, the request can be sent out when cross-domain (the server can receive the request), but the ajax engine prevents the data from being returned when it comes back. Solve cross-domain in React scaffolding Scaffolding proxy is a middleman (tiny server), it is opened on port 3000, when Client (3000) sends a request to Server (5000), it first sends the request to The proxy intermediary (3000) is established, and then the proxy intermediary (3000) forwards the request to the Server (5000). When the Server (5000) returns the data, the agent intermediary (3000) receives the data first, and then forwards it to the Client (3000). Although the proxy middleman (3000) is opened on port 3000, it does not use the ajax engine. Because the essential problem of cross-domain is that the ajax engine blocks the response, and the intermediary without the ajax engine has no cross-domain problem, and the same-origin policy does not limit it. Scaffolding proxy configuration There are two ways to configure proxies in React. Global proxy (single server) In the package.json file, add the proxy attribute at the end of the file. The key value is the address to which the request is to be forwarded, just write the port number. Do not write specific &#x2F; items, such as &#x2F;students, it will cause the address to be dead. After configuration, all requests sent to 3000 in the client will be forwarded to 5000. Note here that the scaffolding needs to be restarted after setting. 12&#125;,&quot;proxy&quot;:&quot;http://localhost:5000&quot; After configuration, the Client code must only send requests to port 3000. 12345678910111213141516171819202122232425262728293031323334353637383940414243 getStudentData = () =&gt; &#123; axios.get(&#x27;http://localhost:3000/students&#x27;).then( //Note that this is for 3000 response =&gt; &#123;console.log(response.data);&#125;, error =&gt; &#123;console.log(error);&#125; ) &#125; `` &lt;br/&gt; Note that not all requests sent via http://localhost:3000 are forwarded to the Server (5000). If the item followed by 3000/request is the file under the &lt;font color=&#x27;red&#x27;&gt;public folder&lt;/font&gt; of this project, such as http://localhost:3000/index.html, it will get the public file . &lt;font color=&#x27;red&#x27;&gt;This is because the public folder is the root path of 3000 in http://localhost:3000. &lt;/font&gt;Some resources in 3000 will not be forwarded to 5000 by the agent. &lt;br/&gt;2. &lt;font color=&#x27;green&#x27;&gt;Multi-Server Agent&lt;/font&gt; There is a problem with a single-server proxy, because only one proxy server address can be configured. If the project is to get data from different servers, configuring a proxy cannot meet the needs. Before configuring, make sure there is no proxy configuration in package.json. &lt;br/&gt; &lt;font color=&#x27;red&#x27;&gt;Configuration method: Create the setupProxy.js file in the src folder (the file name cannot be changed). &lt;/font&gt; The code in the file cannot use ES6, but use CJS. Because this file is scaffolded into webpack, which is node.js syntax. (The code does not need to be mastered) &lt;br/&gt; ```javascript const proxy = require(&#x27;http-proxy-middleware&#x27;) //This package has been downloaded when the react scaffold is initialized. // The global proxy is just a shorthand version of it module.exports = function(app)&#123; app.use( proxy(&#x27;/api1&#x27;,&#123; //parameter 1, when a request with this prefix is encountered, the configuration of the proxy will be triggered target:&#x27;http://localhost:5000&#x27;, //To whom the request is forwarded changeOrigin:true, //Let the server know exactly where the request came from. The default is false, and it is changed to true pathRewrite:&#123;&#x27;^/api&#x27;:&#x27;&#x27;&#125; //Key-value pair, the key name is the prefix to be replaced, and the key value is empty after the replacement (required) &#125;), proxy(&#x27;/api2&#x27;,&#123; target:&#x27;http://localhost:5001&#x27;, //Second server changeOrigin:true, pathRewrite:&#123;&#x27;^/api&#x27;:&#x27;&#x27;&#125; &#125;), ) &#125; proxy() accepts two parameters. The first parameter is the path, that is, if the request in the project contains this path, it will be forwarded to the specified server. The second parameter is an object, the forwarding target server and configuration. The pathRewrite:&#123;&#39;^/api&#39;:&#39;&#39;&#125; in the second parameter is to fix the path where the client sends the request. In parameter 1, the proxy sets the identification path, so the address requests sent by the Client to the target server all have &#x2F;api1 (to allow the proxy to identify the server to be forwarded). However, after adding the identification path &#x2F;api, the request address is wrong. pathRewrite:&#123;&#39;^/api&#39;:&#39;&#39;&#125; can replace the identification path &#x2F;api in the request address (after locating the forwarding server) with empty, so the address can be repaired to the server address. The changeOrigin:true, in the second parameter is used to control the value of the Host field in the request header received by the server. The Host field identifies where the request is sent from. Without adding changeOrigin:true,, the Host obtained by the server is 3000, and the data cannot be obtained if the server is strictly restricted. After adding changeOrigin:true,, the Host obtained by the server is 5000. Therefore, this configuration is generally added. Also note that every time you modify the configuration proxy file or modify the server file, you must restart the scaffolding&#x2F;server. Axios request code should be written as: 123456789101112getStudentData = () =&gt; &#123; axios.get(&#x27;http://localhost:3000/api1/students&#x27;).then( //Identify the path api1 response =&gt; &#123;console.log(response.data);&#125;, error =&gt; &#123;console.log(error);&#125; )&#125;getCarData = () =&gt; &#123; axios.get(&#x27;http://localhost:3000/api2/cars&#x27;).then( //Identify the path api2 response =&gt; &#123;console.log(response.data);&#125;, error =&gt; &#123;console.log(error);&#125; )&#125; It means that if there is no students data in the request sent to localhost:3000 (local), go to the proxy configured by api1. Simplified request address If the client location (3000) is the same location as the destination location of the request, you can omit http://localhost:3000. Note here that the reason why the 3000 address sends a request to the 3000 address is that the proxy is set, and the address sent to 3000 is transferred to 5000. 12axios.get(&#x27;http://localhost:3000/api1/search/user?q=$&#123;keyWord&#125;&#x27;).then() //Before simplificationaxios.get(&#x27;/api1/search/user?q=$&#123;keyWord&#125;&#x27;).then() //simplified","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Spread operator","slug":"JavaScript/ES6/3 Spread operator","date":"2021-12-08T19:50:51.000Z","updated":"2023-09-11T01:15:52.318Z","comments":true,"path":"2021/12/09/JavaScript/ES6/3 Spread operator/","link":"","permalink":"https://redre4per.github.io/2021/12/09/JavaScript/ES6/3%20Spread%20operator/","excerpt":"","text":"Spread operator … (array) The spread operator can split an array or array-like structure into a comma-separated sequence of arguments. 12const arr = [1, 2, 3];console.log(...arr) //result is 1 2 3 Note that the spread operator unpacks [ ] not a value, but a sequence. That is, something like var a =...obj; is wrong, because there is no such thing as var a = 1, 2, 3;. But the spread operator can be used for destructuring assignments. Use of spread operator: Pass a sequence of arguments to a function 123456let arr = [1, 2, 3];function getMax(a, b, c)&#123; console.log(b);&#125;getMax(...arr);Math.max(...arr); Merging of arrays 12345const arr1 = [1, 2];const arr2 = [3, 4];const arr3 = arr1.concat(arr2) //The merge method in ES5. The result is [1, 2, 3, 4]const arr4 = [...arr, ...arr2] //The merge method in ES6. The result is [1, 2, 3, 4] Copy of array 123const arr1 = [1, 2, 3, 4];const arr2 = [...arr1];console.log(arr2); //result is [1, 2, 3, 4] Note that if the elements in the array are reference type elements, then this copy is also a shallow copy. If not, it is a deep copy. Convert pseudo array to real array 12const divs = document.querySelectorAll(&#x27;div&#x27;);console.log(divs); //The result is an object because it is a pseudo-array. 123const divs = document.querySelectorAll(&#x27;div&#x27;);const divArr = [...divs];console.log(divArr); //The result is a real array: [div, div, div] The arguments parameter can also be converted to a true array using this method. But since there are rest parameters, this method is unnecessary. Spread operator … (object) Merge two objects 12345678910let obj1 = &#123; name:&#x27;Tom&#x27;, age:18&#125;let obj2 = &#123; gender:&#x27;male&#x27;, hobby:&#x27;football&#x27;&#125;let obj3 = &#123;...obj1, ...obj2&#125;;console.log(obj3) //result &#123;name: &#x27;Tom&#x27;, age: 18, gender: &#x27;male&#x27;, hobby: &#x27;football&#x27;&#125; Add attributes to element objects Native JS approach 1234567891011var obj = &#123; &#x27;id&#x27;:&#x27;Hello&#x27;, &#x27;className&#x27;:&#x27;box&#x27;, &#x27;style&#x27;:&#x27;width:200px; height:200px; background:red&#x27;&#125;let app = document.getElementsByTagName(&#x27;div&#x27;)[0]for(let key in obj)&#123; app[key]=obj[key] //app[key] is to be distinguished from app.key, [key] is a variable and .key is a property name. That is, app[key] is the key in the key-value pair. //[key] of obj[key] is the value in the key-value pair. It&#x27;s not the key because the obj object is in the for in loop.&#125; Spread operator method 1234567var obj = &#123; &#x27;id&#x27;:&#x27;Hello&#x27;, &#x27;className&#x27;:&#x27;box&#x27;, &#x27;style&#x27;:&#x27;width:200px; height:200px; background:red&#x27;&#125;let app = document.getElementsByTagName(&#x27;div&#x27;)[0]app.innerHTML=&quot;&lt;div &quot;+...obj+&quot;&gt;&lt;/div&gt;&quot; //Note here...obj can only be used in React.","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"ES6","slug":"JS-TS/ES6","permalink":"https://redre4per.github.io/categories/JS-TS/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://redre4per.github.io/tags/ES6/"}]},{"title":"Arrow Functions, Rest params","slug":"JavaScript/ES6/2 Arrow function, rest params","date":"2021-12-06T07:40:12.000Z","updated":"2023-09-11T01:16:00.378Z","comments":true,"path":"2021/12/06/JavaScript/ES6/2 Arrow function, rest params/","link":"","permalink":"https://redre4per.github.io/2021/12/06/JavaScript/ES6/2%20Arrow%20function,%20rest%20params/","excerpt":"","text":"Extensions to Functions: Arrow Functions &#x3D;&gt; 123let fn = function(m)&#123;return m&#125;; //ordinary functionlet fn = (m) =&gt; &#123;return m&#125; //complete writing of arrow functionlet fn = m =&gt; m // shorthand arrow function Arrow function writing The complete writing of arrow function: just change the function before the parameter (m) in the ordinary function to the &#x3D;&gt; after the parameter. (the first and second lines of the code) Arrow functions only have the declaration method of function literals, not the declaration method of function fn()&#123;&#125;; . Arrow function shorthand: If the arrow function has only one parameter, you can omit (). () cannot be omitted without arguments. If you want to return an expression (data) directly in an arrow function, you can omit &#123;return&#125; directly. Note that return AND &#123;&#125; must be omitted together. Omitting &#123;return &#125; is generally used when a function does not perform an operation and only wants to return a value. If there are other operations (such as conditional judgment) in &#123;&#125;, don’t save it. 123456//correct waylet fn = m =&gt; m;let fn = m =&gt; 100;let fn = m =&gt; m + 5;//wrong waylet fn = m =&gt; &#123;m + 5&#125;; If you want to return an object &#123;&#125;, there will be ambiguity, because the program parsing does not know whether it is the object &#123;&#125; or the function body &#123;&#125;. Therefore, when returning an object directly, you need to add a () outside, such as: 1let fn = () =&gt; (&#123;name:&#x27;Tom&#x27;&#125;) Arrow Function Features This pointer is static, this always points to the value of this in the scope where the function is declared. The this of a normal function points to the object on which the function was called. example: 12345678910var x = 100;var obj = &#123; x:10 getX: function()&#123; console.log(this.x) &#125;&#125;obj.getX() //10 The function called by obj, this points to obja = obj.get;a(); //100 function called by window, this points to window In an arrow function, this points to the object where the function is defined, and will not change due to changes in the caller. 12345678910var x = 100;var obj = &#123; x:10 getX = () =&gt; &#123; console.log(this.x) &#125;&#125;obj.getX() //10 this points to obja = obj.get;a(); //10 this points to obj Arrow functions cannot instantiate objects as constructors 123456let Person = (name, age) =&gt; &#123; this.name = name; this.age = age;&#125;let me = new Person (&#x27;Tom&#x27;, 30);console.log(me) //error Arguments variable cannot be used 1234let fn = () =&gt; &#123; console.log(arguments);&#125;fn(1, 2, 3); //error. ReferenceError: arguments is not defined Arrow function concept example 12345678910111213function Timer()&#123; this.s1 = 0; this.s2 = 0; //arrow function setInterval(() =&gt; this.s1++, 1000); //normal function setInterval(function()&#123; this.s2++; &#125;, 1000)&#125;var timer = new Timer()setTimeout(() =&gt; console.log(&#x27;s1: &#x27;, timer.s1), 3100); //3setTimeout(() =&gt; console.log(&#x27;s2: &#x27;, timer.s2), 3100); //0 When timer = new Timer(), all the code in Timer is executed, including the timer part. Note that the timer is executed directly instead of being bound to the Timer. The error-prone thing is that timers are methods of the window object, not the timer object. Therefore, the timer is created by the timer object when timer = new Timer() (because the code in the constructor Timer is not executed until the Timer is called). This leads to the fact that when an arrow function is used, the this in the arrow function points to the creator timer of the function; and the caller of the timer is window. Therefore, in the case of non-arrow functions, this in the timer will point to the caller window of the timer. 12var fn = () =&gt; &#123;console.log(this)&#125;;fn() The creator and caller of the arrow function in this example are both window. Rest parameter Used in place of arguments parameter in native JS. The rest parameter can get all the actual parameters of rest. arguments: The result is an object. 1234function data()&#123; console.log(arguments);&#125;data(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;); rest: result is an array rest is declared as …args. 1234function data(...args)&#123; console.log(args);&#125;data(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;); Therefore, the rest parameters can use array methods, such as filter, some, every, map, which improves flexibility. The rest parameter must be placed at the end of the parameter. 1234567891011121314function fn(a, b, ...args)&#123; console.log(a); //result is 1 console.log(b); //The result is 2 console.log(args); //results are 3, 4, 5, 6&#125;fn(1, 2, 3, 4, 5, 6);//if...args put forwardfunction fn(a, ...args, b)&#123; console.log(a); console.log(b); console.log(args);&#125;fn(1, 2, 3, 4, 5, 6); // result error Function default parameters 1234function sum(a = 1, b = 1) &#123; return a + b&#125;sum() When the number of parameters passed in is not enough, or when undefined is passed in, the default parameter value is used instead.","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"ES6","slug":"JS-TS/ES6","permalink":"https://redre4per.github.io/categories/JS-TS/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://redre4per.github.io/tags/ES6/"}]},{"title":"Let, Const, Destructuring assignment","slug":"JavaScript/ES6/1 let const destructuring assignment","date":"2021-12-04T04:20:19.000Z","updated":"2023-09-11T01:15:58.096Z","comments":true,"path":"2021/12/04/JavaScript/ES6/1 let const destructuring assignment/","link":"","permalink":"https://redre4per.github.io/2021/12/04/JavaScript/ES6/1%20let%20const%20destructuring%20assignment/","excerpt":"","text":"Declares variable a by ‘let’ let is the new way to declare variables in ES6, replacing var. 1234let a;let b, c, d;let e = 100;let f = 521, g = &#x27;iloveyou&#x27;, h = []; var: allows repeated declarations, declaration promotion, and automatic declaration. let: No duplicate declarations allowed, no declaration hoisting. Only valid in block scope. Temporary dead zone. Block scope: A &#123;&#125; is a block scope. Common: if, for, and functions. ​ Notice: &#123;&#123;&#125;&#125; This kind of nested block-level scope, variables declared by let in the outer &#123;&#125; are also valid in the inner &#123;&#123;&#125;&#125;. This is because the inner &#123;&#123;&#125;&#125; is also part of the outer &#123;&#125; block scope. (Global variables are also valid in the local scope) In the for loop, let is written outside &#123;&#125;, such as for(let a=0; a&lt;n; a++)&#123;&#125;, but due to the internal processing of the for loop, the element declared by let is actually in the The following &#123;&#125; block scope is defined. And, every time the loop is looped, a new let a (new value) is generated, and a new &#123;&#125; block-level scope is also generated. Therefore, for loops have several &#123;&#125; block scopes a few times. Example 1: var 1234567var a=[];for(var i=0; i&lt;10; i++)&#123; a[i] = function()&#123; console.log(i) &#125;;&#125;a[6]()//The output is 10. This is because var a is a global variable, i will increase every time you run, and finally add to 10, that is, output 10. Example 2: let 1234567var a=[];for(let i=0; i&lt;10; i++)&#123; a[i] = function()&#123; console.log(i) &#125;;&#125;a[6]()//The output is 10. Because let generates 10 &#123;&#125; block scopes, the i declared by each let is only valid within its block scope (not globally) Temporary dead zone: let-declared variables are automatically bound to the current block-level scope. That is, if there is a let declaration variable in a block-level scope, it can only be used in this block-level scope, and external variables with the same name cannot be used. Example: 12345var tmp = 123;if(true)&#123;tmp = &#x27;abc&#x27;; let tmp;&#125;//The output is an error. Because tmp is not declared. ​ const declare constants A constant declared by const cannot be modified, and is used to prevent the constant from being accidentally changed. The initial value must be assigned when const is declared. Const constants generally use uppercase (unspoken rule). const can be used for: regular expressions, username&#x2F;password, elements of document.getElementBy… during DOM manipulation, etc. Another code style is to use const whenever indeterminate. For element modification of arrays and objects, it does not count as constant modification, and no error will be reported. Because the address of the constant has not changed. 123const TEAM = [&#x27;Ali&#x27;,&#x27;Neil&#x27;,&#x27;Tom&#x27;,&#x27;Tony&#x27;];TEAM.push(&#x27;Ben&#x27;); //correct syntaxTEAM = 100; //Error Array destructuring assignment Destructuring assignment can be used to declare multiple variables. The syntax is: 1let [a, b, c] = [1, 2, 3] // same as let a=1; let b=2; let c=3; That is, the left side of let is an array of variables, the right side is an array of data, and the structures on both sides should be the same. Notice: If the number of variables and data on both sides of let do not match, match them one by one from left to right. A variable whose destructuring failed is undefined. Commas can take place. 1let [ , , a] = [1, 2, 3] //a=3 In the case of nesting in destructuring assignment, as long as the nested structure on both sides is the same, it can be successfully matched. Destructuring assignment can be used to exchange data between two variables, such as: 1[x, y] = [y, x] Object destructuring assignment 12345678const stu1 = &#123; name:&#x27;tom&#x27;; age:18; ability: function()&#123; console.log(&quot;I can eat&quot;); &#125;&#125;let &#123;name, age, ability&#125; = stu1; continuous destructuring assignment 1const &#123;keyWordElement:&#123;value&#125;&#125; = this //You can get the value of this.keyWordElement.value, that is, multiple properties Multiple properties can be assigned with continuous destructuring, but note that the intermediate property keyWordElement is not defined here. Destructuring assignment and renaming 12345//method 1let obj = &#123;a:&#123;b:1&#125;&#125;;const &#123;a:&#123;b:data&#125;&#125; = obj; // old name: new name//method 2const &#123;keyWordElement:&#123;value:keyWord&#125;&#125; = this //some experienced programmers will write this Extensions to Strings: Template Strings &#96;&#96; to write strings, allowing newlines. Write variables in ${} without splicing. Shorthand for object ES6 allows variables and functions to be written directly inside curly brackets as object properties and methods 123456789101112let name = &#x27;Web age&#x27;;let change = function()&#123; console.log(&#x27;I can change you&#x27;);&#125;const school = &#123; name, // same as name: name change, //equivalent to change: change improve()&#123; //same as improve: function()&#123;&#125; console.log(&#x27;I can improve your skills&#x27;); &#125;&#125;","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"ES6","slug":"JS-TS/ES6","permalink":"https://redre4per.github.io/categories/JS-TS/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://redre4per.github.io/tags/ES6/"}]},{"title":"setState()","slug":"React/B04 setState()","date":"2021-11-30T02:21:47.000Z","updated":"2022-11-12T03:03:17.404Z","comments":true,"path":"2021/11/30/React/B04 setState()/","link":"","permalink":"https://redre4per.github.io/2021/11/30/React/B04%20setState()/","excerpt":"","text":"Data in React state cannot be changed directly The code in the example is to directly change (wrong) 1234changeWeather()&#123; const isHot=this.state.isHotthis.state.Hot=!isHot //Error!console.log(this.state.isHot)&#125; The immediate consequence of the change is that the console.log output can toggle between true and false, but the page is not re-rendered. Here you can check the status from inspect &#x3D;&gt; Components, and find that isHot in the status is always the initial value. setState() The state state cannot be changed directly, it needs to be changed with the help of a built-in API: setState(). setState() is an asynchronous update. setState() is available in the React.Components prototype through the inheritance chain. An object is to be written in setState(), which is the same as state. 1234changeWeather()&#123;const isHot=this.state.isHotthis.setState(&#123;isHot : ! isHot&#125;)&#125; At this time, the state in inspect&#x3D;&gt;Components will switch. The state update action of setState() is merged rather than replaced When the state is updated, the object in setState() will not replace the object in the state as a whole, but only modify the part with the same name. Times of code executions in class components The constructor constructor(props) is only executed once, the time ReactDOM.render is called when the instance is created. render is called 1+n times. 1 is the time it was initialized, and n is the number of state updates. changeWeather(): It is called several times when the click event is triggered several times. setState is in changeWeather() . Therefore, React will re-call render once whenever the state is modified via setState. Components are also known as state machines. Shorthand for state and function The this in constructor(props) and render() in the class component points to the class component instance. Because the this in the constructor itself is the instance object of the class, and the this of render() is also the instance object because react creates an instance of the class when ReactDOM.render(&lt;component tag/&gt;...) is executed. And it is called by instance.render(). There is a problem with the this pointer in the custom function, because the custom function is not called through instance.custom function, but called through event callbacks (custom functions are almost all called through event callbacks). Code before simplification 123456789101112131415class Weather extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123;isHot:false,wind:&#x27;breeze&#x27;&#125; this.changeWeather = this.changeWeather.bind(this) //*** &#125; render()&#123; const &#123;isHot,wind&#125; = this.state return &lt;h1&gt;onClick=&#123;this.changeWeather&#125;Today&#x27;s weather &#123;isHost?&#x27;hot&#x27;:&#x27;cool&#x27;&#125;,&#123;wind&#125;&lt;/h1&gt; &#125; changeWeather()&#123; const isHot = this.state.isHot this.setState(&#123;isHot:!isHot&#125;) &#125;&#125; Simplified way Assignment statements can be written directly in the class, such as a=1, instead of this.property name=fixed value written in the constructor. This code is to add an attribute to the instance object of the class. If the initial value of this property is passed in from outside, it must be written in the constructor. Therefore, state initialization can be written outside the constructor. 1state = &#123;isHot: false, wind: &quot;breeze&quot;&#125; this.changeWeather = this.changeWeather.bind (this) This statement can be omitted. The purpose of this statement is to change the point of this and copy the changeWeather method on the class prototype object to the instance attribute changeWeather. After being omitted, the changeWeather method does not exist on the function prototype object, but only the instance attribute has changeWeather. And the value of this property is an anonymous function. Note that it is an error to omit the method changeWeather=function()&#123;&#125;. This is because it just changed the changeWeather to another place, and it still reports an error after clicking (because there is no .bind(this) to change the direction). So the correct way is arrow functions. The arrow function does not have its own this. When using this in the arrow function, it will find the this of the outer function of the arrow function to use. Therefore, this in the arrow function is the instance object of the component. 1234changeWeather = () =&gt; &#123; const isHot = this.state.isHot this.setState(&#123;isHot:!isHot&#125;)&#125; When writing a custom method in a class component in the future, it must be written in the form of an assignment statement + an arrow function. It is impossible not to write an assignment statement, and a syntax error will be reported. Because if you don’t write assignment, you are putting the function on the class prototype. There is no syntax that can put the arrow function on the class prototype. 1changeWeather() =&gt; &#123;&#125; //Wrong way of writing abbreviated code 12345678910111213class Weather extends React.Component&#123; state = &#123;isHot:false,wind:&#x27;breeze&#x27;&#125; changeWeather = () =&gt; &#123; const isHot = this.state.isHot this.setState(&#123;isHot:!isHot&#125;) &#125; render()&#123; const &#123;isHot,wind&#125; = this.state return &lt;h1&gt;onClick=&#123;this.changeWeather&#125;Today&#x27;s weather &#123;isHost?&#x27;hot&#x27;:&#x27;cool&#x27;&#125;,&#123;wind&#125;&lt;/h1&gt; &#125;&#125;","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Class components","slug":"React/B03 Class components","date":"2021-11-28T12:04:18.000Z","updated":"2022-11-12T02:49:43.476Z","comments":true,"path":"2021/11/28/React/B03 Class components/","link":"","permalink":"https://redre4per.github.io/2021/11/28/React/B03%20Class%20components/","excerpt":"","text":"Create class components If the class defines the component, the class must inherit React’s built-in class: React.Component 1class MyComponent extends React. Component&#123;&#125; Among them, the constructor can be omitted. render() must be written, and the return value of render()&#123;return&#125; must also be written. If returning a multi-level structure, it is best to wrap it with (). 12345class MyComponent extends React. Component&#123; render()&#123; return &#125;&#125; Location of render()&#123;&#125; render is placed on the prototype object of the class for use by the instance. Instances of class components are created by React.render(&lt;MyComponent/&gt;......). What happens after executing ReactDOM.render( &lt;MyComponent/&gt; ......)? When executing this code, React parses the component tags and finds the MyComponent component. Later, it is found that the component is defined using a class, and then an instance of the class is newly created, and the render() method on the prototype is called through the instance. Then, convert the virtual DOM returned by render into real DOM, and then render it on the page. The this in render() points to the instance object of the class. It can also be called an instance object of a class component. The props, refs, and state in the class component instance object are called the three major attributes of the component (instance). The context will also look at it. No other attributes are concerned. These attributes are obtained by inheritance. Simple components and complex components Simple components: components without state (functional components) Complex components: stateful components (class components) state state The state of the component drives the page. (Compared to Vue, Vue is a data-driven page) React puts the data in the state, and the change of the data will drive the display of the page. The state property is on the component instance object, not the class itself. State initialization The initialization of state should be written in the constructor (not shorthand). Because state is a property in the class, and modifying the property value must be written in the constructor (ES5). Shorthand in ES6. state can also be abbreviated outside the constructor. constructor(){} What arguments should it accept when it is not omitted (what to pass when new)? Class components are not new by themselves, but React.render helps us new. The official documentation in React states that props should be passed in, that is, constructor(props){}. It should be noted that props are written here because of syntax requirements. If not, the constructor will report an error. I will talk about it in detail later. Before simplified 12345678910class Weather extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123;isHot:true&#125; &#125; render()&#123; console.log(this); //this is the instance object of the class return &lt;h1&gt;Today&#x27;s weather is very &#123;this.state.isHost?&#x27;hot&#x27;:&#x27;cool&#x27;&#125;&lt;/h1&gt; //The ternary expression processes the state data &#125;&#125; After simplified 1234567class Weather extends React.Component&#123; state = &#123;isHot:true&#125; // Shorthand without writing a constructor (detailed in React.6.5) render()&#123; const &#123;isHot&#125; = this.state //Use destructuring and copying to take out the keys in the state, and then you can write it shorter. return &lt;h1&gt;Today&#x27;s weather is &#123;isHost?&#x27;hot&#x27;:&#x27;cool&#x27;&#125;&lt;/h1&gt; &#125;&#125; After initializing the state value, the state of the class component can be seen in the Components in the inspect. click event Event binding in native JS (three ways): .addEvent Listener(&quot;click&quot;, ()=&gt;&#123;&#125;) .onclick=()=&gt;&#123;&#125; &lt;button onclick=&quot;fn()&quot;&gt; The third one is recommended in React, which is to bind events directly in tags. (The first two can actually be used, but there are too many document operations, so it is not recommended). React rewrites all events in native JS, and uses the small camel form, that is, onclick is onClick in React. In the event of React, the listener cannot be a string &quot;&quot;, is different from native JS. Here it should be written as a variable form of &#123;&#125; . React events cannot be written directly onClick=&#123;fn()&#125;. This is because fn() means that the function is executed when the event is assigned a value, which is to return the of the function execution The value is directly assigned to onClick instead of executing the function after clicking. This is equivalent to the logic of the second event binding method in native JS. So write onClick=&#123;fn&#125;. this pointor problem (the click event writes the function body outside the class component) In the above click event, the function body of fn cannot be written outside the class component (such as below ReactDOM.render). This is because this in the function body points to undefined (Babel prohibits custom functions from pointing to window), but cannot point to the instance object of the class. Error analysis After writing this.state, an error may be reported: Cannot read property ‘state’ of undefined. means that state cannot be read on undefined. That is, in this.state, this points to undefined. In the same way, in a similar error report, you can directly find the a error in the a.b structure. What if you must write the function body outside the class and get the this pointing to the class instance? The idea here is to start with global variables. That is, the global variable let that, and then write that = this in the constructor of the class component. At this time, the outer-class function body can use that to point to the instance object. But this way of writing is unreasonable, because it is too cumbersome, and it will cause the code block of the class component to be scattered everywhere. This points to the problem (the function body is inside the class) Question 1: Where is the function changeWeather() placed in the class? is placed on the Weather prototype object. When changeWeather() is called from a Weather instance, the this in changeWeather() is the Weather instance. 123456class Weather extends React.Component&#123; constructor(props)&#123;... render()&#123;... changeWeather()&#123; console.log(this.state.isHot); &#125;&#125; Several wrong spellings in render() &lt;h1 onClick=&#123;changeWeather&#125;&gt; This will report an error changeWeather is not defined. This is because only the instance can call the function in the class, which can be found by writing this.changeWeather according to the logic. &lt;h1 onClick=&#123;this.changeWeather&#125;&gt; This will report an error cannot read property ‘state’ of undefined . This means that the left side of state is wrong again, that is, this points to undefined. What is the reason for this? (This error only occurs when the above code block is used. This problem does not occur when using non-constructor arrow functions) When calling changeWeather through the Weather instance, this in changeWeather is the Weather instance. But here changeWeather( ) is not called from the Weather instance. After binding the click event here, the heap address of this.changeWeather is directly bound to the click event of h1, similar to const x=p1.changeWeather in native JS. In this case, when h1 is clicked, the caller of changeWeather is not the Weather instance object, but the window. Therefore, since changeWeather is used as a callback of onClick, it is not called through an instance, but directly. All custom methods in the class have turned on strict mode locally, so they cannot point to window, but can only be undefined. Resolve this pointer The method in the example is used with &lt;h1 onClick=&#123;this.changeWeather&#125;&gt;, that is to change the this point. Code is executed from right to left. this.changeWeather finds the changeWeather on the prototype object, and then bind turns this in the new function into the Weather instance object. This new function is then placed in the instance itself and named changeWeather. 12345constructor(props)&#123; super(props) //initialize state this.state = &#123;isHot:false&#125;; this.changeWeather = this.changeWeather.bind(this);&#125; That is, after writing this line of code, there is one more method on the instance object of Weather, which is called changeWeather. If it is not written, there is no such method on the instance object, only changeWeather on the prototype. When &lt;h1 onClick= &#123;this.changeWeather&#125;&gt; is clicked, the changeWeather here is not the one on the prototype, but the changeWeather on the instance itself. At this time, according to the search order, the method with the same name is used first on itself. Array data in state state = &#123;todoList:[]&#125; state = &#123;todoList:[&#123;&#125;,&#123;&#125;,&#123;&#125;]&#125; It should be noted here that the state in state can only be written as {} object, and the data in the object are all key-value pairs, written as key: value. If key: value is written as key&#x3D;value, an error will be reported, that is, Parsing error: Invalid shorthand property initialiser.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Class knowledge review","slug":"React/B02 Class knowledge review","date":"2021-11-26T11:48:29.000Z","updated":"2022-11-12T02:35:33.253Z","comments":true,"path":"2021/11/26/React/B02 Class knowledge review/","link":"","permalink":"https://redre4per.github.io/2021/11/26/React/B02%20Class%20knowledge%20review/","excerpt":"","text":"Console output class Red represents that the output is an instance object, and blue represents who created the instance object. Person {} If the constructor of the class does not receive parameters, the created instance objects will look the same. Constructor constructor 12345class Person &#123;constructor (name, age) &#123; this.name=name this.age=age &#125;&#125; Who is this in the constructor? this points to the instance object of the class. The constructor can not be written. But if you don’t write it, the instance objects are the same. General methods: custom methods other than constructors. Do not write functions. Directly methodname() in the class. Common methods are placed on the prototype object of the class. The methods placed on the prototype object are for the instance. In general methods this refers to the instance object. That is, when a generic method is invoked through an instance, this in the generic method refers to the instance. But here you can use the call&#x2F;apply&#x2F;bind method to change the this pointer. Inherit extends 1class Student extends Person &#123;&#125; The Student class does not have to write a constructor, because the parent class Person has a constructor. When a subclass does not write a constructor, it directly inherits the constructor of the parent class. When a subclass needs to customize a new constructor, because the parameters are passed in order, they must be received in order. And must call super to call the constructor of the parent class. 12345class Student extend Person &#123; constructor (name, age, grade) &#123; super (name, age) //Note here that super must be placed at the top of the constructor. this.grade=grade &#125;&#125; ​ Summary The constructor in the class does not have to be written. It is only written when some initialization operations are to be performed on the instance, such as adding specified attributes. If class a inherits class b, and a constructor is written in class a, super must be called in the constructor of class a. The method defined in the class is placed on the prototype object of the class for use by the instance. Object related knowledge All property names in the object are strings (that is, hard-coded), namely this.setState(&#123;dataType: event.target.value&#125;) and this.setState(&#123;&#39;dataType&#39;: event.target.value&#125; ) is the same effect, just shorthand. If you want dataType to become a variable, you must write it as [dataType]. If you want to get the object key name in the object, if the key name is still a variable, you need to use obj[key] to get it instead of obj.[key]. Such as let a=&#39;name&#39;; let obj=&#123;&#125;; To get the result of name: &#39;tom&#39;, you must write obj[a] = &#39;tom&#39;.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Component","slug":"React/B01 Component","date":"2021-11-26T06:37:03.000Z","updated":"2022-11-12T02:34:18.106Z","comments":true,"path":"2021/11/26/React/B01 Component/","link":"","permalink":"https://redre4per.github.io/2021/11/26/React/B01%20Component/","excerpt":"","text":"Module and component definitions Module: Generally, a .JS file is a module (developed by function) Component: A collection of JS+HTML+CSS code and resources (developed by region) Developer Tools React-Developer Tools Based on Chrome browser. Chrome - Extensions - Open the Chrome Web Store - Type React in the search box. The provider is Facebook. When opening a webpage written by React, the icon in the upper right corner will light up. If the webpage has not been packaged and launched, it is a red + bug mark; If the webpage is packaged and launched, it is the React dark blue logo. When right-clicking an element, there are more Components and Profiler tabs. Components are used to observe how many components a web page is composed of, and to see how many properties each component has. Profiler is used to record website performance, loading time&#x2F;which component is the slowest, etc. Functional components Because components include HTML&#x2F;CSS&#x2F;JS, at least there must be structural HTML, , so functional components must have a return value. The component name must be capitalized. If the component name is lowercase, an error will be reported after rendering with the lowercase name: Warning: Function are not valid as a React Child. This may happen if you return a Component instead of from render. Or maybe you meant to call this function rather than return it. When rendering the component to the page, must write &lt;MyComponent/&gt; closing tag. Attention question The functional component is not called by itself, but is called by React for me. After the call, the return value is obtained and rendered on the page. This in functional components points to the problem 123function MyComponent()&#123;console.log(this) //undefined&#125; The reason is that the JSX code is to be translated by babel, and strict mode will be turned on after translation. Strict mode prohibits this in custom functions from pointing to window, so it is undefined. What happens after executing ReactDOM.render( &lt;MyComponent/&gt; ...) ? React parses the component tag and finds the MyComponent component. It is found that the component is defined with a function, and then the function is called to convert the returned virtual DOM into a real DOM, and then render it on the page. The application of the three properties of class components in functional components The three properties of class components are state, props, and refs. This is used when calling these properties, such as this.state.isHot this.props.name. This is because this represents an instance of a functional component. That is, the three attributes of class components are used on class instances. Functional components, on the other hand, do not have instances. So state and refs cannot be used (the new version of state can be used through hooks). But functional components can use props, because functions can take parameters. Functional components use props The props in class components are returned from this.props like: 1render()&#123;const &#123;name, age, gender&#125; = this.props &#125; Functional components don’t have this. However, all key-value pairs passed into component tags are also collected by React into the props object. In this case, the parameter of the functional component is the props object. Therefore, instead of using this.props, functional components can directly use props objects instead of class components. Functional components limit the data in props Class component restrictions on props can be written outside the class component or inside the class component. But functional components don’t have the static syntax. Therefore, it is restricted that props can only be written outside the component. 123functional component()&#123;&#125;componentname.propType = &#123;&#125;componentname.default = &#123;&#125; The purpose of functional components The general case is to deal with static pages, because functional components do not handle logic (before hooks).","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Virtual DOM, JSX","slug":"React/A02 Virtual DOM, JSX","date":"2021-11-25T03:06:26.000Z","updated":"2022-11-12T02:11:25.659Z","comments":true,"path":"2021/11/25/React/A02 Virtual DOM, JSX/","link":"","permalink":"https://redre4per.github.io/2021/11/25/React/A02%20Virtual%20DOM,%20JSX/","excerpt":"","text":"**Why React uses JSX instead of native JS? ** Case 1: Create the following example with JS and JSX 123&lt;div id=&quot;test&quot;&gt; &lt;h1 id=&quot;title&quot;&gt;Hello,React&lt;/h1&gt;&lt;/divdiv&gt; JSX 1const VDOM = &lt;h1 id=&quot;title&quot;&gt; Hello, React &lt;/h1&gt; JS: Syntax const VDOM = React.createElement(tag name, tag attribute-object writing, tag content) That is, without introducing babel, create a virtual DOM directly with React. Note here that document.createElement() creates a real DOM, while React.createElement() creates a virtual DOM. 1const VDOM = React.createElement(&#x27;h1&#x27;, &#123;id: &#x27;title&#x27;&#125;,&#x27;Hello, React&#x27;) Case 2: One more level of nesting in case 1 12345&lt;div id=&quot;test&quot;&gt; &lt;h1 id=&quot;title&quot;&gt; &lt;span&gt;Hello,React&lt;/span&gt; &lt;/h1&gt;&lt;/divdiv&gt; JSX 1const VDOM = &lt;h1 id=&quot;title&quot;&gt;&lt;span&gt;Hello, React&lt;/span&gt;&lt;/h1&gt; JS: Wrong writing (The span tag in this writing method does not take effect.) 1const VDOM = React.createElement(&#x27;h1&#x27;, &#123;id: &#x27;title&#x27;&#125;,&#x27;&lt;span&gt;Hello, React&lt;/span&gt;&#x27;) Correct spelling 1const VDOM = React.createElement(&#x27;h1&#x27;, &#123;id: &#x27;title&#x27;&#125;,React.createElement(&#x27;span&#x27;, &#123;&#125;, &#x27;Hello, React&#x27;)) //Write an empty object without a tag attribute. When multiple layers of tags need to be nested, it is very difficult to write native JS, and JSX only needs to be written in normal HTML mode. The creation of JSX is only to solve: to solve the problem that virtual DOM creation is too cumbersome. JSX also supports newline writing. Use parentheses ( ) to wrap the code in JSX. Note here that the JSX code in the example, after being translated by babel, is the JS code in the example. Therefore, the way of creating virtual DOM in JSX is the syntactic sugar for creating virtual DOM in native JS. Virtual DOM Methods of outputting the DOM Use Console.log to output the VDOM. The result is a generic Object, whose data type is object, and which is also an instance of Object. (left) Use Console.log to output the real DOM. The real DOM is written HTML, like &lt;div id=&quot;demo&quot;&gt;&lt;/div&gt; . If I use the code Console.log(document.getElementById(&quot;demo&quot;)), the output can only get &lt;div id=&quot;test&quot;&gt;&lt;/div&gt; without seeing the attributes. So you need to use breakpoints, debugger; (right) In conclusion Virtual DOM is essentially an object of type Object (general object) The virtual DOM is relatively “light” and has fewer attributes; the real DOM is relatively “heavy”. Because the virtual DOM is used internally by React, there is no need for so many properties on the real DOM. The virtual DOM will eventually be converted into a real DOM by React and presented on the page. JSX syntax The full name is JavaScript XML. It is a JS extension syntax similar to XML defined by React. XML is an early data storage and transmission mode. Later, JSON is used to store data in the form of &#123;&#125; object strings. The parse method converts the string to JSON, and the stringily method converts the object string. 1234&lt;student&gt; &lt;name&gt;Tom&lt;/name&gt; &lt;age&gt;19&lt;/age&gt;&lt;/student&gt; Grammar rules: When defining a virtual DOM, do not write quotes. If you want to mix JS expressions in the tag, use the &#123;&#125; form. And because JS requires lowercase, it can be converted with &#123;myId&#125;.toLowerCase( ). The style class name designation applies className, because class is already occupied by the keyword. For example className=&quot;title&quot;. The inline style cannot be written with style=&quot;color: white&quot;, it will report an error that style cannot be written as a string. Because multiple sets of key-value pairs can be written in style, inline styles are written in object form in JSX. style needs to be written as a double {} pattern, ie: style=&#123;&#123;&#125;&#125; The outer {} represents the JS environment, and the inner {} represents the object in the JS. Such as style=&#123;&#123;color: 'white'&#125;&#125; . Be careful to add &#39;&#39; here, otherwise it will become a variable. In addition, some inline styles are composed of multiple words, namely font-size. It should be written as a small hump, that is, style=&#123;&#123;color: 'white', fontSize: '20px'&#125;&#125; Summary: Inline styles should be written in the form of style=&#123;&#123;key: value&#125;&#125; . JSX requires only one root tag. That is, the outermost layer needs a &lt;div&gt; container. The label must be closed. The first: &lt;input type=&quot;text&quot;&gt;&lt;/input&gt; The second: &lt;input type=&quot;text&quot;/&gt; Lowercase tags in JSX tags will be automatically converted to HTML tags with the same name when babel is compiled, and uppercase tags are component tags. But if you write a tag that is not in HTML and it is still a lowercase tag, it will be ignored by babel when compiling, which is equivalent to writing no tag outside. The first letter of the label: If it starts with a lowercase letter, the label will be converted to an element with the same name in HTML. If there is no element with the same name in HTML, an error will be reported. If the uppercase letter starts with , react will render the corresponding component. If the component is not defined, an error will be reported. JSX error-prone point React can automatically traverse the data in the array. The backend returns pure data, which is modified with map(). React cannot directly write the object as a node in the JSX tag. The corresponding error is: Uncaught Invariant Violation: Objects are not valid as a React child. If you meant to render a collection of children, use an array instead. In JSX, the for loop cannot be written in the tag. Because JS expressions inside JSX tags are written in &#123;&#125;, &#123;&#125; can only be written as expressions, not statements. JS expressions Expression: An expression yields a value and can be placed anywhere a value is required. Example: a variable name, a+b, demo(1) function call expression, arr.map() processing array, function test()&#123;&#125; defining function. Simple distinction method: connect a const x&#x3D; to the left of the expression, if it can receive a value, it is an expression, and if it cannot be received, it is not. Statement: if()&#123;&#125;, for()&#123;&#125;, switch()&#123;case:xxx&#125; The statement controls the direction of the code. No value, not part of an expression, no value. The map needs a key after modifying the array, because the diff algorithm needs it. The key is written in the loop tag as an attribute. If you don’t add data in reverse order, delete in order, etc. to destroy the order, only the list is rendered for display, and index can be used as the key. The way of comments in JSX Using /* */ directly will not work. Use &#123;/* */&#125; because &#123;&#125; provides the JS execution environment. Folding code in JSX 123//#regioncode block//#endregion","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Introduction","slug":"React/A01 Introduction","date":"2021-11-23T22:26:51.000Z","updated":"2022-11-12T02:09:41.030Z","comments":true,"path":"2021/11/24/React/A01 Introduction/","link":"","permalink":"https://redre4per.github.io/2021/11/24/React/A01%20Introduction/","excerpt":"","text":"React Family Bucket React core React- Router routing library PubSub message management library Redux centralized state management library Ant-Design UI component library React definition React: A JavaScript library for building user interfaces. The interface is the view. React is an open-source JavaScript library that renders data into HTML views. For example, the process of obtaining backend data and presenting it includes: Send a request to get data Process the data (filtering, formatting, etc.) Manipulate the DOM to render the page Regardless of the first two steps, React is only responsible for operating the DOM to render the page, and the first two steps still need to be operated by itself. In the first two steps, React does not have its own encapsulation method. Developed by Facebook, and open source It was deployed in Facebook and other newsfeeds in 2011, and was announced as open source in May 2013. Native JS Disadvantages The operation of DOM in native JS is cumbersome and inefficient. Complicated refers to troublesome coding, and low efficiency refers to the browser having to rearrange and draw every DOM operation. Using JS to directly manipulate the DOM, the browser will do a lot of redrawing and rearranging. Native JS has no component coding scheme, and the code reuse rate is low. Modularization: split a JS into several small JS files according to the function points. React Features Component mode, declarative coding, improves development efficiency and component reuse rate. Imperative: order the machine how to do things (how), so that no matter what you want (what), it will be implemented according to your order. Declarative: tell the machine what you want (what), let the machine figure out how to do it (how). In React Native, React syntax can be used for mobile development. React Native is to allow front-end staff to write IOS and Android applications with JS. Use virtual DOM + excellent Diffing algorithm to minimize interaction with real DOM. JS knowledge to master in learning React Judging this point, class, ES6 grammar specification, npm package manager, prototype prototype chain, common methods of arrays, modularization. Using React (learning version 16.8 + new version) 4 packages Babel.min.js Babel has two uses: ES6 to ES5, JSX to JS. Prop-types.js prop library in React class components React.development.jsReact core library React-dom.development.js React extension library for manipulating DOM React Coding First, there must be a container, similar to a mount point. &lt;div id=&quot;test&quot;&gt;&lt;/div&gt; Import the React package. react.development must be imported before react-dom.development. Finally, introduce babel. Before writing JS, you need to write it in the tag &lt;script&gt;. The full name of the tag is &lt;script type=&quot;text/javascript&quot;&gt; where type can be omitted. In React, because JSX needs to be written, the tag is &lt;script type=&quot;text/babel&quot;&gt;. Create virtual DOM const VDOM = &lt;h1&gt;Hello, React&lt;/h1&gt; Do not write &quot; &quot; here, because it is not a JS string, but a JSX virtual DOM. Render the virtual DOM to the page ReactDOM.render(virtual DOM, container) ReactDOM. render(VDOM, document. getElementById(&#39;test&#39;)) This is the only place in React where you need to manipulate the DOM yourself. Warnings and Errors You are using the in-brower Babel transformer. Be sure to precompile your scripts for production - When beginners use the method of manually introducing the React library (such as Section React 1.1.7 &amp; 1.1.8), the browser finds out that it is not JS when the script code is obtained. It depends on babel and the browser translates it on the spot. When there are many codes, the screen will be white, and it will run after waiting. Hence the yellow warning. Failed to load resource: the server responded with a status of 404 (Not Found) There is no icon for the website, after refreshing it is gone. Error-prone point Did not write mount point container &lt;div id=&quot;&quot;&gt;&lt;/div&gt; const VDOM = &#39;&lt;h1&gt;Hello, React&lt;/h1&gt;&#39; mistakenly added single quotes &#39; &#39; &lt;script type=&quot;text/babel&quot;&gt; is written as text/javascript Rendering twice is not an addition, but a replacement. Favicon When there is no icon, the console will report an error, and it will be canceled after refreshing. Failed to load resource: the server responded with a status of 404 (Not Found) Solution: Make an icon with the name&#x2F;format favicon.ico and put it in the root directory. The icon will appear after a forced refresh. Force refresh: press and hold shift+refresh. Annotation shortcuts in scaffolding CTRL+SHIFT+ - , the selected area directly forms a {&#x2F;* *&#x2F;} comment.","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"}]},{"title":"Variable","slug":"JavaScript/Native JS/2 Variable","date":"2021-10-13T00:39:20.000Z","updated":"2023-09-11T01:16:14.664Z","comments":true,"path":"2021/10/13/JavaScript/Native JS/2 Variable/","link":"","permalink":"https://redre4per.github.io/2021/10/13/JavaScript/Native%20JS/2%20Variable/","excerpt":"","text":"Variable naming Variable names can be capitalized because JS is case-sensitive. Variable assignment = is an assignment symbol. The usage is to assign the value on the right side of the equal sign to the variable on the left side of the equal sign. var box can be unassigned first when declaring variables, but it must be assigned with =. 1234var box = 1;var a = 5;var b = a = box;console.log(a, b, box) //result: 1, 1, 1. Data Types in JavaScript Primitive data type: Number, String, Boolean, undefined, null. (Symbol in ES6) Reference data types: Object, Array, Function. There is no need to declare a type when a variable is declared. It is okay to store different data types before and after the variable, for example, var b=123; var b=&quot;hello&quot;;. There is no floating point numbers in JS. Both integers and decimals are of type number. String type data must be added with &quot;&quot;. The data added with &quot;&quot; must also be a string. The boolean type has only a=true; b=false; (true and false are keywords). Undefined is used for unassigned variables. The result of var a; console.log(a) is undefined. Undefined is used to automatically initialize variables. Null is a null object pointer. Operator Operator: Symbols that operate on data. Expressions: All expressions are connected by operators, and expressions and data are equivalent. (because the result of an expression must be data) Arithmetic operators: + - * / ++ -- % a++ a++ self increment (+1 on the basis of itself, and then assign to itself). ++ When used alone, a++ and ++a are the same. When ++ is not used alone (eg b=a++), it is different before and after. ++a: +1 before participating in other operations. a++: first use the previous value to participate in the operation, and then increment 1 to itself after the operation is completed. 1234var a = 10;var b = a++;console.log(a) //11console.log(b) //10","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"Native JavaScript","slug":"JS-TS/Native-JavaScript","permalink":"https://redre4per.github.io/categories/JS-TS/Native-JavaScript/"}],"tags":[{"name":"Native JavaScript","slug":"Native-JavaScript","permalink":"https://redre4per.github.io/tags/Native-JavaScript/"}]},{"title":"Basic knowledge","slug":"JavaScript/Native JS/1 JavaScript Basic","date":"2021-10-12T08:28:36.000Z","updated":"2023-09-11T01:16:10.330Z","comments":true,"path":"2021/10/12/JavaScript/Native JS/1 JavaScript Basic/","link":"","permalink":"https://redre4per.github.io/2021/10/12/JavaScript/Native%20JS/1%20JavaScript%20Basic/","excerpt":"","text":"HTML CSS is not a programming language JavaScript is a programming language (browser programming language). Web pages written in HTML CSS do not have any functionality. All functions have to be done through JavaScript. Java brand backend language, the best language for writing backend. It is cooperative web development, big data, enterprise-level applications, big data, and Android development. C embedded, operating system, driver development C++ games and the like, desktop software C# software development How to use JS Add &lt;script&gt;&lt;/script&gt; tags to the body to use JS. Usually coding JS before the closing tag of the body. This is because JS loads slowly and the HTML &amp; CSS loads quickly. From the user’s point of view, the overall web page should be swiped first. JS core ECMAScript Core DOM page manipulation BOM browser related operations Comments in JS // Single line /* Multiple lines */ Variable A variable is a space in memory dedicated to storing data. How to use variable: Variables should be declared by var. The variable should be named var box. The variable should be assigned var box = 1. Semicolon in JS ; can be added or not (preferably) Console Console is for debugging JS, it is useless after the project development is over. The console can prompt errors. Console is in the browser -&gt; right click -&gt; inspect -&gt; Console. Console.log() function is console output (in JS). Project deployment The project can be accessed locally on the computer. Logically, other people can also access it through IP address + path + file name, but it’s practically not feasible because of firewall.To actually deploy project, you need to run the project to the server. The server is a high-performance computer that runs 24 hours a day without shutting down. Generally, small projects only rent a small part of the space in the server. Domain name: like www.google.com, and bind it’s IP address. When the domain name is entered, it is resolved by DNS (domain name system) and resolved into an IP address in the service and accessed. URL address: like https://www.google.com/src/index. protocol://domain name: port number + path (file path or route). Protocol http, https (secure mode), FTD (file upload), file.Port number: Different applications, different functions of the server. Such as 80 web pages, 3306 databases. Can be omitted by default. Path: The file path or the route set by the frontend&#x2F;backend.","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"Native JavaScript","slug":"JS-TS/Native-JavaScript","permalink":"https://redre4per.github.io/categories/JS-TS/Native-JavaScript/"}],"tags":[{"name":"Native JavaScript","slug":"Native-JavaScript","permalink":"https://redre4per.github.io/tags/Native-JavaScript/"}]},{"title":"Appendix - Special characters in TS","slug":"Others/Chinese notes/Appendix TS中的符号","date":"2021-01-19T00:29:31.000Z","updated":"2023-03-01T10:36:32.004Z","comments":true,"path":"2021/01/19/Others/Chinese notes/Appendix TS中的符号/","link":"","permalink":"https://redre4per.github.io/2021/01/19/Others/Chinese%20notes/Appendix%20TS%E4%B8%AD%E7%9A%84%E7%AC%A6%E5%8F%B7/","excerpt":"","text":"_ 数字分隔符 分隔符 _ 不会改变数值字面量的值，但逻辑分组使人们更容易一眼就能读懂数字。 12const inhabitantsOfMunich = 1_464_301;const bytes = 0b1111_10101011_11110000_00001101; 使用限制： 只能在两个数字之间添加 _ 分隔符，下例是非法的： 1234563_.141592 // Error1_e10 // Error_126301 // Error126301_ // Error0_b111111000 // Error123__456 // Error，也不能连续使用多个 _ 分隔符 解析数字的函数是不支持分隔符 123Number(&#x27;123_456&#x27;) //NaNparseInt(&#x27;123_456&#x27;) //123parseFloat(&#x27;123_456&#x27;) //123 #XXX 私有字段 在 TypeScript 3.8 版本就开始支持 ECMAScript 私有字段。与常规属性（甚至使用 private 修饰符声明的属性）不同，规则是： 私有字段以 # 字符开头，有时我们称之为私有名称； 每个私有字段名称都唯一地限定于其包含的类； 不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）； 私有字段不能在包含的类之外访问，甚至不能被检测到。 123456789101112class Person &#123; #name: string; //私有字段 constructor(name: string) &#123; this.#name = name; &#125; greet() &#123; console.log(`Hello, my name is $&#123;this.#name&#125;!`); &#125;&#125;let semlinker = new Person(&quot;Semlinker&quot;);semlinker.#name; // Property &#x27;#name&#x27; is not accessible outside class &#x27;Person&#x27;。 私有字段和 private 的区别： private 的属性和方法可以通过一些特殊方式访问。如： 1234567class Person &#123; constructor(private name: string)&#123;&#125;&#125;let person = new Person(&quot;Semlinker&quot;);console.log(person.name); //Property &#x27;name&#x27; is private and only accessible within class &#x27;Person&#x27;.console.log((person as any).name); //可以正常访问！ 这是因为 private 编译成 ES5 代码后，成为了： 123456789var Person = /** @class */ (function () &#123; function Person(name) &#123; this.name = name; &#125; return Person;&#125;());var person = new Person(&quot;Semlinker&quot;);console.log(person.name); 而私有字段编译后不同。 ! 非空断言（第11节） ?. 可选链 Optional Chaining（第11节） ?? 空值合并运算符（第11节） ?: 可选属性（第9节） 工具类型（第13节） &amp; intersection（第10节） | union（第四节） &lt;type&gt; 语法：断言（第11节）或泛型（第12节）","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Chinese notes","slug":"Others/Chinese-notes","permalink":"https://redre4per.github.io/categories/Others/Chinese-notes/"}],"tags":[{"name":"Chinese notes","slug":"Chinese-notes","permalink":"https://redre4per.github.io/tags/Chinese-notes/"}]},{"title":"TS in React","slug":"Others/Chinese notes/14 React中的TS","date":"2021-01-18T00:29:31.000Z","updated":"2023-03-01T10:33:25.532Z","comments":true,"path":"2021/01/18/Others/Chinese notes/14 React中的TS/","link":"","permalink":"https://redre4per.github.io/2021/01/18/Others/Chinese%20notes/14%20React%E4%B8%AD%E7%9A%84TS/","excerpt":"","text":"React.FC 说明不是常规函数，而是函数式组件。必须有返回值。 123const TodoList: React.FC = () =&gt; &#123; return &lt;div&gt;&lt;/div&gt;&#125;; Props props 的类型有两种写法，它们是等价的。 泛型接口 React.FC&lt;props类型&gt; 123456interface TodoListProps &#123; items: &#123;id: string, text: string&#125;[]; &#125;;const TodoList: React.FC&lt;TodoListProps&gt; = props =&gt; &#123; return ( ... )&#125; 在参数中声明 props 类型 123456interface TodoListProps &#123; items: &#123;id: string, text: string&#125;[]; &#125;;const TodoList = (props: TodoListProps) =&gt; &#123; return ( ... )&#125; props 也有可能是函数。这时应该写成： 123456type NewTodoProps = &#123; onAddTodo: (todoText: string) =&gt; void;&#125;const NewTodo: React.FC&lt;NewTodoProps&gt; = props =&gt; &#123; return (...)&#125; 事件的类型 常见的Event 事件对象如下： 剪切板事件对象：ClipboardEvent&lt;T &#x3D; Element&gt; 拖拽事件对象：DragEvent&lt;T &#x3D; Element&gt; 焦点事件对象：FocusEvent&lt;T &#x3D; Element&gt; 表单事件对象：FormEvent&lt;T &#x3D; Element&gt; Change事件对象：ChangeEvent&lt;T &#x3D; Element&gt; 键盘事件对象：KeyboardEvent&lt;T &#x3D; Element&gt; 鼠标事件对象：MouseEvent&lt;T &#x3D; Element, E &#x3D; NativeMouseEvent&gt; 触摸事件对象：TouchEvent&lt;T &#x3D; Element&gt; 滚轮事件对象：WheelEvent&lt;T &#x3D; Element&gt; 动画事件对象：AnimationEvent&lt;T &#x3D; Element&gt; 过渡事件对象：TransitionEvent&lt;T &#x3D; Element&gt; 这些Event事件对象的泛型中都会接收一个Element元素的类型，这个类型就是绑定这个事件的标签元素的类型。 1234567891011121314151617type State = &#123; text: string;&#125;;const App: React.FC = () =&gt; &#123; const [text, setText] = useState&lt;string&gt;(&quot;&quot;) const onChange = (e: React.FormEvent&lt;HTMLInputElement&gt;): void =&gt; &#123; setText(e.currentTarget.value); &#125;; return ( &lt;div&gt; &lt;input type=&quot;text&quot; value=&#123;text&#125; onChange=&#123;onChange&#125; /&gt; &lt;/div&gt; );&#125; useState() 声明类型 用 useState&lt;类型&gt;() 来声明 state 的类型。 默认情况下，React会为根据设置的state的初始值来自动推导state以及更新函数的类型。如果初始值为null，需要显式地声明 state 的类型。 123const [count, setCount] = useState&lt;number&gt;(1); //可以省略&lt;number&gt;const [count, setCount] = useState&lt;number | null&gt;(null); //需要显示声明const [todos, setTodos] = useState&lt;&#123;id: string; text: string&#125;[]&gt;([]); //最好改成interface[]。 如果state是一个对象，想要初始化一个空对象，可以使用断言来处理： 1const [user, setUser] = React.useState&lt;IUser&gt;(&#123;&#125; as IUser); 使用 useRef 获得用户输入的类型 1const textInputRef = useRef&lt;HTMLInputElement&gt;(null); **更多的 React 中使用 TS 的知识 ** https://juejin.cn/post/7021674818621669389","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Chinese notes","slug":"Others/Chinese-notes","permalink":"https://redre4per.github.io/categories/Others/Chinese-notes/"}],"tags":[{"name":"Chinese notes","slug":"Chinese-notes","permalink":"https://redre4per.github.io/tags/Chinese-notes/"}]},{"title":"Generic Utility Types","slug":"Others/Chinese notes/13 Generic Utility Types","date":"2021-01-17T00:29:31.000Z","updated":"2023-03-01T10:33:20.601Z","comments":true,"path":"2021/01/17/Others/Chinese notes/13 Generic Utility Types/","link":"","permalink":"https://redre4per.github.io/2021/01/17/Others/Chinese%20notes/13%20Generic%20Utility%20Types/","excerpt":"","text":"Generic Utility Types 泛型实用程序类型 泛型实用程序类型（generic utility types），可以用于处理和转换不同类型的数据。这些 generic utility types 都是 generic，因为它们所做的就是取其他任何类型的值，并对其进行处理。 Partial 将类型 T 中的所有属性变为可选属性。常用于想临时切换一个对象类型，一个接口，使它成为可选的。例如： 12345678910111213interface CourseGoal &#123; title: string; description: string; completeUntil: Date;&#125;function createCourseGoal (title: string, description: string, completeUntil: Date): CourseGoal &#123; let courseGoal = Partial&lt;CourseGoal&gt; = &#123;&#125;; //没有Partial的话就报错了。 courseGoal.title = title; courseGoal.description = description; courseGoal.completeUntil = date; return courseGoal as CourseGoal;&#125; Required 将类型 T 中的所有可选属性变为必填属性。例如： 12345678910interface Person &#123; name?: string; age?: number; address?: string;&#125;type RequiredPerson = Required&lt;Person&gt;;const person1: RequiredPerson = &#123; name: &#x27;Alice&#x27;, age: 30, address: &#x27;123 Main St.&#x27; &#125;; // OKconst person2: RequiredPerson = &#123; name: &#x27;Bob&#x27;, age: 40 &#125;; // Error: address is missing Readonly 将类型 T 中的所有属性变为只读属性。例如： 12345678910interface Person &#123; name: string; age: number; address: string;&#125;type ReadonlyPerson = Readonly&lt;Person&gt;;const person: ReadonlyPerson = &#123; name: &#x27;Alice&#x27;, age: 30, address: &#x27;123 Main St.&#x27; &#125;;person.name = &#x27;Bob&#x27;; // Error: Cannot assign to &#x27;name&#x27; because it is a read-only property. 也可以用来锁定数组和对象等。 12const names: Readonly&lt;string[]&gt; = [&quot;Max&quot;, &quot;Anna&quot;];names.push(&quot;Manu&quot;); //报错 Pick&lt;T, K&gt; 从类型 T 中挑选出属性名为 K 的属性组成一个新的类型。例如： 123456789interface Person &#123; name: string; age: number; address: string; email: string;&#125;type PersonNameEmail = Pick&lt;Person, &#x27;name&#x27; | &#x27;email&#x27;&gt;;const person: PersonNameEmail = &#123; name: &#x27;Alice&#x27;, email: &#x27;alice@example.com&#x27; &#125;; Omit&lt;T, K&gt; 从类型 T 中剔除属性名为 K 的属性组成一个新的类型。例如： 12345678910interface Person &#123; name: string; age: number; address: string; email: string;&#125;type PersonWithoutAge = Omit&lt;Person, &#x27;age&#x27;&gt;;const person: PersonWithoutAge = &#123; name: &#x27;Alice&#x27;, address: &#x27;123 Main St.&#x27;, email: &#x27;alice@example.com&#x27; &#125;; Record&lt;K, T&gt; 创建一个类型，其中包含由类型 K 中的每个属性名映射到类型 T 的值类型。例如： 12345678910type Weekday = &#x27;Mon&#x27; | &#x27;Tue&#x27; | &#x27;Wed&#x27; | &#x27;Thu&#x27; | &#x27;Fri&#x27;;type WorkHours = Record&lt;Weekday, &#123; start: string, end: string &#125;&gt;;const workHours: WorkHours = &#123; Mon: &#123; start: &#x27;9:00&#x27;, end: &#x27;17:00&#x27; &#125;, Tue: &#123; start: &#x27;9:00&#x27;, end: &#x27;17:00&#x27; &#125;, Wed: &#123; start: &#x27;9:00&#x27;, end: &#x27;17:00&#x27; &#125;, Thu: &#123; start: &#x27;9:00&#x27;, end: &#x27;17:00&#x27; &#125;, Fri: &#123; start: &#x27;9:00&#x27;, end: &#x27;17:00&#x27; &#125;,&#125;","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Chinese notes","slug":"Others/Chinese-notes","permalink":"https://redre4per.github.io/categories/Others/Chinese-notes/"}],"tags":[{"name":"Chinese notes","slug":"Chinese-notes","permalink":"https://redre4per.github.io/tags/Chinese-notes/"}]},{"title":"Generic","slug":"Others/Chinese notes/12 Generic","date":"2021-01-16T00:29:31.000Z","updated":"2023-03-01T10:33:15.850Z","comments":true,"path":"2021/01/16/Others/Chinese notes/12 Generic/","link":"","permalink":"https://redre4per.github.io/2021/01/16/Others/Chinese%20notes/12%20Generic/","excerpt":"","text":"泛型的概念 Generic 类型是一种与其他类型有某种联系的类型，并且对于其他类型是哪种类型非常灵活。TS 有内置的泛型类型： Array 主类型是 Array，但是 Array 中的项可以是其他类型。 1const names: Array = []; //这里类型实际是Array&lt;any&gt;，或者也可以写成any[]; Promise 主类型是 Promise，但是 resolve 的结果可以是其他类型。 12345const promise: Promise&lt;string&gt; = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&quot;This is done!&quot;); &#125;, 2000);&#125;); 在某种程度上，Generic 类型并不关心数据是否属于某个特定类型，而是希望将类型信息存储在传入数据之外，以便在使用泛型类型时获得更好的 TypeScript 支持。 在函数中使用 Generic 在例中，TS 只知道函数返回类型是 object。 12345function merge(objA: object, objB: object) &#123; return Object.assign(objA, objB);&#125;const mergedObj = merge(&#123;name: &quot;Max&quot;&#125;, &#123;age: 30&#125;);mergedObj.age; //报错，因为TS只知道返回了一个对象，而不知道对象内属性。 函数中可以使用泛型来表示参数类型或返回值类型的不确定性，可以使用尖括号 &lt;&gt; 来声明泛型参数。在例中，调用函数时传入参数一传入 object 类型参数，T就被推导为 object 类型了。 而 &lt;T, U&gt; 是泛型参数列表，用来定义函数中的类型参数。泛型参数列表中的 &lt;T, U&gt; 表示有两个泛型类型参数 T 和 U，可以用来表示函数的参数类型（T 和 U）。 12345function merge&lt;T, U&gt;(objA: T, objB: U) &#123; //鼠标放在merge上，会获得T&amp;U（intersection，交叉类型）。 return Object.assign(objA, objB);&#125;const mergedObj = merge(&#123;name: &quot;Max&quot;&#125;, &#123;age: 30&#125;);mergedObj.age; //正常运行，得到30. 函数的返回值类型是根据函数体中的代码，TS 推断得到的。泛型参数 &lt;T, U&gt; 只是用来指定参数的类型，以及为 TS 的类型推断提供支持，而对于函数的实际行为和返回值类型的推断并没有直接的影响。 注意例中的 T, U 也包含 object 类型外的类型。 类型限制 type constraint 上例中，如果参数不是 object 类型，就会得出错误的结果，并且 IDE 也不会报错。如果想把它们限制在 object 类型，就应该使用类型限制。 类型限制使用 extends 关键字，并且只写在 &lt;&gt; 中的参数列表。 1234function merge&lt;T extends object, U extends object&gt;(objA: T, objB: U) &#123; return Object.assign(objA, objB);&#125;const mergedObj = merge(&#123;name: &quot;Max&quot;&#125;, 30); //此时这里会报错，30不符合类型。 同样，类型限制 extends 后也可以使用自定义类型，union 类型等。 使用泛型来确保函数参数有某个属性 在 TS 中，可以使用 Generic 来确保参数具有某个属性。一种常用的方法是使用泛型约束，即在泛型参数后面添加一个 extends 关键字和一个约束类型，用来限制泛型参数的类型。 123456interface HasName &#123; name: string;&#125;function printName&lt;T extends HasName&gt;(obj: T) &#123; //强制参数拥有name属性 console.log(obj.name);&#125; 例中函数接收一个 T 类型的参数，这个参数必须满足 T extends HasName 的约束条件。不满足条件 IDE 就会报错。 同样的，这个方法也可以用来限制参数原型对象上有某种方法，来确保它的原型对象上某种属性： 123456interface Lengthy &#123; length: number;&#125;function countAndDescribe&lt;T extends Lengthy&gt;(element: T)&#123; if(element.length...)&#123; ... &#125;;&#125; 使用 keyof 来声明参数是对象中的某个 key keyof 用来获取一个类型的所有属性名称，生成一个由属性名组成的联合类型。keyof 有两个使用场景： 获取对象属性名并进行类型检查 使用 keyof 获取对象的所有属性名，并将它们组成一个联合类型。这个联合类型中的每个成员都是该对象的一个属性名。我们可以使用这个联合类型来进行类型检查，以确保我们只访问了该对象真正拥有的属性。例如： 123function extractAndConvert&lt;T extends object, U extends keyof T&gt;(obj: T, key: U) &#123; return &quot;Value&quot; + obj[key]; //如果不声明U是T中属性的key，就会报错。&#125; 例中，假如参数 obj 的值是 &#123;name = &quot;Derek&quot;, age = 18, gender = male&#125;，那么 **U 的类型就是 &#39;name&#39; | &#39;age&#39; | &#39;gender&#39;**。 定义泛型类型参数 使用 keyof 还可以在定义泛型类型参数时限制该参数的取值范围，以确保它只能取某个类型的属性名。例如： 123456interface Person &#123; name: string; age: number;&#125;type PersonKey = keyof Person; // 类型为 &#x27;name&#x27; | &#x27;age&#x27; 与第一种场景类似。 泛型类 使用泛型来定义类，可以让类中的某些属性或方法支持多种类型。类中使用泛型的语法与函数中类似，我们只需要在类名后面加上 &lt;&gt;，并在其中指定泛型类型参数即可。 123456789101112131415161718192021class DataStorage&lt;T&gt; &#123; private data: T[] = []; addItem(item: T) &#123; this.data.push(item); &#125; removeItem(item: T) &#123; this.data.splice(this.data.indexOf(item), 1); //注意indexOf无法对reference类型数据生效。 &#125; getItems() &#123; return [...this.data]; &#125;&#125;const container1 = new DataStorage&lt;string&gt;();container1.addItem(&quot;derek&quot;);const container2 = new DataStorage&lt;number&gt;();const container2 = new DataStorage&lt;object&gt;();container1.addItem(&#123;name: &quot;derek&quot;&#125;);container1.addItem(&#123;name: &quot;tom&quot;&#125;&#125;);container1.remove(&#123;name: &quot;derek&quot;&#125;);console.log(objStorage.getItems()); //这里结果就不对了。因为remove的是一个新对象，地址和之前的不同。 在 Generic 类型可以同时表示 primitive 类型和 reference 类型参数时，有些两种类型不通用的方法就会出现问题。 解决方案是，先把 reference 类型数据（的 heap 地址）赋值给一个 primitive 数据（即在 stack 中），再操作。这样就可以按照 primitive 类型数据的方法操作了。 123456const container2 = new DataStorage&lt;object&gt;();const derekObj = &#123; name: &quot;derek&quot; &#125;;container1.addItem(derekObj);container1.addItem(&#123;name: &quot;tom&quot;&#125;&#125;);container1.remove(&#123;derekObj);console.log(objStorage.getItems()); //得到正确结果 另一个解决方案是对泛型 &lt;T&gt; 限制，让 class 只能应用于 primitive 类型。如： 1class DataStorage&lt;T extends string | number | boolean&gt;&#123;&#125; 也可以在类的方法中引入新的泛型如 &lt;U&gt;，如果这个泛型只在某个方法中需要。 Generic 和 Union type 的区别 如果想得到一个函数，每次调用它的时候多可以用这些类型中的一种来调用，union 类型就适用；如果想锁定某个类型，Generic 就适用。Generic 用于在创建的整个类实例中使用相同的类型。 123456789class DataStorage&lt;string | number | boolean&gt; &#123; private data: string[] | number[] | boolean[] = []; addItem(item: string | number | boolean) &#123; this.data.push(item); &#125; removeItem(item: string | number | boolean) &#123; this.data.splice(this.data.indexOf(item), 1); &#125;&#125; 例中使用了 union 类型。实际每次调用 addItem(item) 时都可以添加不同类型的参数。而如果用 generic 来定义，那么类就只能添加一种类型的参数。 更多泛型知识 https://juejin.cn/post/6844904184894980104 其中有反省条件类型","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Chinese notes","slug":"Others/Chinese-notes","permalink":"https://redre4per.github.io/categories/Others/Chinese-notes/"}],"tags":[{"name":"Chinese notes","slug":"Chinese-notes","permalink":"https://redre4per.github.io/tags/Chinese-notes/"}]},{"title":"Advanced types - Type Casting, index properties, Function overloads, Optional chaining, Nullish Coalescing","slug":"Others/Chinese notes/11 类型转换 索引类型 函数重载","date":"2021-01-12T00:29:31.000Z","updated":"2023-03-01T10:33:12.631Z","comments":true,"path":"2021/01/12/Others/Chinese notes/11 类型转换 索引类型 函数重载/","link":"","permalink":"https://redre4per.github.io/2021/01/12/Others/Chinese%20notes/11%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%20%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%20%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/","excerpt":"","text":"Type Casting 类型转换 类型转换可以告诉 TS 某个值属于特定类型，而 TS 自己无法检测到它。 TS 某些情况下无法检测到类型，例如 HTML 中使用 id 获取 DOM（取到的都是 HTMLElement 这种宽泛的，而不是具体哪种 element），从后端得到的数据也是。 Type Casting 的两种语法（等价）： 非 React 在值之前加 &lt;类型&gt; 来指定类型。 1const userInputElement = &lt;HTMLInputElement&gt;document.getElementById(&quot;user-input&quot;); React 使用 as 关键字来指定类型。 1const userInputElement = document.getElementById(&quot;user-input&quot;) as HTMLInputElement; 非空断言 ! ! 表示它前面的表达式永远不会产生 null。如果程序员知道这个值永远不会是 null，可以如此声明。如果不确定的话，可以使用 if 检查。 ! 也有一种代替方法。! 前的值的类型应该是 某种类型 | null，所以才需要 !。因此，如果我们用 as 将其指定为 某种类型，就可以代替 !。 123if (userInputElement) &#123; (userInputElement as HTMLInputElement).value = &quot;Hi there!&quot;;&#125; index properties 索引类型 index properties 可以用来定义对象类型中的动态属性。通常我们需要在对象类型中定义所有可能的属性，但是有些情况下，我们不知道对象会有哪些属性，或者我们需要允许用户定义任意属性。这时候可以用 index properties。 注意： index property 必须是字符串或数字类型。index property 可以单独使用作为对象中属性的唯一类型。 index property 的类型必须与对象中其他已知属性的类型一致，或者是它们的子类型。 如果对象中已经包含了某个属性，那么这个属性的类型必须与 index property 的类型相同或者是其子类型。（这是因为 index property 是对象中类型的总结） 1234567891011121314151617interface User &#123; [key: string]: string | number; name: string; age: number;&#125;const user: User = &#123; name: &#x27;Alice&#x27;, age: 30, email: &#x27;alice@example.com&#x27;, phone: 1234567890,&#125;;console.log(user.name); // Aliceconsole.log(user.age); // 30console.log(user.email); // alice@example.comconsole.log(user.phone); // 1234567890 Function overloads 函数重载 函数重载（function overloads）允许为同一个函数定义多个函数类型签名。每个函数类型签名定义了一组参数和返回值的类型，函数重载会根据传入的参数类型和个数自动选择正确的函数类型签名来执行函数。 通过函数重载，编译器在编译时就检查函数调用是否符合期望的类型，并在运行时自动选择正确的函数类型签名执行代码，从而提高代码的可读性和可维护性。 123456789function add(a: string, b: string): string;function add(a: number, b: number): number;function add(a: any, b: any): any &#123; return a + b;&#125;console.log(add(&#x27;Hello &#x27;, &#x27;World&#x27;)); // Hello Worldconsole.log(add(2, 3)); // 5 注意： 函数重载必须先声明（写在主函数正上方）。 主函数中的参数类型和返回值类型必须兼容所有的函数类型签名。 函数重载的函数类型签名可以有任意数量和任意类型的参数，只要能够区分不同的函数类型签名即可。 使用函数重载，主函数中不需要再写条件判断语句来判断参数类型，TypeScript 编译器会根据参数类型自动选择正确的函数类型签名来执行函数。 Optional chaining Optional chaining 允许开发者在访问一个可能不存在的属性或方法时，避免因为该属性或方法不存在而导致程序崩溃或出现异常的情况（例如从后端获取数据，无法保证数据完整）。使用 Optional chaining，可以在访问一个属性或方法时，添加一个问号 ?，来表示该属性或方法可能不存在，从而避免了因为不存在该属性或方法而导致的异常错误。 注意，Optional chaining 只能用于 TypeScript 3.7 以上版本。 1234// 在访问可能不存在的属性时，使用 ?. 运算符const name = obj?.person?.name;// 在调用可能不存在的方法时，使用 ?. 运算符const result = obj?.person?.getName(); Nullish Coalescing 零合并 ?? Nullish Coalescing（??） 是类似于 || 的运算符。 它们的区别是，**|| 对前一个值的判断标准是 falsy**，即：布尔值false，0，-0，&#39;&#39;空字符串，null，undefined，NaN。 ?? 对前一个值的判断标准为 null 或 undefined，而不是 false。 123const userInput = &quot;&quot;const storedData1 = userInput || &quot;DEFAULT&quot; //如果userInput为falsy，就使用后面的值。const storedData2 = userInput ?? &quot;DEFAULT&quot; //如果userInput为null或，就使用后面的值。","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Chinese notes","slug":"Others/Chinese-notes","permalink":"https://redre4per.github.io/categories/Others/Chinese-notes/"}],"tags":[{"name":"Chinese notes","slug":"Chinese-notes","permalink":"https://redre4per.github.io/tags/Chinese-notes/"}]},{"title":"Advanced types - intersection types, type Guard，Discriminated union","slug":"Others/Chinese notes/10 交叉类型 类型保护 可识别联合","date":"2021-01-11T00:29:31.000Z","updated":"2023-03-01T10:33:09.684Z","comments":true,"path":"2021/01/11/Others/Chinese notes/10 交叉类型 类型保护 可识别联合/","link":"","permalink":"https://redre4per.github.io/2021/01/11/Others/Chinese%20notes/10%20%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B%20%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4%20%E5%8F%AF%E8%AF%86%E5%88%AB%E8%81%94%E5%90%88/","excerpt":"","text":"intersection types “&amp;” intersection types 允许我们组合其他类型。使用 &amp; 来组合类型。组合后的类型包含了那些被组合类型的所有属性和方法。 123456789type Admin = &#123; name: string; privileges: string[];&#125;;type Employee = &#123; name: string; startDate: Date;&#125;type ElevatedEmployee = Admin &amp; Employee; //这个类型包含了Admin和Employee的所有属性和方法。 intersection types 和接口继承密切相关，因为可以通过使用接口实现相同功能。 123456789interface Admin &#123; name: string; privileges: string[];&#125;;interface Employee &#123; name: string; startDate: Date;&#125;interface ElevatedEmployee extends Admin, Employee &#123;&#125;; 把多个 union 类型用 intersection types 组合起来时，取交集（共有部分）。 123type Combinable = string | number;type Numeric = number | boolean;type Universal = Combinable &amp; Numeric; //type Universal = number Type Gaurd 类型保护 类型保护用于收敛类型，即把可能有多种类型的变量收敛成一个准确类型。类型保护是一个术语，它描述了在尝试使用某个属性或方法之前检测它是否存在。 typeof 的类型保护（用于检测非 object） typeof 只能对比 JS 已知的类型，即 object，string，number，boolean。TS 的自定义类型不能对比。 1234567type Combinable = string | number;function add(a: Combinable, b: Combinable) &#123; if (typeof a === &quot;string&quot; || typeof b === &quot;string&quot;) &#123; return a.toString() + b.toString(); &#125; return a + b;&#125; in 的类型保护（用于检测 object） 两个对象在 union 后，无法用 typeof 确定里面是否含有某个属性，因为类型为 object（typeof emp === &quot;object&quot;）。这里也无法检测 type 是否为自定义类型（typeof emp === &quot;Employee&quot;），因为 JS 不知道自定义类型。这是因为 typeof 在运行时使用 JS 而不是 TS，所以只能将 typeof 得到的类型和 JS 知道的类型对比。 in 关键字可以检查 TS 中禁止访问的属性。 123456789101112interface Admin &#123; name: string; privileges: string[];&#125;;interface Employee &#123; name: string; startDate: Date;&#125;type UnknownEmployee = Employee | Admin;function printEmp (emp: UnknownEmployee) &#123; if(&quot;privileges&quot; in emp)&#123; ... &#125;; //检查privileges是否是emp上的属性。&#125; instanceof 的类型保护（用于检测 object，仅限于 class 的实例，无法用于 interface） 和 in 的类型保护实现的功能类似，更优雅一些。用来检测对象是否是某个 class 的实例。如果是 interface，就不能用 instanceof 检测了。 1234567891011121314151617181920212223class Car &#123; drive()&#123; console.log(&quot;Driving&quot;) &#125;&#125;class Truck &#123; drive()&#123; console.log(&quot;Driving&quot;) &#125; loadCargo(amount: number) &#123; console.log(&quot;Loading cargo ...&quot; + amount); &#125;&#125;type Vehicle = Car | Truck; //[注]const v1 = new Car();const v2 = new Truck();function useVehicle(vehicle: Vehicle) &#123; vehicle.drive(); //共有方法 if (vehicle instanceof Truck) &#123; //检测实例 vehicle.loadCargo(1000); &#125;&#125; 注：Car 和 Truck 是两个类，但在 TypeScript 中，类也是一种 type，就像基本数据类型（如 string 和 number）和其他自定义类型一样。因此，我们可以将 Car 和 Truck 类型组合成一个联合类型 Vehicle。 Discriminated Unions 可辨识联合 Discriminated Unions （可辨识联合）是一种设计模式，可在使用 union type 时使用它，它使实现类型保护更容易。它用于 object 的类型。 两个不同类型 union 后的类型，其中通常有一些相关但不同的属性或方法。Discriminated Unions 意味着，在组成 union 的每个对象（的 type）中，都有一个公共属性，这个公共属性描述了该对象。因此我们可以在类型检测中使用这个公共属性，以实现100%的类型安全。 不使用 Discriminated Unions： 1234567interface Bird &#123; flyingSpeed: number;&#125;interface Horse &#123; runningSpeed: number;&#125;type Animal = Bird | Horse; 使用 Discriminated Unions： 12345678910111213141516interface Bird &#123; type: &quot;bird&quot;; flyingSpeed: number;&#125;interface Horse &#123; type: &quot;horse&quot;; runningSpeed: number;&#125;type Animal = Bird | Horse;function moveAnimal(animal: Animal) &#123; let speed; switch (animal.type) &#123; case &quot;bird&quot;: speed = animal.flyingSpeed; break; case &quot;horse&quot;: speed = animal.runningSpeed; break; &#125;&#125;","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Chinese notes","slug":"Others/Chinese-notes","permalink":"https://redre4per.github.io/categories/Others/Chinese-notes/"}],"tags":[{"name":"Chinese notes","slug":"Chinese-notes","permalink":"https://redre4per.github.io/tags/Chinese-notes/"}]},{"title":"interface","slug":"Others/Chinese notes/09 interface","date":"2021-01-10T00:29:31.000Z","updated":"2023-03-01T10:33:06.374Z","comments":true,"path":"2021/01/10/Others/Chinese notes/09 interface/","link":"","permalink":"https://redre4per.github.io/2021/01/10/Others/Chinese%20notes/09%20interface/","excerpt":"","text":"interface interface（接口）是一种用于描述对象形状（shape）的语法结构。它定义了对象应该具有哪些属性和方法，以及它们的类型。接口可以用来作为类型声明、函数参数、类成员等。 和类不同，interface 并不会被作为蓝图，而只是一种自定义类型。 1234567interface Person &#123; name: string; age: number; greet(phrase: string): void; //方法的写法1，函数的标准语法形式 sayHello: () =&gt; void; //方法的写法2，类型注解的形式 greet(): (phrase: string) =&gt; void //函数重载形式。表示greet函数不接受参数，但是返回一个函数。&#125; interface 和自定义类型 type 的区别 在很多时候，可以把 interface 换成 type，然后它就像以前一样工作。但是 interface 和 type 并不完全相同。 interface 只能用来描述对象的结构，type 还可以存储其他，如联合类型等。但是，当使用 interface 时，会明确的知道它时用来定义一个对象的结构。 类应该用 interface 描述，不应用 type。interface 可以被视为类必须遵守的协定。如果使用 type 来描述类，可能会丧失一些 interface 提供的一些额外的功能，例如 extends 和 implements。 使用 interface 实现类 要使用关键词 implements（实现）。实现和继承是有区别的，可以一次实现多个接口，用 , 分隔。 123456interface Greetable &#123; name: string; greet(phrase: string): void;&#125;class Person implements Greetable &#123;&#125; 类中必须包含实现的 interface 中的属性和方法，并且可以写 interface 外的属性和方法。因此，接口经常被用来在不同的类之间共享功能，而不考虑功能的具体实现（因为不能在 interface 中有实现或者值）。这有点像抽象类，但是接口没有实现细节。实现 interface，可以轻易的在子类之间共享功能，而且每个子类都要添加自己的功能实现（固定结构，不同方法）。 interface 中的 readonly 修饰符 interface 中不能添加 private 和 public 修饰符，但是可以添加 readonly。它表示在基于此接口生成的任何对象中，此属性只能设置一次，并且此后为只读。readonly 也能在 type 上使用。 如果类实现了这种接口，类中即使对应属性不写 readonly，它也不能更改。 interface 的 extends（扩展） 接口可以 extends （扩展）其他接口，与类的继承相似。 123456interface Named &#123; readonly name: string;&#125;interface Greetable extends Named &#123; greet(phrase: string): void;&#125; 接口可以扩展多个接口，用,分隔。 123interface Greetable extends Named, AnotherInterface &#123; greet(phrase: string): void;&#125; 用 interface 来定义函数结构 除了定义对象结构，interface 也能用来定义函数。（实际上自定义类型定义函数更常见） 注意参数后是 : 而不是 =&gt;。并且，这里没有添加方法名，因此是匿名函数。 12345interface MyFunc &#123; (a: number, b: number): number;&#125;const add: MyFunc = (a, b) =&gt; a + b;console.log(add(2, 3)); // Output: 5 optional 属性和方法 在 interface 和类中可以定义可选属性。在属性名称后加入 ? 即可指定选择性属性。 1234interface Named &#123; readonly name: string; outputName?: string;&#125; 可选方法的写法： 12345interface MyInterface &#123; requiredMethod(): void; optionalMethod?(): void; //函数写法1 sayHello?: () =&gt; void; //函数写法2&#125; 想把类中构造器初始化的属性被标识为 optional，需要在 constructor() 和类的属性类型声明中都用?标识（注：此处不严谨，看下一段）。 那么使用new创建实例时，参数中没有这项 optional 属性也行。 实际中这些?的关联是松散的。例如可以把 name: string 不作为 optional，而 constructor()中标识?，并在构造器中赋予默认值。只要符合逻辑即可。 123456789101112class Person implements Greetable &#123; name?: string; //使用？标识optional age: 30; constructor(n?: string)&#123; //使用？标识optional if(n) &#123; this.name = n; &#125; &#125;&#125;let user1 = mew Person(); //可以没有optional参数 TS 中的 interface 编译成 JS 代码 接口在编译成 JS 后不存在。接口是纯 TS 功能，仅在开发和编译期间可用（纯粹的开发特性）。","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Chinese notes","slug":"Others/Chinese-notes","permalink":"https://redre4per.github.io/categories/Others/Chinese-notes/"}],"tags":[{"name":"Chinese notes","slug":"Chinese-notes","permalink":"https://redre4per.github.io/tags/Chinese-notes/"}]},{"title":"Inheritance","slug":"Others/Chinese notes/08 inheritance","date":"2021-01-09T00:29:31.000Z","updated":"2023-03-01T10:33:02.218Z","comments":true,"path":"2021/01/09/Others/Chinese notes/08 inheritance/","link":"","permalink":"https://redre4per.github.io/2021/01/09/Others/Chinese%20notes/08%20inheritance/","excerpt":"","text":"继承 继承用来创建类的子类。子类拥有父类的属性和方法，同时也有子类的专属属性和方法。 继承的关键字是 extends。子类只能从一个父类中继承，这与 interface 的 implement 不同。 子类的构造器 如果子类不写构造器，子类就继承了父类的构造器。传入参数和对应属性与父类完全相同。 1234class Department &#123; constructor(private name: string, private id: string) &#123;&#125;&#125;class ITDepartment extends Department &#123;&#125; 子类有自己的构造器 当在子类中添加自己的构造函数时，必须在子类中添加 super()。super() 接受父类构造函数的参数。 在构造器中，super() 的使用要在其他代码之前。 123456789class Department &#123; constructor(private id: string, private name: string) &#123;&#125;&#125;class ITDepartment extends Department &#123; constructor(private id: string) &#123; super(id, &quot;IT&quot;); //super接收父类构造器的参数。第一个参数是变量，第二个参数子类自己是写死的。 &#125;&#125;const accounting = new ITDepartment(&quot;d1&quot;); 子类也可以在构造器中添加新的参数。 12345class ITDepartment extends Department &#123; constructor(private id: string, public admins: string[]) &#123; //添加新参数 super(id, &quot;IT&quot;); &#125;&#125; protected 修饰符 private 属性实际上只能从定义他们的类内部访问，不能从继承子类内部访问。例如： 1234567891011121314class Department &#123; private employees: string[] = []; //private constructor(private id: string, private name: string) &#123;&#125;&#125;class ITDepartment extends Department &#123; constructor(private id: string) &#123; super(id, &quot;IT&quot;); &#125; addEmployee(name: string)&#123; this.employees.push(name); //此时无法添加，因为employees属性是private。 &#125;&#125;const accounting = new ITDepartment(&quot;d1&quot;);accounting.addEmployee(&quot;derek&quot;); //此时无法添加，因为employees属性是private。 此时我们需要使用 protected 修饰符。它能保证修饰的属性&#x2F;方法不仅在该类内可用，而且在扩展该类的任何类中都可用。 getter and setter getter 和 setter 是 get 和 set 关键字。他们是为了给外部一个可以在类中赋值和取值的方式，并且还能在赋值和取值前添加逻辑，如判断等。getter 必须 return 一个值。 这里要注意的是，虽然 getter 和 setter 的属性声明时有 ()，但是在使用时是没有 () 的。这意味着 setter 和 getter 不是所为一个方法来执行，而是只像访问一个属性一样访问它。 getter 和 setter 是共用属性名的。在外部，会根据赋值还是取值自动判断是 getter 还是 setter。 123456789101112131415161718class Person &#123; private _age: number; //_age，与下面的age()不同 get age(): number &#123; return this._age; &#125; set age(newAge: number) &#123; if (newAge &lt; 0) &#123; throw new Error(&quot;Age cannot be negative.&quot;); &#125; this._age = newAge; &#125;&#125;const person = new Person();person.age = -30; // set age (will throw an error) 注意没有()console.log(person.age); // get age (will not be executed due to the error) 注意没有() static 静态方法和属性 static 关键字用于定义一个类的静态成员，即属于类本身而不是类的实例的成员。静态成员可以是方法或属性。 静态方法是一个不依赖于类的实例而直接调用的方法。静态方法可以访问静态属性和其他静态方法，但不能访问实例属性或实例方法。在 TS 中，静态方法使用 static 关键字来定义，例如： 1234567class MyClass &#123; static myStaticMethod() &#123; console.log(&quot;This is a static method.&quot;); &#125;&#125;MyClass.myStaticMethod(); 需要注意的是，静态成员不能被实例化对象所访问，只能通过类本身来访问。 静态成员也不能被类中非静态化成员访问，例如 constructor 中的 this.静态成员 就会报错。这是因为它们引用的是基于类创建的实例，而静态属性在实例上不可用。静态成员是从实例中分离出来的。如果需要从非静态成员中访问静态成员，则需要**用类名代替 this**： 1234567class Department &#123; static fiscalYear = 2020; private employees: string[] = []; constructor(private id: string, private name: string) &#123; console.log(Department.fiscalYear); //类名.静态成员 &#125;&#125; abstract 抽象类 抽象类是用 abstract 关键字定义的类。抽象类不能被实例化，只能被继承。抽象类用来强制所有派生类共享一些公共的属性和方法，并且不用在基类中提供具体的值。 抽象类可以包含抽象方法和非抽象方法。抽象方法是没有实现（即方法中没有 &#123;&#125; 部分）的方法，它们必须在派生类中实现（implementation）。非抽象方法则是有实现的方法，派生类可以选择是否重写它们。派生类必须实现所有抽象方法，否则它自己也必须是一个抽象类。 123456789101112abstract class Animal &#123; abstract makeSound(): void; //抽象方法，没有&#123;&#125; move(): void &#123; console.log(&quot;Moving...&quot;); &#125; //非抽象方法&#125;class Cat extends Animal &#123; //派生类 makeSound(): void &#123; console.log(&quot;Meow!&quot;); &#125;&#125;const cat = new Cat();cat.makeSound(); // &quot;Meow!&quot;cat.move(); // &quot;Moving...&quot; 例中，Animal 是一个抽象类，它包含了一个抽象方法 makeSound 和一个非抽象方法 move。Cat 继承了 Animal 并实现了 makeSound 方法。注意到 move 方法并没有在 Cat 中被重写，所以它继承了 Animal 中的实现。 抽象类的主要作用是为了定义一些通用的功能，并规定子类必须实现某些方法，从而提高代码的复用性和可维护性。 singleton 单例模式 和 private constructor 私有构造函数 Singleton（单例）模式是为了确保某个类始终只有一个实例，并提供全局访问点来获取该实例。 Singleton 模式的实现通常包含一个私有的构造函数，一个静态方法来获取单例实例，以及一个静态属性来保存单例实例。单例实例只能被创建一次，并在静态方法中进行管理。当需要使用单例实例时，只需调用静态方法即可。 private constructor（私有构造函数）是指只能在类的内部被调用的构造函数。私有构造函数通常用于实现单例模式或工厂模式等模式。在类的外部无法调用私有构造函数来创建类的实例，只能在类的内部使用（即确保我们不能调用 new）。 123456789101112131415161718class Singleton &#123; private static instance: Singleton; private constructor() &#123; // ... &#125; public static getInstance(): Singleton &#123; if (!Singleton.instance) &#123; Singleton.instance = new Singleton(); &#125; return Singleton.instance; &#125;&#125;const singleton1 = Singleton.getInstance();const singleton2 = Singleton.getInstance();console.log(singleton1 === singleton2); // true","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Chinese notes","slug":"Others/Chinese-notes","permalink":"https://redre4per.github.io/categories/Others/Chinese-notes/"}],"tags":[{"name":"Chinese notes","slug":"Chinese-notes","permalink":"https://redre4per.github.io/tags/Chinese-notes/"}]},{"title":"Class","slug":"Others/Chinese notes/07 Class","date":"2021-01-08T00:29:31.000Z","updated":"2023-03-01T10:32:58.880Z","comments":true,"path":"2021/01/08/Others/Chinese notes/07 Class/","link":"","permalink":"https://redre4per.github.io/2021/01/08/Others/Chinese%20notes/07%20Class/","excerpt":"","text":"Class &amp; Instances 类是对象的蓝图。对象是类的实例（Instances）。类定义了对象的样子，对象包含什么属性和方法。类使创建多个相似对象变得简单。 类是构造函数的语法糖。 在 TypeScript 中，class 也是一种 type，就像基本数据类型（如 string 和 number）和其他自定义类型一样。因此，我们可以将多个 class 组合成一个联合类型 。 类的概念： 类（Class）：定义了一件事物的抽象特点，包含它的属性和方法 对象（Object）：类的实例，通过 new 生成 面向对象（OOP）的三大特性：封装、继承、多态 封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据 继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性 多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 Cat 和 Dog 都继承自 Animal，但是分别实现了自己的 eat 方法。此时针对某一个实例，我们无需了解它是 Cat 还是 Dog，就可以直接调用 eat 方法，程序会自动判断出来应该如何执行 eat 存取器（getter &amp; setter）：用以改变属性的读取和赋值行为 修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法 抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现 接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口 Class 写法 类名首字母大写。 构造器方法：constructor 是关键字。它本质上是一个绑定到该类的函数，并绑定到基于类创建的任何对象，并且在类创建对象时执行。它用来为构建的对象做一些初始化工作。构造器利用 this 把参数储存到类的属性中。 1234567class Department &#123; name: string; //此处可以name: string = &quot;default&quot;;来赋初始值，但是一般不这么做，而是用构造器。 constructor(n: string) &#123; this.name = n; //把参数储存在属性name中。 &#125;&#125; 创建类的实例：使用关键字new，传入 constructor 中要求的参数即可。 1const accounting = new Department(&quot;Accounting&quot;); TS 和 JS 中类的区别 ES6 版本的 JS TS 中先声明属性的类型，再使用构造器把参数传入赋值给属性。而 JS 中并不用声明属性类型，因此属性也不提前声明。 1234567&quot;use strict&quot; //编译后的JS代码class Department &#123; //没有name: string;这一行 constructor(n: string) &#123; this.name = n; &#125;&#125;const accounting = new Department(&quot;Accounting&quot;); ES5 版本的 JS ES5 的 JS 中没有 class。因此变成了构造函数。 12345678&quot;use strict&quot;var Department = (function () &#123; function Department(n) &#123; this.name = n; &#125; return Department;&#125;)var accounting = new Department(&quot;Accounting&quot;); TS 中的 this 要从类内部引用类的属性或者方法，必须使用 this 关键字。 TS 可以通过给类中方法声明 this 指向，如 describe(this: Department)&#123;&#125;，来改变 this 默认指向。 在 JS 中，this 指向函数调用时所在的对象。函数一定是由对象调用的。例如： 123456789101112class Department &#123; name: string; constructor(n: string) &#123; this.name = n; &#125; describe()&#123; console.log(&quot;Department: &quot; + this.name); &#125;&#125;const accounting = new Department(&quot;Accounting&quot;);const accountingCopy = &#123; describe: accounting.describe &#125;;accountingCopy.describe(); //输出为Department: undefind。因为this指向accountingCopy。 而在 TS 中，在方法 describe(this: Department)&#123;&#125; 中的 this，总会指向 Department 的实例。 123456789101112class Department &#123; name: string; constructor(n: string) &#123; this.name = n; &#125; describe(this: Department)&#123; //让this指向department的实例 console.log(&quot;Department: &quot; + this.name); &#125;&#125;const accounting = new Department(&quot;Accounting&quot;);const accountingCopy = &#123; describe: accounting.describe &#125;;accountingCopy.describe(); //此时这里会报错。因为describe()方法中的this找不到accountingCopy的name属性 如果把 accountingCopy的对象中加入 name 属性，代码即可正常运行。 12const accountingCopy = &#123; name: &quot;DUMMY&quot;, describe: accounting.describe &#125;;accountingCopy.describe(); //输出为Department: DUMMY。 private 和 public 修饰符 类中的属性和方法，默认情况下，是可以从外部访问的（即默认 public）。 例如，类中有一个数组，并且类中有修改这个数组的方法： 123456class Department &#123; employees: string[] = []; addEmployee(employee: string) &#123; this.employees.push(employee); &#125;&#125; 此时如果我们创建一个实例并且写 accounting.employees[2] = &quot;Anna&quot;，实例中的 employees 属性也是能够被修改的。但是这不规范，容易引发错误。我们希望的是在外部只能通过调用类中方法 addEmployee() 来修改数组。 因此，此时就需要用到 private 属性。 此时 employees 属性只能从类内部访问。 123456class Department &#123; private employees: string[] = []; addEmployee(employee: string) &#123; this.employees.push(employee); &#125;&#125; 注意类中的方法也可以被标记为 private。 1234567891011121314class Example &#123; private doSomethingPrivate() &#123; console.log(&#x27;This is a private method.&#x27;); &#125; public doSomethingPublic() &#123; console.log(&#x27;This is a public method.&#x27;); this.doSomethingPrivate(); // 可以在公共方法中调用私有方法 &#125;&#125;const example = new Example();example.doSomethingPublic(); // 可以调用公共方法example.doSomethingPrivate(); // 不能调用私有方法 类实例初始化的简写 在上面的代码中，初始化一个属性我们需要指定类中属性的类型，之后在构造器中用 this 把参数传入初始值： 12345678class Department &#123; private name: string; id: string; constructor(n: string, i: string) &#123; this.name = n; this.id = i; &#125;&#125; 这么写很繁琐。可以把构造器中的赋值，和类中的属性声明都去掉，在构造器参数中一次性完成所有操作。这时参数依然会传入，并且在传入后把值存储在创建的属性中。简化为： 123class Department &#123; constructor(private name: string, public id: string) &#123;&#125;&#125; 这里需要注意，此时 public 不能省略。因为这是一个显式的 TS 指令，它告诉 TS 你不仅要在构造函数中得到这些参数，还要用完全相同的名字为这个类创建属性。 readonly 修饰符 用来标识某些字段在初始化之后不能更改。例如： 123class Department &#123; constructor(private name: string, public readonly id: string) &#123;&#125;&#125; readonly 也可以用于 interface 中。在接口中使用 readonly 关键字可以将某个属性标记为只读属性，该属性的值只能在对象初始化时或在构造函数中进行设置，不能在对象创建后再次修改。","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Chinese notes","slug":"Others/Chinese-notes","permalink":"https://redre4per.github.io/categories/Others/Chinese-notes/"}],"tags":[{"name":"Chinese notes","slug":"Chinese-notes","permalink":"https://redre4per.github.io/tags/Chinese-notes/"}]},{"title":"Funtion types","slug":"Others/Chinese notes/06 Function types","date":"2021-01-07T00:29:31.000Z","updated":"2023-03-01T10:32:55.495Z","comments":true,"path":"2021/01/07/Others/Chinese notes/06 Function types/","link":"","permalink":"https://redre4per.github.io/2021/01/07/Others/Chinese%20notes/06%20Function%20types/","excerpt":"","text":"函数的类型 函数除了参数有类型外，函数的本身（返回结果）也有类型。 函数返回结果类型 TS 也会推断。如果没有明确设定类型的特别理由，就不应该显式设定类型，最好用 TS 推断。 函数显式声明类型的方法为： 123function add(n1: number, n2: number): number &#123; return n1 + n2;&#125; 如果 return 的结果和显式声明的类型不匹配，TS 就会报错。 void， undefined 不 return 任何值的函数，类型为 void（不需要显示声明）。 void 类型和 TS 中的 undefined 类型是有区别的。void 类型标识函数没有 return 语句，undefined 类型表示函数返回时没有返回实际值，如 return;（即有返回语句，但是不返回一个值）。 函数变量的类型 有的时候我们可以把函数赋给一个变量。这时这个变量的类型就是一个函数。 123456function add(n1: number, n2: number): number &#123; return n1 + n2;&#125;let combineValue: (a: number, b:number) =&gt; number;combineValue = add 函数变量类型写法就是一个箭头函数。参数类型和返回类型都要写。 回调函数的类型 函数的参数也可以是函数，即回调函数。类型写法： 1234567891011function addAndHandle(n1: number, n2: number, cb: (number) =&gt; void) &#123; const result = n1 + n2; cb(result);&#125;addAndHandle(10, 20, (result) =&gt; &#123; console.log(result);&#125;);addAndHandle(10, 20, (result) =&gt; &#123; console.log(result); return result; //不报错&#125;); 这里需要注意的时，主函数中回调函数类型为 void 时，如果让回调函数有return语句并返回值，并不会报错。回调函数的 void 类型代表回调函数返回的任何值都不会被主函数使用。因此无法用在主函数中用 const result2 = cb(result) 获得数据。 箭头函数的类型 箭头函数的类型可以使用函数类型注解，即 (params) =&gt; returnType，例如： 123type MyFunc = (a: number, b: number) =&gt; number;const add: MyFunc = (a, b) =&gt; a + b;console.log(add(2, 3)); // Output: 5 函数的接口写法： 12345interface MyFunc &#123; (a: number, b: number): number;&#125;const add: MyFunc = (a, b) =&gt; a + b;console.log(add(2, 3)); // Output: 5","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Chinese notes","slug":"Others/Chinese-notes","permalink":"https://redre4per.github.io/categories/Others/Chinese-notes/"}],"tags":[{"name":"Chinese notes","slug":"Chinese-notes","permalink":"https://redre4per.github.io/tags/Chinese-notes/"}]},{"title":"Types - any, unknown, never","slug":"Others/Chinese notes/05 Types - any, unknown, never","date":"2021-01-06T00:29:31.000Z","updated":"2023-03-01T10:32:52.485Z","comments":true,"path":"2021/01/06/Others/Chinese notes/05 Types - any, unknown, never/","link":"","permalink":"https://redre4per.github.io/2021/01/06/Others/Chinese%20notes/05%20Types%20-%20any,%20unknown,%20never/","excerpt":"","text":"any any 类型是 TS 中指定的最灵活的类型，any 基本上确保 TS 编译器不能检查任何东西。但 any 也剥夺了 TS 带来的所有好处，应该尽量避免。 unknown unknown 比 any 严格一些。把一个未知类型的值赋给一个固定类型的值时，unknown 比 any 更好。它们的区别是： 可赋值性 any 类型的值可以被赋值给任何类型的变量，也可以将任何类型的值赋给 any 类型的变量，这意味着 any 类型可以轻松地与其他类型进行交互。 unknown 类型的值不能直接赋值给其他类型的变量，也不能将其他类型的值直接赋值给 unknown 类型的变量，需要进行类型检查或类型断言后才能进行赋值。 123456let userInput: unknown;let userName: string;userInput = 5;userInput = &quot;Derek&quot;;userName = userInput; //报错。如果userInput类型为any就不会报错。 类型推断 当使用 any 类型时，TypeScript 不会对该变量或值进行类型检查或类型推断，这意味着 any 类型可能会掩盖潜在的类型错误。 当使用 unknown 类型时，TypeScript 会对该变量或值进行类型检查和类型推断，这可以帮助开发人员更好地捕捉潜在的类型错误。 类型安全 在使用 any 类型时，TypeScript 编译器不会强制执行类型检查，这可能会导致潜在的运行时错误。 在使用 unknown 类型时，TypeScript 编译器会强制执行类型检查，这可以帮助开发人员避免潜在的运行时错误。 综上所述，any 和 unknown 类型的主要区别在于可赋值性、类型推断和类型安全方面的不同。在 TypeScript 中，应尽量避免使用 any 类型，而应该使用 unknown 类型，并在必要时进行类型检查或类型断言。 never Never 是函数的类型。它表示函数从不生成返回值，比如函数直接抛出错误等。抛出错误会导致脚本崩溃，所以从不生成返回值。 123function generateError(message: string, code: number): never &#123; throw &#123;message: message, errorCode: code&#125;;&#125;","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Chinese notes","slug":"Others/Chinese-notes","permalink":"https://redre4per.github.io/categories/Others/Chinese-notes/"}],"tags":[{"name":"Chinese notes","slug":"Chinese-notes","permalink":"https://redre4per.github.io/tags/Chinese-notes/"}]},{"title":"Types - union, literal, custom/aliases","slug":"Others/Chinese notes/04 Types - union, literal, aliases","date":"2021-01-05T00:29:31.000Z","updated":"2023-03-01T10:32:49.411Z","comments":true,"path":"2021/01/05/Others/Chinese notes/04 Types - union, literal, aliases/","link":"","permalink":"https://redre4per.github.io/2021/01/05/Others/Chinese%20notes/04%20Types%20-%20union,%20literal,%20aliases/","excerpt":"","text":"union 联合类型 写法为 参数: 类型1|类型2|类型3...。表示参数可以赋这些类型的值。如： 123function combine(input1: string | number, input2: string | number)&#123; const result = input1 + input2; //报错&#125; 例子中，无法在函数内直接写 const result = input1 + input2，这是因为 TS 不会分析联合类型中有什么，因此无法检测这些值是否能进行 + 运算。因此要自己在函数内写 if(typeof ...) 类型检测代码。 union 类型的使用场景通常是，让函数可以更灵活地接收参数，但随后会根据所获取的确切类型在函数中使用不同的逻辑。这样函数就可以处理多种不同类型的值了。但这也不是必须的。也会出现使用 union 但不做后续类型判断的场景，这取决于函数逻辑。 union 可以用来联合 type, class 和 interface。因为它们在 TS 中都是 type。联合后可以用 type a = 取值。 Literal 字面量类型 字面量类型是以联合类型为基础的。Literal 类型表示，变量不只是类型是确定的，可选值也是确定的。 在常量的TS自动推断中，结果并不是某个类型，而是一个固定数值，如： 1const number2 = 2.8 //推断结果为const number2: 2.8 在联合类型例子的函数中，如果我们想加入第三个参数来标识结果类型，并且第三个参数是字符串，按照之前的写法我们就要在函数加入很多判断： 123456function combine(input1: string | number, input2: string | number, result: string)&#123; if(result === &quot;as-number&quot;)&#123;...&#125;; if(result === &quot;as-string&quot;)&#123;...&#125;;&#125;const combinedAges = combine(30, 26, &quot;as-number&quot;);const combinedString = combine(&quot;Hello&quot;, &quot;World&quot;, &quot;as-string&quot;); 这里的缺陷是，在调用函数时输入第三个参数 &quot;as-number&quot; 或 &quot;as-string&quot;，必须保证没有拼写错误。我们可以用 enum 来改进，但是如果这里只有两个可能的值，Literal 类型就是一个好的选择。如： 12345678function combine( input1: string | number, input2: string | number, result: &quot;as-number&quot; | &quot;as-string&quot;)&#123; if(result === &quot;as-number&quot;)&#123;...&#125;; if(result === &quot;as-string&quot;)&#123;...&#125;;&#125; 这样的话我们只允许这两个字符串作为参数，而不是任何字符串。此时，如果我们在使用 result 值让其等于其他 string，TS 会直接报错。 Custom types 自定义类型 &#x2F; Type Aliases 类型别名 TS 支持给类型起其他名字。需要使用关键字 type，并且自定义类型首字母要大写。如： 1type Combinable = number; //此后所有number类型都能用Combinable类型代替。无意义。 通常情况下，自定义类型可以和 union &#x2F; literal 类型结合使用。 12type Combinable = number | string; //此后所有 number | string 都可用 Combinable 代替。type ResultDescription = &quot;as-number&quot; | &quot;as-string&quot;; 自定义类型非常有用，它把类型编码到程序员自己的类型名称中，并在之后的代码中复用。类似于提取函数。 Custom types 用于对象类型 自定义类型也能用于对象类型。如： 12type User = &#123; name: string; age: number &#125;;const u1: User = &#123; name: &#x27;Max&#x27;, age: 30 &#125;; // this works! 或者简化代码： 12345678910111213141516171819/////////////////////简化前////////////////////function greet(user: &#123; name: string; age: number &#125;) &#123; console.log(&#x27;Hi, I am &#x27; + user.name);&#125; function isOlder(user: &#123; name: string; age: number &#125;, checkAge: number) &#123; return checkAge &gt; user.age;&#125;//////////////////////简化后////////////////////type User = &#123; name: string; age: number &#125;; function greet(user: User) &#123; console.log(&#x27;Hi, I am &#x27; + user.name);&#125; function isOlder(user: User, checkAge: number) &#123; return checkAge &gt; user.age;&#125; 它和 interface 非常类似，一般被 interface 代替。","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Chinese notes","slug":"Others/Chinese-notes","permalink":"https://redre4per.github.io/categories/Others/Chinese-notes/"}],"tags":[{"name":"Chinese notes","slug":"Chinese-notes","permalink":"https://redre4per.github.io/tags/Chinese-notes/"}]},{"title":"Types - Array, Tuple, Enum","slug":"Others/Chinese notes/03 Types - array, tuple, enum","date":"2021-01-04T00:29:31.000Z","updated":"2023-03-01T10:32:46.419Z","comments":true,"path":"2021/01/04/Others/Chinese notes/03 Types - array, tuple, enum/","link":"","permalink":"https://redre4per.github.io/2021/01/04/Others/Chinese%20notes/03%20Types%20-%20array,%20tuple,%20enum/","excerpt":"","text":"TS 对数组的支持 数组类型写法为 数组名: 数组中数据类型[]，如 hobbies: string[]。在对象内外使用数组是完全一样的。 另一种写法是 Array&lt;类型&gt;，例如 hobbies: Array&lt;string&gt;。这两种写法是等价的。 如果给数组赋了初始值（而不是空数组），TS 也会自动推断数组类型。如： 1234const person = &#123; name: &quot;Derek&quot;, hobbies: [&quot;Sport&quot;, &quot;Cooking&quot;] //TS会推断类型为hobbies: string[]&#125;; TS 中数组不能是混合类型的 在 TS 中如果给数组定义了一个类型，就无法给它添加其他类型的元素。如果想让一个数组中包含不同类型的元素，解决方案有： 给数组赋 any 类型。any 很灵活，但是放弃了 TS 提供的所有好处。 12let activities: any[];activities = [&quot;Sports&quot;, 1]; 元组 联合类型数组 Tuple 元组 元组是固定长度并且固定类型的数组。元组是 TS 添加的。类型写法为 role: [number, string];。 12345const person = &#123; name: &quot;Derek&quot;, hobbies: [&quot;Sport&quot;, &quot;Cooking&quot;], role: [2, &quot;author&quot;] //元组，TS推断类型为role:(string | number)[]，这是联合类型不是元组&#125;; 可以看到 TS 推断的结果是联合类型数组，而不是元组。这种数组长度不固定，可以向其继续添加元素，修改某个元素类型等。因此元组类型需要显示设置。 123456789const person: &#123; name: string; hobbies: string; role: [number, string]; //元组类型的写法。&#125; = &#123; name: &quot;Derek&quot;, hobbies: [&quot;Sport&quot;, &quot;Cooking&quot;], role: [2, &quot;author&quot;]&#125;; 元组中每个位置元素的赋值只是能元组声明的类型。例如上面的元组中，如果赋值 1234person.role[0] = &quot;Derek&quot;; //报错person.role[1] = 10; //报错person.role = [0, &quot;admin&quot;, &quot;user&quot;]; //报错person.role.push(&quot;user&quot;); //不报错 前面三种都是错误的。但是 push() 不受元组限制。 Enum 枚举 Enum 约定以大写字母开头。因为枚举也是一个自定义类型。枚举可以列出所有变量可能的值。 1enum Role &#123; ADMIN, READ_ONLY, AUTHOR &#125;; Enum 会自动把值标识为数字。默认数字就是值在数组中的 index。当鼠标 hover 在 enum 中值时，会显示 (enum member) Role.AUTHOR = 2 。 也可以不使用默认数字标识，手动分配： 1enum Role &#123; ADMIN = 5, READ_ONLY = 100, AUTHOR = 200&#125;; 如果只手动分配了第一个值的数字标识，后面的值会自动分配递增数字标识。手动分配的标识也可以不是数字。也可以混合。如： 1enum Role &#123; ADMIN = &#x27;my_admin&#x27;, READ_ONLY = 100, AUTHOR = 200&#125;; 使用枚举值时用法是： 1let role = Role.ADMIN; //会得到元组值的标识值，如my_admin。","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Chinese notes","slug":"Others/Chinese-notes","permalink":"https://redre4per.github.io/categories/Others/Chinese-notes/"}],"tags":[{"name":"Chinese notes","slug":"Chinese-notes","permalink":"https://redre4per.github.io/tags/Chinese-notes/"}]},{"title":"Types - primitive, object","slug":"Others/Chinese notes/02 Types - primitive, object","date":"2021-01-03T00:29:31.000Z","updated":"2023-03-01T10:32:42.769Z","comments":true,"path":"2021/01/03/Others/Chinese notes/02 Types - primitive, object/","link":"","permalink":"https://redre4per.github.io/2021/01/03/Others/Chinese%20notes/02%20Types%20-%20primitive,%20object/","excerpt":"","text":"Core Types primitive types：number, string, boolean reference types：object, Array TS 专属 typs：Tuple, Enum, any primitive types 在 TS 中写法就是，参数: 类型，如 n1: number。 Type Casting 大小写问题 在 TS 中，core primitive types 永远都是小写，如 string，number 等。不会出现 String，Number 等。 TS 的类型推断 123const number1 = 5;const printResult = true;const string1 = &quot;Result is: &quot;; 上面代码为什么没有写类型呢？如写成： 1234const number1: number = 5;const printResult: boolean = true;const string1: string = &quot;Result is: &quot;;//可以这么写，但是多余的，也不是一个好做法。 这是因为 TS 有一个内置特性，叫做类型推断（Type inference）。这意味着 TS 理解变量和常量，因为程序员用了一个数字&#x2F;布尔值&#x2F;字符串来初始化变量&#x2F;常量。鼠标 hover 到变量上方就能看到推断的类型。 只有不初始化变量&#x2F;常量时，才需要手动写类型，如： 1let number2: number; TS 对于对象类型的支持 TS 会推断对象类型。即对于对象中的属性，有类型推断。 如果想使用一个对象中没有的属性，TS 会直接报错， 如果手动给对象设置类型，如只设置为 object 而不写对象内部属性类型，使用对象中现有属性也会报错： 12345const person: object = &#123; name: &quot;Derek&quot;, age: 18&#125;;console.log(person.name); //报错 因此，手动设置对象类型，应该写为： 1234567const person: &#123; name: string; age: number;&#125; = &#123; name: &quot;Derek&quot;, age: 18&#125;; //正确的写法 Nested objects 遇到 nested object，类型直接一层层嵌套即可。 123456789&#123; id: string; price: number; tags: string[]; details: &#123; title: string; description: string; &#125;&#125;","categories":[{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Chinese notes","slug":"Others/Chinese-notes","permalink":"https://redre4per.github.io/categories/Others/Chinese-notes/"}],"tags":[{"name":"Chinese notes","slug":"Chinese-notes","permalink":"https://redre4per.github.io/tags/Chinese-notes/"}]},{"title":"Typescript Introduction","slug":"Others/Chinese notes/01 TS介绍","date":"2021-01-02T00:29:31.000Z","updated":"2023-09-11T01:42:43.654Z","comments":true,"path":"2021/01/02/Others/Chinese notes/01 TS介绍/","link":"","permalink":"https://redre4per.github.io/2021/01/02/Others/Chinese%20notes/01%20TS%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"What is TypeScript TS is a superset of JavaScript. TS takes JS and adds new features and syntax to it. TS cannot be executed directly in JS environment (such as browser, node.js). TS is a programming language and a tool. It is a powerful compiler that compiles TS code into JS code. That is, the programmer writes TS code with all the new features and all the benefits, and the result is normal JS code. TS gives programmers the opportunity to find errors in their code while the browser is running, before the script is run. In other words, TS provides additional error checking during project development (compliation). This catches and fixes errors early on. JS can only find errors at runtime. TypeScript overview Types: Many mistakes can be avoided. Next-gen JS features: Use modern JS features and still generate and publish code that works in older browsers. TS-specific features: such as interfaces and Generics (generics). Meta-Programming features: such as Decorators. Rich Configuration Option: TS can be configured and fine-tuned according to requirements to make it more strict or loose. Can be supported in non-TS projects: via modern tools and modern IDEs. Why use TypeScript Since JS variables&#x2F;constants have no type restrictions, the code execution results may be completely different from the original intention. For example: 12345function add(num1, num2)&#123;return num1 + num2;&#125;console.log(add(&#x27;2&#x27;, &#x27;3&#x27;)) //The result is 23 because it is string concatenation.console.log(add(input1.value, input2.value)) //This will make the error more subtle. If you want to solve this problem through JS, you need to add an if conditional judgment to verify the incoming parameters. But using TS, you can find errors while writing code. 12345function add(num1: number, num2: number)&#123;return num1 + num2;&#125;console.log(add(&#x27;2&#x27;, &#x27;3&#x27;)) //Report an error directly at this timeconsole.log(add(+input1.value, +input2.value)) Unary plus operator (+) In JavaScript, you can convert a value to a number using the unary plus operator (+). When the unary plus operator is used before a non-numeric value, JavaScript attempts to convert the value to a number. If the value cannot be converted to a number, NaN is returned. So if you use +input.value in JavaScript, it will try to convert the value of the input element (usually a string) to a numeric type. This can be used to ensure that the value obtained from the input element is of numeric type, rather than a string type, so that correct numerical calculations can be performed in subsequent calculations. A website that can convert TS code into JS code typescriptlang.org","categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"TypeScript","slug":"JS-TS/TypeScript","permalink":"https://redre4per.github.io/categories/JS-TS/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://redre4per.github.io/tags/TypeScript/"}]},{"title":"Create new project with Next.js","slug":"Others/Chinese notes/00 Create new project","date":"2021-01-01T00:29:31.000Z","updated":"2023-09-11T01:39:09.731Z","comments":true,"path":"2021/01/01/Others/Chinese notes/00 Create new project/","link":"","permalink":"https://redre4per.github.io/2021/01/01/Others/Chinese%20notes/00%20Create%20new%20project/","excerpt":"","text":"Packages and plug-ins to be installed in the project next.js engine locking eslint prettier lint-staged vs config testing (jest, cypress) git hooks (husky) conventional commit UI (chakra ui) tailwind daisyUI redux tool kit storybook Next.js It’s in the official documentation. npx create-next-app@latest Then just keep selecting the default option. Next.js contains many settings, such as ESlint and jest related content (written in the document). **When asked for the name, enter . to create the project in the current folder. ** Engine locking In the Next.js project configuration, engine locking is an option that controls whether Next.js should lock the version of the Node.js engine used. When the engine locking option is enabled, Next.js will lock on the Node.js engine version used in the project, which ensures that the same Node.js version is used when building and running the application. This can help avoid issues caused by differences between different versions of the Node.js engine, making applications more stable and reliable. In Next.js’s project configuration, “engine locking” is an option that controls whether Next.js should lock the version of the Node.js engine used. Specifically, when the engine locking option is enabled, Next.js will lock on the Node.js engine version used in the project, which ensures that the same Node.js version is used when building and running the application. This can help avoid issues caused by differences between different versions of the Node.js engine, making applications more stable and reliable. Engine locking is inside webpack. Documentation can be found in npm docs under engines. In the project, you can add the code after the script in package.json: 123456&quot;engineStrict&quot;: true, &quot;engines&quot;: &#123; &quot;node&quot;: &quot;&gt;=14.0.0&quot;, &quot;npm&quot;: &quot;&gt;=8.0.0&quot;, &quot;yarn&quot;: &quot;please-use-npm&quot; //It is forbidden to use yarn &#125;, eslint ESLint can be found in the Next.js documentation. If you use Next.js, it is already installed. eslint has also been set in the script of package.json. The difference between lint and prettier is that prettier beautifies the code, while lint makes the code comply with the rules. The lint config file is in .eslintrc.json. After installing prettier, you need to write new rules here. prettier It can be found in Next.js documentation. 12npm install --save-dev --save-exact prettiernpm install --save-dev eslint-config-prettier After installation, add the following code in .eslintrc.json. Note that there is an order of addition, and it needs to be added after &quot;next/core-web-vitals&quot;. 12&#123; &quot;extends&quot;: [&quot;next&quot;, &quot;prettier&quot;] &#125; //Added content&#123; &quot;extends&quot;: [&quot;next/core-web-vitals&quot;, &quot;next&quot;, &quot;prettier&quot;] &#125; //After adding After that, add a comment to the scripts in package.json: 1&quot;prettier&quot;: &quot;prettier --write .&quot; **Then run npm run prettier to automatically beautify the code. **The actual instruction executed here is npm run prettier --write .. lint-staged Sometimes I want to upload code, but not all files comply with lint. If lint-staged is not installed, all files must meet the requirements of lint. If lint-staged is present, only staged files need to meet lint requirements. That is, in addition to the changes in commit, there is one more staged changes. 1npm install --save-dev lint-staged vsconfig The file should be created in the .vscode folder in the root directory and named settings.json. You can set part of it in the preference-setting of vscode app. For example, change Files: Auto Save to afterDelay. Can be set in settings.json: 1234&#123; &quot;editor.formatOnSave&quot;: true, //Automatically format code when saving a file &quot;default.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;&#125; At this time, prettier will be used to automatically adjust the format when the entire project is saved. I tried it and found that I can’t automatically use prettier to change the format when I write it this way. But when I delete the line “editor.defaultFormatter”: “esbenp.prettier-vscode”, I can automatically use prettier to change the format. What could be the reason for this? This issue may be caused by a conflict between VS Code’s default formatter and the Prettier plugin. The “editor.defaultFormatter” setting specifies the default formatter, but if another formatter (such as the VS Code default formatter) is registered earlier than Prettier, then it will be used to format the code instead of Prettier. . Testing Next.js has a lot of testing integrated into it. So just click Document to install it. If you use react instead of next, you need to set up a lot more settings. Jest Install Jest: 1npm install --save-dev jest jest-environment-jsdom @testing-library/react @testing-library/jest-dom Then follow the document, create the jest.config.js file in the directory, and paste the content in the document. This document also contains content such as Handling stylesheets and image imports under testing. Then add the command to scripts in package.json: 1&quot;test&quot;: &quot;jest --watch&quot; Create test file: According to the documentation, create the file in the root directory: __tests__/index.test.jsx. Cover rate and the like need to be set in the jest.config.js file. See the jest documentation. Cypress Install Cypress 1npm install --save-dev cypress Then add in package.json scripts: 1&quot;cypress&quot;: &quot;cypress open&quot; There is also how to write cypress in the documentation. git hooks (husky) and conventional commit conventional commit Conventional commit is so that the commit must meet certain rules, such as fix(server): send cors headers. Install: 1npm install --save-dev @commitlint/config-conventional @commitlint/cli Then use the commands in the documentation to create the commitlint.config.js file: 1echo &quot;module.exports = &#123;extends: [&#x27;@commitlint/config-conventional&#x27;]&#125;&quot; &gt; commitlint.config.js Note: The file created in this way is not in utf-8 format, and an error will always be reported when using husky pre-commit. You need to create one with an empty notepad, write the statement and save it as a file in utf-8 format. git hooks (husky) Git hook (husky) is a Git client hook tool that allows developers to execute some custom scripts before or after Git events occur. By using Git hooks, code specification checking, unit testing, code packaging, automatic deployment and other operations can be completed automatically, improving development efficiency and reducing errors. Common Git hooks include pre-commit, post-commit, pre-push, etc. Among them, pre-commit is executed before the code is submitted and can be used to check code style, run unit tests and other operations; post-commit is executed after the code is submitted and can be used to update documents, send emails and other operations; pre-push is Executed before code push, it can be used to check code quality, run end-to-end tests, etc. Install and activate. After activation, the .husky folder will appear: 12npm install husky --save-devnpx husky install Then follow the documentation to add a hook, and in Husky’s own documentation, find and install another Hook: 12npx husky add .husky/commit-msg &#x27;npx --no -- commitlint --edit $&#123;1&#125;&#x27;npx husky add .husky/pre-commit &quot;npm test&quot; Since there is no need to let it run for the time being, use # to comment out npm test in the pre-commit file in .husky: 123#!/usr/bin/env sh. &quot;$(dirname -- &quot;$0&quot;)/_/husky.sh&quot;# npm test At this time, if the text does not comply with the rules during commit, husky will prompt an error. Finally, set the pre-commit check item. First add in scripts in package.json: 1&quot;pre-commit&quot;: &quot;npm run prettier &amp;&amp; npm run lint &amp;&amp; npm run test&quot; At this time, you may need to change the original &quot;test&quot;: &quot;jest --watch&quot; to &quot;test&quot;: &quot;jest&quot;. Then write in the .husky&#x2F;pre-commit file 1npm run pre-commit **If there is a problem with husky and it is stuck and cannot be submitted, you should use git commit --no-verify -m &quot;xxx&quot; to temporarily block husky. ** Tailwind Follow documentation to install tailwind. Here -D and -dev are the same. 12npm install -D tailwindcss postcss autoprefixernpx tailwindcss init -p Then follow the documentation to replace the content in the tailwind.config.js file with: (The following may not be the latest, please refer to the documentation) 123456789101112131415/** @type &#123;import(&#x27;tailwindcss&#x27;).Config&#125; */module.exports = &#123; content: [ &quot;./app/**/*.&#123;js,ts,jsx,tsx&#125;&quot;, &quot;./pages/**/*.&#123;js,ts,jsx,tsx&#125;&quot;, &quot;./components/**/*.&#123;js,ts,jsx,tsx&#125;&quot;, // Or if using `src` directory: &quot;./src/**/*.&#123;js,ts,jsx,tsx&#125;&quot;, ], theme: &#123; extend: &#123;&#125;, //The content of design system is written here. Documentation: https://tailwindcss.com/docs/theme &#125;, plugins: [],&#125; Then delete the contents of the globals.css file and replace it with: 123@tailwind base;@tailwind components;@tailwind utilities; Then set tailwind Automatic IntelliSense in the .vscode&#x2F;settings.json file (requires the Tailwind CSS IntelliSense plug-in to be installed): 123456&quot;editor.quickSuggestions&quot;: &#123; &quot;strings&quot;: true&#125;,&quot;tailwindCSS.experimental.classRegex&quot;: [ &quot;([\\&quot;&#x27;])(?:tw|tw-s|tw-state)\\\\(([^)]+)\\\\1&quot;] daisyUI daisyUI is a plug-in for tailwind. Install: 1npm i daisyui Then add daisyui in the tailwind.config.js file. 1234module.exports = &#123; //... plugins: [require(&quot;daisyui&quot;)],&#125; Redux-toolkit Install according to Documentation. 12npm install @reduxjs/toolkitnpm install react-redux According to document, you need to install it in store&#x2F;store.ts (the document says app&#x2F;store.js): 12345678910import &#123; configureStore &#125; from &#x27;@reduxjs/toolkit&#x27; export const store = configureStore(&#123; reducer: &#123;&#125;,&#125;) // Infer the `RootState` and `AppDispatch` types from the store itselfexport type RootState = ReturnType&lt;typeof store.getState&gt;// Inferred type: &#123;posts: PostsState, comments: CommentsState, users: UsersState&#125;export type AppDispatch = typeof store.dispatch Finally, install the provider in _app.tsx under the pages folder (if there is a UI package outside the component, the provider must be outside the UI): 12345678910import &#123; store &#125; from &#x27;../store/store&#x27;; //provider relatedimport &#123; Provider &#125; from &#x27;react-redux&#x27;; //provider related export default function App(&#123; Component, pageProps &#125;: AppProps) &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;Component &#123;...pageProps&#125; /&gt; &lt;/Provider&gt; )&#125; Storybook There are a lot of configurations required to use storybook and tailwind together, please refer to Document, Video. Other settings There are also some other settings for cc-app later in the video. Among the more useful ones are: .eslintignore Some officially recommended plugins in .eslintrc and some tips in rules. .prettierignore Set prettier rules in .prettierrc …","categories":[{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"Next.js","slug":"Front-end/Next-js","permalink":"https://redre4per.github.io/categories/Front-end/Next-js/"}],"tags":[{"name":"Next.js","slug":"Next-js","permalink":"https://redre4per.github.io/tags/Next-js/"}]}],"categories":[{"name":"JS/TS","slug":"JS-TS","permalink":"https://redre4per.github.io/categories/JS-TS/"},{"name":"ES6","slug":"JS-TS/ES6","permalink":"https://redre4per.github.io/categories/JS-TS/ES6/"},{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/categories/Test/"},{"name":"React-testing-library","slug":"Test/React-testing-library","permalink":"https://redre4per.github.io/categories/Test/React-testing-library/"},{"name":"Others","slug":"Others","permalink":"https://redre4per.github.io/categories/Others/"},{"name":"Stripe payment","slug":"Others/Stripe-payment","permalink":"https://redre4per.github.io/categories/Others/Stripe-payment/"},{"name":"Back-end","slug":"Back-end","permalink":"https://redre4per.github.io/categories/Back-end/"},{"name":"Nest.js","slug":"Back-end/Nest-js","permalink":"https://redre4per.github.io/categories/Back-end/Nest-js/"},{"name":"Front-end","slug":"Front-end","permalink":"https://redre4per.github.io/categories/Front-end/"},{"name":"React","slug":"Front-end/React","permalink":"https://redre4per.github.io/categories/Front-end/React/"},{"name":"Other","slug":"Others/Other","permalink":"https://redre4per.github.io/categories/Others/Other/"},{"name":"HTML&CSS","slug":"HTML-CSS","permalink":"https://redre4per.github.io/categories/HTML-CSS/"},{"name":"CSS","slug":"HTML-CSS/CSS","permalink":"https://redre4per.github.io/categories/HTML-CSS/CSS/"},{"name":"Database","slug":"Database","permalink":"https://redre4per.github.io/categories/Database/"},{"name":"MongoDB","slug":"Database/MongoDB","permalink":"https://redre4per.github.io/categories/Database/MongoDB/"},{"name":"Express.js","slug":"Back-end/Express-js","permalink":"https://redre4per.github.io/categories/Back-end/Express-js/"},{"name":"Node.js","slug":"Back-end/Node-js","permalink":"https://redre4per.github.io/categories/Back-end/Node-js/"},{"name":"Axios","slug":"Front-end/Axios","permalink":"https://redre4per.github.io/categories/Front-end/Axios/"},{"name":"Native JavaScript","slug":"JS-TS/Native-JavaScript","permalink":"https://redre4per.github.io/categories/JS-TS/Native-JavaScript/"},{"name":"Chinese notes","slug":"Others/Chinese-notes","permalink":"https://redre4per.github.io/categories/Others/Chinese-notes/"},{"name":"TypeScript","slug":"JS-TS/TypeScript","permalink":"https://redre4per.github.io/categories/JS-TS/TypeScript/"},{"name":"Next.js","slug":"Front-end/Next-js","permalink":"https://redre4per.github.io/categories/Front-end/Next-js/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://redre4per.github.io/tags/ES6/"},{"name":"Promise","slug":"Promise","permalink":"https://redre4per.github.io/tags/Promise/"},{"name":"Test","slug":"Test","permalink":"https://redre4per.github.io/tags/Test/"},{"name":"React-testing-library","slug":"React-testing-library","permalink":"https://redre4per.github.io/tags/React-testing-library/"},{"name":"Stripe","slug":"Stripe","permalink":"https://redre4per.github.io/tags/Stripe/"},{"name":"Payment","slug":"Payment","permalink":"https://redre4per.github.io/tags/Payment/"},{"name":"Nest.js","slug":"Nest-js","permalink":"https://redre4per.github.io/tags/Nest-js/"},{"name":"Mongoose","slug":"Mongoose","permalink":"https://redre4per.github.io/tags/Mongoose/"},{"name":"React","slug":"React","permalink":"https://redre4per.github.io/tags/React/"},{"name":"Hooks","slug":"Hooks","permalink":"https://redre4per.github.io/tags/Hooks/"},{"name":"VSCode","slug":"VSCode","permalink":"https://redre4per.github.io/tags/VSCode/"},{"name":"CSS","slug":"CSS","permalink":"https://redre4per.github.io/tags/CSS/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://redre4per.github.io/tags/MongoDB/"},{"name":"Node.js","slug":"Node-js","permalink":"https://redre4per.github.io/tags/Node-js/"},{"name":"Express.js","slug":"Express-js","permalink":"https://redre4per.github.io/tags/Express-js/"},{"name":"npm","slug":"npm","permalink":"https://redre4per.github.io/tags/npm/"},{"name":"Axios","slug":"Axios","permalink":"https://redre4per.github.io/tags/Axios/"},{"name":"Native JavaScript","slug":"Native-JavaScript","permalink":"https://redre4per.github.io/tags/Native-JavaScript/"},{"name":"Chinese notes","slug":"Chinese-notes","permalink":"https://redre4per.github.io/tags/Chinese-notes/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://redre4per.github.io/tags/TypeScript/"},{"name":"Next.js","slug":"Next-js","permalink":"https://redre4per.github.io/tags/Next-js/"}]}